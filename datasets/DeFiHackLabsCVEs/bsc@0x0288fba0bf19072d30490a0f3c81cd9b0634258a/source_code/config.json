{
    "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/GymSinglePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.12;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\r\\nimport \\\"./interfaces/IWETH.sol\\\";\\r\\nimport \\\"./interfaces/IGymMLM.sol\\\";\\r\\nimport \\\"./interfaces/IPancakeRouter02.sol\\\";\\r\\nimport \\\"./interfaces/IERC20Burnable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\r\\nimport \\\"./interfaces/IPancakePair.sol\\\";\\r\\nimport \\\"./interfaces/IPancakeFactory.sol\\\";\\r\\nimport \\\"@quant-finance/solidity-datetime/contracts/DateTime.sol\\\";\\r\\n/* preserved Line */\\r\\n/* preserved Line */\\r\\n/* preserved Line */\\r\\n/* preserved Line */\\r\\n/* preserved Line */\\r\\n\\r\\n/**\\r\\n * @notice GymSinglePool contract:\\r\\n * - Users can:\\r\\n *   # Deposit GYMNET\\r\\n *   # Withdraw assets\\r\\n */\\r\\n\\r\\ncontract GymSinglePool is ReentrancyGuardUpgradeable, OwnableUpgradeable {\\r\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\r\\n\\r\\n   /**\\r\\n     * @notice Info of each user\\r\\n     * One Address can have many Deposits with different periods. Unlimited Amount.\\r\\n     * Total Depsit Tokens = Total amount of user active stake in all.\\r\\n     * Total Depsit Dollar Value = Total Dollar Value over all staking single pools. Calculated when user deposits tokens, and dollar value is for that exact moment rate.\\r\\n     * level = level qualification for this pool. Used internally, for global qualification please check MLM Contract.\\r\\n     * depositId = incremental ID of deposits, eg. if user has 3 stakings then this value will be 2;\\r\\n     * totalClaimt = Total amount of tokens user claimt. \\r\\n     */\\r\\n    struct UserInfo {\\r\\n        uint256 totalDepositTokens;\\r\\n        uint256 totalDepositDollarValue;\\r\\n        uint256 level;\\r\\n        uint256 depositId;\\r\\n        uint256 totalClaimt;\\r\\n    }\\r\\n\\r\\n   /** \\r\\n     * @notice Info for each staking by ID\\r\\n     * One Address can have many Deposits with different periods. Unlimited Amount.\\r\\n     * depositTokens = amount of tokens for exact deposit.\\r\\n     * depositDollarValue = Dollar value of deposit.\\r\\n     * stakePeriod = Locking Period - from 3 months to 30 months. value is integer\\r\\n     * depositTimestamp = timestamp of deposit\\r\\n     * withdrawalTimestamp = Timestamp when user can withdraw his locked tokens\\r\\n     * rewardsGained = amount of rewards user has gained during the process\\r\\n     * is_finished = checks if user has already withdrawn tokens\\r\\n     */\\r\\n    struct UserDeposits {\\r\\n        uint256 depositTokens;\\r\\n        uint256 depositDollarValue;\\r\\n        uint256 stakePeriod;\\r\\n        uint256 depositTimestamp;\\r\\n        uint256 withdrawalTimestamp;\\r\\n        uint256 rewardsGained;\\r\\n        uint256 rewardsClaimt;\\r\\n        uint256 rewardDebt;\\r\\n        bool is_finished;\\r\\n    }\\r\\n    /**\\r\\n     * @notice Info of Pool\\r\\n     * @param lastRewardBlock: Last block number that reward distribution occurs\\r\\n     * @param accUTacoPerShare: Accumulated rewardPool per share, times 1e18\\r\\n     * @param rewardPerBlock: How many reward tokens will user get per block\\r\\n     */\\r\\n    struct PoolInfo {\\r\\n        uint256 lastRewardBlock;\\r\\n        uint256 accRewardPerShare;\\r\\n        uint256 rewardPerBlock;\\r\\n    }\\r\\n\\r\\n    /// Startblock number\\r\\n    uint256 public startBlock;\\r\\n    uint256 public withdrawFee;\\r\\n\\r\\n     // MLM Contract - RelationShip address\\r\\n    address public relationship;\\r\\n    /// Treasury address where will be sent all unused assets\\r\\n    address public treasuryAddress;\\r\\n    /// Info of pool.\\r\\n    PoolInfo public poolInfo;\\r\\n    /// Info of each user that staked tokens.\\r\\n    mapping(address => UserInfo) public userInfo;\\r\\n\\r\\n    /// accepts user address and id of element to select - returns information about selected staking by id\\r\\n    mapping (address=>UserDeposits[]) public user_deposits;\\r\\n\\r\\n    uint256 private lastChangeBlock;\\r\\n\\r\\n    /// GYMNET token contract address\\r\\n    address public tokenAddress;\\r\\n\\r\\n    /// address of pancake Router\\r\\n    address public pancakeRouterAddress;\\r\\n    /// WBNB and BUSD Token Pair address, element 0 = Address of WBNB Token, element 1= Address of GYMNET \\r\\n    address[] public wbnbAndUSDTTokenArray;\\r\\n    /// GYMNET and WBNB Token Pair address, element 0 = Address of GYMNET, element 1 = Address of WBNB Token, \\r\\n    address[] public GymWBNBPair;\\r\\n\\r\\n    /// Level Qualifications for the pool\\r\\n    uint256[16] public levels;\\r\\n    /// Locking Periods \\r\\n    uint256[6] public months;\\r\\n\\r\\n    /// Amount of Total GYMNET Locked in the pool\\r\\n    uint256 public totalGymnetLocked;\\r\\n\\r\\n    /// Amount of GYMNET all users has claimt over time.\\r\\n    uint256 public totalClaimtInPool;\\r\\n\\r\\n    /// Percent that will be sent to MLM Contract for comission distribution\\r\\n    uint256 public RELATIONSHIP_REWARD;\\r\\n\\r\\n    /// 6% comissions\\r\\n    uint256 public poolRewardsAmount;\\r\\n\\r\\n    address public holderRewardContractAddress;\\r\\n\\r\\n    address public runnerScriptAddress;\\r\\n    uint256 public totalBurntInSinglePool;\\r\\n    bool public isPoolActive;\\r\\n    bool public isInMigrationToVTwo;\\r\\n    uint256 public totalGymnetUnlocked;\\r\\n    uint256 public unlockedTimestampQualification;\\r\\n    address public vaultContractAddress;\\r\\n    address public farmingContractAddress;\\r\\n    /* ========== EVENTS ========== */\\r\\n\\r\\n    event Initialized(address indexed executor, uint256 at);\\r\\n    event Deposit(address indexed user, uint256 amount,uint indexed period);\\r\\n    event Withdraw(address indexed user, uint256 amount,uint indexed period);\\r\\n    event RewardPaid(address indexed token, address indexed user, uint256 amount);\\r\\n    event ClaimUserReward(address indexed user, uint256 amount);\\r\\n\\r\\n\\r\\n    modifier onlyRunnerScript() {\\r\\n        require(msg.sender == runnerScriptAddress || msg.sender == owner(), \\\"Only Runner Script\\\");\\r\\n        _;\\r\\n    }\\r\\n    modifier onlyBank() {\\r\\n        require(msg.sender == vaultContractAddress, \\\"GymFarming:: Only bank\\\");\\r\\n        _;\\r\\n    }\\r\\n    receive() external payable {}\\r\\n\\r\\n    fallback() external payable {}\\r\\n\\r\\n// all initialize parameters are mandatory\\r\\n    function initialize(\\r\\n        uint256 _startBlock,\\r\\n        address _gym,\\r\\n        address _mlm,\\r\\n        uint256 _gymRewardRate,\\r\\n        address _pancakeRouterAddress,\\r\\n        address[] memory _wbnbAndUSDTTokenArray,\\r\\n        address[] memory _GymWBNBPair\\r\\n    ) external initializer {\\r\\n        require(block.number < _startBlock, \\\"SinglePool: Start block must have a bigger value\\\");\\r\\n\\r\\n        startBlock = _startBlock; // Number of Upcoming Block\\r\\n        relationship = _mlm;  // address of MLM contract\\r\\n        tokenAddress = _gym; // address of GYMNET Contract\\r\\n        pancakeRouterAddress = _pancakeRouterAddress; // Address of Pancake Router\\r\\n        wbnbAndUSDTTokenArray = _wbnbAndUSDTTokenArray; // WBNB And USDT Token Addresses [WBNB,USDT]\\r\\n        GymWBNBPair = _GymWBNBPair; // GYMNET And WBNB Token Addresses [GYMNET,WBNB]\\r\\n        runnerScriptAddress = msg.sender;\\r\\n        isPoolActive = false;\\r\\n        isInMigrationToVTwo = false;\\r\\n        RELATIONSHIP_REWARD = 39; // Relationship commission amount\\r\\n        levels = [0, 0, 200, 200, 2000, 4000, 10000, 20000, 40000, 45000, 50000, 60000, 65000, 70000, 75000, 80000]; // Internal Pool Levels\\r\\n        months = [3, 6, 12, 18, 24, 30]; // Locking Periods\\r\\n\\r\\n        poolInfo = PoolInfo({\\r\\n                lastRewardBlock: _startBlock,\\r\\n                rewardPerBlock: _gymRewardRate,\\r\\n                accRewardPerShare: 0\\r\\n            });\\r\\n\\r\\n        lastChangeBlock = _startBlock;\\r\\n\\r\\n        __Ownable_init();\\r\\n        __ReentrancyGuard_init();\\r\\n        \\r\\n        emit Initialized(msg.sender, block.number);\\r\\n    }\\r\\n\\r\\n\\r\\n    function setPoolInfo(uint256 lastRewardBlock,uint256 accRewardPerShare, uint256 rewardPerBlock) external onlyOwner {\\r\\n        poolInfo = PoolInfo({\\r\\n                lastRewardBlock: lastRewardBlock,\\r\\n                accRewardPerShare: accRewardPerShare,\\r\\n                rewardPerBlock: rewardPerBlock\\r\\n            });\\r\\n    }\\r\\n\\r\\n    function updateStartBlock(uint256 _startBlock) external onlyOwner {\\r\\n        startBlock = _startBlock;\\r\\n    }\\r\\n\\r\\n    function setMLMAddress(address _relationship) external onlyOwner {\\r\\n        relationship = _relationship;\\r\\n    }\\r\\n\\r\\n    function setTokenAddress(address _tokenAddress) external onlyOwner {\\r\\n        tokenAddress = _tokenAddress;\\r\\n    }\\r\\n    function setVaultContractAddress(address _vaultContractAddress) external onlyOwner {\\r\\n        vaultContractAddress = _vaultContractAddress;\\r\\n    }\\r\\n    function setFarmingContractAddress(address _farmingContractAddress) external onlyOwner {\\r\\n        farmingContractAddress = _farmingContractAddress;\\r\\n    }\\r\\n\\r\\n    function setRelationshipReward(uint256 _amount) external onlyOwner {\\r\\n        RELATIONSHIP_REWARD = _amount;\\r\\n    }\\r\\n    function setOnlyRunnerScript(address _onlyRunnerScript) external onlyOwner {\\r\\n        runnerScriptAddress = _onlyRunnerScript;\\r\\n    }\\r\\n\\r\\n    function setGymWBNBPair(address[] memory  _GymWBNBPair) external onlyOwner {\\r\\n        GymWBNBPair = _GymWBNBPair;\\r\\n    }\\r\\n    function setPancakeRouterAddress(address _pancakeRouterAddress) external onlyOwner {\\r\\n        pancakeRouterAddress = _pancakeRouterAddress;\\r\\n    }\\r\\n\\r\\n    function setIsPoolActive(bool _isPoolActive) external onlyOwner {\\r\\n        isPoolActive = _isPoolActive;\\r\\n    }\\r\\n    function setIsInMigrationToVTwo(bool _isInMigrationToVTwo) external onlyOwner {\\r\\n        isInMigrationToVTwo = _isInMigrationToVTwo;\\r\\n    }\\r\\n\\r\\n    function setHolderRewardContractAddress(address _holderRewardContractAddress) external onlyOwner {\\r\\n        holderRewardContractAddress = _holderRewardContractAddress;\\r\\n    }\\r\\n\\r\\n\\r\\n    function setWbnbAndUSDTTokenArray(address[] memory _wbnbAndUSDTTokenArray) external onlyOwner {\\r\\n        wbnbAndUSDTTokenArray = _wbnbAndUSDTTokenArray;\\r\\n    }\\r\\n    function setUnlockedTimestampQualification(uint256 _unlockedTimestampQualification) external onlyOwner {\\r\\n        unlockedTimestampQualification = _unlockedTimestampQualification;\\r\\n    }\\r\\n    function setLevels(uint256[16] calldata _levels) external onlyOwner {\\r\\n        levels = _levels;\\r\\n    }\\r\\n\\r\\n     /**\\r\\n     * @notice  Function to set Treasury address\\r\\n     * @param _treasuryAddress Address of treasury address\\r\\n     */\\r\\n    function setTreasuryAddress(address _treasuryAddress) external nonReentrant onlyOwner {\\r\\n        treasuryAddress = _treasuryAddress;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Deposit in given pool\\r\\n     * @param _depositAmount: Amount of want token that user wants to deposit\\r\\n     */\\r\\n    function deposit(\\r\\n        uint256 _depositAmount,\\r\\n        uint8 _periodId,\\r\\n        uint256 _referrerId,\\r\\n        bool isUnlocked\\r\\n    ) external  {\\r\\n        require(isPoolActive,'Contract is not running yet');\\r\\n        IGymMLM(relationship).addGymMLM(msg.sender, _referrerId);\\r\\n        _deposit(_depositAmount,_periodId,isUnlocked);\\r\\n    }\\r\\n    /**\\r\\n     * @notice Deposit in given pool\\r\\n     * @param _depositAmount: Amount of want token that user wants to deposit\\r\\n     */\\r\\n    function depositFromOtherContract(\\r\\n        uint256 _depositAmount,\\r\\n        uint8 _periodId,\\r\\n        bool isUnlocked,\\r\\n        address _from\\r\\n    ) external  {\\r\\n        require(isPoolActive,'Contract is not running yet');\\r\\n        _autoDeposit(_depositAmount,_periodId,isUnlocked,_from);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice To get User level in other contract for single pool.\\r\\n     * @param _user: User address\\r\\n     */\\r\\n    function getUserLevelInSinglePool(address _user) external view returns (uint32) {\\r\\n        uint256 _totalDepositDollarValue = userInfo[_user].totalDepositDollarValue;\\r\\n        uint32 level = 0;\\r\\n        for (uint32 i = 0; i<levels.length ; i++) {\\r\\n            if(_totalDepositDollarValue >= levels[i]) {\\r\\n                level=i;\\r\\n            }\\r\\n        }\\r\\n        return level;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    Should approve allowance before initiating\\r\\n    accepts depositAmount in WEI\\r\\n    periodID - id of months array accordingly\\r\\n    */\\r\\n    function _deposit(\\r\\n        uint256 _depositAmount,\\r\\n        uint8 _periodId,\\r\\n        bool _isUnlocked\\r\\n    ) private {\\r\\n        UserInfo storage user = userInfo[msg.sender];\\r\\n        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\\r\\n        PoolInfo storage pool = poolInfo;\\r\\n        updatePool();\\r\\n\\r\\n        uint256 period = months[_periodId];\\r\\n        uint256 lockTimesamp = DateTime.addMonths(block.timestamp,months[_periodId]);\\r\\n        uint256 burnTokensAmount = 0;\\r\\n\\r\\n        if(!_isUnlocked) {\\r\\n            burnTokensAmount = (_depositAmount * 4) / 100;\\r\\n            totalBurntInSinglePool += burnTokensAmount;\\r\\n            IERC20Burnable(tokenAddress).burnFrom(msg.sender,burnTokensAmount);\\r\\n        }\\r\\n\\r\\n        \\r\\n        uint256 amountToDeposit = _depositAmount - burnTokensAmount;\\r\\n\\r\\n        token.safeTransferFrom(msg.sender, address(this), amountToDeposit);\\r\\n        uint256 UsdValueOfGym = ((amountToDeposit * getPrice())/1e18) / 1e18;\\r\\n\\r\\n        user.totalDepositTokens += amountToDeposit;\\r\\n        user.totalDepositDollarValue += UsdValueOfGym;\\r\\n        totalGymnetLocked += amountToDeposit;\\r\\n        if(_isUnlocked) {\\r\\n            totalGymnetUnlocked += amountToDeposit;\\r\\n            period = 0; \\r\\n            lockTimesamp = DateTime.addSeconds(block.timestamp,months[_periodId]);\\r\\n        }\\r\\n\\r\\n        uint256 rewardDebt = (amountToDeposit * (pool.accRewardPerShare)) / (1e18);\\r\\n        UserDeposits memory depositDetails = UserDeposits(\\r\\n            {\\r\\n                depositTokens: amountToDeposit, \\r\\n                depositDollarValue: UsdValueOfGym,\\r\\n                stakePeriod: period,\\r\\n                depositTimestamp: block.timestamp,\\r\\n                withdrawalTimestamp: lockTimesamp,\\r\\n                rewardsGained: 0,\\r\\n                is_finished: false,\\r\\n                rewardsClaimt: 0,\\r\\n                rewardDebt: rewardDebt\\r\\n            }\\r\\n        );\\r\\n\\r\\n        user_deposits[msg.sender].push(depositDetails);\\r\\n        user.depositId = user_deposits[msg.sender].length;\\r\\n        \\r\\n\\r\\n       for (uint i = 0; i<levels.length ; i++) {\\r\\n            if(user.totalDepositDollarValue >= levels[i]) {\\r\\n                user.level=i;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit Deposit(msg.sender, _depositAmount,_periodId);\\r\\n    }\\r\\n\\r\\n     /**\\r\\n    Should approve allowance before initiating\\r\\n    accepts depositAmount in WEI\\r\\n    periodID - id of months array accordingly\\r\\n    */\\r\\n    function _autoDeposit(\\r\\n        uint256 _depositAmount,\\r\\n        uint8 _periodId,\\r\\n        bool _isUnlocked,\\r\\n        address _from\\r\\n    ) private {\\r\\n        UserInfo storage user = userInfo[_from];\\r\\n        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\\r\\n        PoolInfo storage pool = poolInfo;\\r\\n        token.approve(address(this), _depositAmount);\\r\\n        updatePool();\\r\\n        uint256 period = months[_periodId];\\r\\n        uint256 lockTimesamp = DateTime.addMonths(block.timestamp,months[_periodId]);\\r\\n        uint256 burnTokensAmount = 0;\\r\\n        // if(!_isUnlocked) {\\r\\n        //     uint256 burnTokensAmount = (_depositAmount * 4) / 100;\\r\\n        //     totalBurntInSinglePool += burnTokensAmount;\\r\\n        //     IERC20Burnable(tokenAddress).burnFrom(msg.sender,burnTokensAmount);\\r\\n        // }\\r\\n        uint256 amountToDeposit = _depositAmount - burnTokensAmount;\\r\\n        uint256 UsdValueOfGym = ((amountToDeposit * getPrice())/1e18) / 1e18;\\r\\n\\r\\n        user.totalDepositTokens += amountToDeposit;\\r\\n        user.totalDepositDollarValue += UsdValueOfGym;\\r\\n        totalGymnetLocked += amountToDeposit;\\r\\n        if(_isUnlocked) {\\r\\n            totalGymnetUnlocked += amountToDeposit;\\r\\n            period = 0; \\r\\n            lockTimesamp = DateTime.addSeconds(block.timestamp,months[_periodId]);\\r\\n        }\\r\\n\\r\\n        uint256 rewardDebt = (amountToDeposit * (pool.accRewardPerShare)) / (1e18);\\r\\n        UserDeposits memory depositDetails = UserDeposits(\\r\\n            {\\r\\n                depositTokens: amountToDeposit, \\r\\n                depositDollarValue: UsdValueOfGym,\\r\\n                stakePeriod: period,\\r\\n                depositTimestamp: block.timestamp,\\r\\n                withdrawalTimestamp: lockTimesamp,\\r\\n                rewardsGained: 0,\\r\\n                is_finished: false,\\r\\n                rewardsClaimt: 0,\\r\\n                rewardDebt: rewardDebt\\r\\n            }\\r\\n        );\\r\\n        user_deposits[_from].push(depositDetails);\\r\\n        user.depositId = user_deposits[_from].length;\\r\\n \\r\\n        emit Deposit(_from, amountToDeposit,_periodId);\\r\\n    }\\r\\n\\r\\n     /**\\r\\n     * Returns the latest price\\r\\n     */\\r\\n    function getPrice () public view returns (uint) {\\r\\n        uint256[] memory gymPriceInUSD = IPancakeRouter02(pancakeRouterAddress).getAmountsOut(1000000000000000000,GymWBNBPair);\\r\\n        uint256[] memory BNBPriceInUSD = IPancakeRouter02(pancakeRouterAddress).getAmountsOut(1, wbnbAndUSDTTokenArray);\\r\\n        return gymPriceInUSD[1] * BNBPriceInUSD[1];\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @notice withdraw one claim\\r\\n     * @param _depositId: is the id of user element. \\r\\n     */\\r\\n    function withdraw(\\r\\n        uint256 _depositId\\r\\n    ) external  {\\r\\n        require(_depositId >= 0, \\\"Value is not specified\\\");\\r\\n        updatePool();\\r\\n        _withdraw(_depositId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    Should approve allowance before initiating\\r\\n    accepts _depositId - is the id of user element. \\r\\n    */\\r\\n    function _withdraw(\\r\\n            uint256 _depositId\\r\\n        ) private {\\r\\n            UserInfo storage user = userInfo[msg.sender];\\r\\n            IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\\r\\n            PoolInfo storage pool = poolInfo;\\r\\n            UserDeposits storage depositDetails = user_deposits[msg.sender][_depositId];\\r\\n            if(!isInMigrationToVTwo) {\\r\\n                require(block.timestamp > depositDetails.withdrawalTimestamp,\\\"Locking Period isn't over yet.\\\");\\r\\n            }\\r\\n            require(!depositDetails.is_finished,\\\"You already withdrawn your deposit.\\\");\\r\\n\\r\\n            _claim(_depositId,1);\\r\\n            depositDetails.rewardDebt = (depositDetails.depositTokens * (pool.accRewardPerShare)) / (1e18);\\r\\n\\r\\n            user.totalDepositTokens -=  depositDetails.depositTokens;\\r\\n            user.totalDepositDollarValue -=  depositDetails.depositDollarValue;\\r\\n            totalGymnetLocked -= depositDetails.depositTokens;\\r\\n            if(depositDetails.stakePeriod == 0) {\\r\\n                totalGymnetUnlocked -= depositDetails.depositTokens;\\r\\n            }\\r\\n            \\r\\n            token.safeTransferFrom(address(this),msg.sender, depositDetails.depositTokens);\\r\\n\\r\\n            for (uint i = 0; i<levels.length ; i++) {\\r\\n                if(user.totalDepositDollarValue >= levels[i]) {\\r\\n                    user.level=i;\\r\\n                }\\r\\n            }\\r\\n            depositDetails.is_finished = true;\\r\\n            emit Withdraw(msg.sender,  depositDetails.depositTokens,depositDetails.stakePeriod);\\r\\n\\r\\n\\r\\n        }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @notice Claim rewards you gained over period\\r\\n     * @param _depositId: is the id of user element. \\r\\n     */\\r\\n    function claim(\\r\\n        uint256 _depositId\\r\\n    ) external  {\\r\\n        require(_depositId >= 0, \\\"Value is not specified\\\");\\r\\n        updatePool();\\r\\n        refreshMyLevel(msg.sender);\\r\\n        _claim(_depositId,0);\\r\\n    }\\r\\n\\r\\n   /*\\r\\n    Should approve allowance before initiating\\r\\n    accepts _depositId - is the id of user element. \\r\\n    */\\r\\n    function _claim(\\r\\n            uint256 _depositId,\\r\\n            uint256 fromWithdraw\\r\\n        ) private {\\r\\n            UserInfo storage user = userInfo[msg.sender];\\r\\n            IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\\r\\n            UserDeposits storage depositDetails = user_deposits[msg.sender][_depositId];\\r\\n            PoolInfo storage pool = poolInfo;\\r\\n\\r\\n            uint256 pending = pendingReward(_depositId,msg.sender);\\r\\n\\r\\n            if(fromWithdraw == 0) {\\r\\n                require(pending > 0 ,\\\"No rewards to claim.\\\");\\r\\n            }\\r\\n\\r\\n\\r\\n            if (pending > 0) {\\r\\n                uint256 distributeRewardTokenAmt = (pending * RELATIONSHIP_REWARD) / 100;\\r\\n                token.safeTransfer(relationship, distributeRewardTokenAmt);\\r\\n                IGymMLM(relationship).distributeRewards(pending, address(tokenAddress), msg.sender, 3);\\r\\n\\r\\n                // 6% distribution \\r\\n                uint256 calculateDistrubutionReward = (pending * 6) / 100;\\r\\n                poolRewardsAmount += calculateDistrubutionReward; \\r\\n                \\r\\n                uint256 calcUserRewards = (pending-distributeRewardTokenAmt-calculateDistrubutionReward);\\r\\n                safeRewardTransfer(tokenAddress, msg.sender, calcUserRewards);\\r\\n\\r\\n                user.totalClaimt += calcUserRewards;\\r\\n                totalClaimtInPool += pending;\\r\\n                depositDetails.rewardsClaimt += pending;\\r\\n                depositDetails.rewardDebt = (depositDetails.depositTokens * (pool.accRewardPerShare)) / (1e18);\\r\\n                emit ClaimUserReward(msg.sender,  calcUserRewards);\\r\\n                 depositDetails.rewardsGained = 0;\\r\\n            }\\r\\n            \\r\\n            // token.safeTransferFrom(address(this),msg.sender, depositDetails.rewardsGained);\\r\\n\\r\\n        }\\r\\n\\r\\n\\r\\n      \\r\\n   /*\\r\\n    transfers pool commisions to management\\r\\n    */\\r\\n    function transferPoolRewards() public onlyRunnerScript {\\r\\n            require(address(holderRewardContractAddress) != address(0x0),\\\"Holder Reward Address::SET_ZERO_ADDRESS\\\");\\r\\n            IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\\r\\n            token.safeTransfer(holderRewardContractAddress, poolRewardsAmount);\\r\\n            // token.safeTransfer(relationship, poolRewardsAmount/2);\\r\\n            poolRewardsAmount = 0;\\r\\n        }  \\r\\n\\r\\n\\r\\n    /**\\r\\n     * @notice  Safe transfer function for reward tokens\\r\\n     * @param _rewardToken Address of reward token contract\\r\\n     * @param _to Address of reciever\\r\\n     * @param _amount Amount of reward tokens to transfer\\r\\n     */\\r\\n    function safeRewardTransfer(\\r\\n        address _rewardToken,\\r\\n        address _to,\\r\\n        uint256 _amount\\r\\n    ) internal {\\r\\n        uint256 _bal = IERC20Upgradeable(_rewardToken).balanceOf(address(this));\\r\\n        if (_amount > _bal) {\\r\\n            require(IERC20Upgradeable(_rewardToken).transfer(_to, _bal), \\\"GymSinglePool:: Transfer failed\\\");\\r\\n        } else {\\r\\n            require(IERC20Upgradeable(_rewardToken).transfer(_to, _amount), \\\"GymSinglePool:: Transfer failed\\\");\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * @notice To get User Info in other contract.\\r\\n     */\\r\\n    function getUserInfo(address _user) external view returns (UserInfo memory) {\\r\\n        return userInfo[_user];\\r\\n    }\\r\\n\\r\\n        /**\\r\\n     * @notice View function to see pending reward on frontend.\\r\\n     * @param _depositId: Staking pool id\\r\\n     * @param _user: User address\\r\\n     */\\r\\n    function pendingReward(uint256 _depositId, address _user) public view returns (uint256) {\\r\\n        UserDeposits storage depositDetails = user_deposits[_user][_depositId];\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        PoolInfo storage pool = poolInfo;\\r\\n        if(depositDetails.is_finished == true || depositDetails.stakePeriod == 0){\\r\\n            return 0;\\r\\n        }\\r\\n      \\r\\n        uint256 _accRewardPerShare = pool.accRewardPerShare;\\r\\n        uint256 sharesTotal = totalGymnetLocked-totalGymnetUnlocked;\\r\\n\\r\\n        if (block.number > pool.lastRewardBlock && sharesTotal != 0) {\\r\\n            uint256 _multiplier = block.number - pool.lastRewardBlock;\\r\\n            uint256 _reward = (_multiplier * pool.rewardPerBlock);\\r\\n             _accRewardPerShare = _accRewardPerShare + ((_reward * 1e18) / sharesTotal);\\r\\n        }\\r\\n\\r\\n        return (depositDetails.depositTokens * _accRewardPerShare) / (1e18) - (depositDetails.rewardDebt);\\r\\n    }\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @notice Update reward variables of the given pool to be up-to-date.\\r\\n     */\\r\\n    function updatePool() public {\\r\\n        PoolInfo storage pool = poolInfo;\\r\\n        if (block.number <= pool.lastRewardBlock) {\\r\\n            return;\\r\\n        }\\r\\n        uint256 sharesTotal = totalGymnetLocked-totalGymnetUnlocked;\\r\\n        if (sharesTotal == 0) {\\r\\n            pool.lastRewardBlock = block.number;\\r\\n            return;\\r\\n        }\\r\\n        uint256 multiplier = block.number - pool.lastRewardBlock;\\r\\n        if (multiplier <= 0) {\\r\\n            return;\\r\\n        }\\r\\n        uint256 _rewardPerBlock = pool.rewardPerBlock;\\r\\n        uint256 _reward = (multiplier * _rewardPerBlock);\\r\\n        pool.accRewardPerShare = pool.accRewardPerShare + ((_reward * 1e18) / sharesTotal);\\r\\n        pool.lastRewardBlock = block.number;\\r\\n    }\\r\\n    /**\\r\\n     * @notice Claim All Rewards in one Transaction Internat Function.\\r\\n     * If reinvest = true, Rewards will be reinvested as a new Staking\\r\\n     * Reinvest Period Id is the id of months element\\r\\n     */\\r\\n    function _claimAll(bool reinvest,uint8 reinvestPeriodId) private {\\r\\n        UserInfo storage user = userInfo[msg.sender];\\r\\n        IERC20Upgradeable token = IERC20Upgradeable(tokenAddress);\\r\\n        PoolInfo storage pool = poolInfo;\\r\\n         updatePool();\\r\\n         uint256 distributeRewardTokenAmtTotal = 0;\\r\\n         uint256 calcUserRewardsTotal = 0;\\r\\n         uint256 totalDistribute = 0;\\r\\n        for (uint256 i = 0; i<user.depositId ; i++) {\\r\\n            UserDeposits storage depositDetails = user_deposits[msg.sender][i];\\r\\n            uint256 pending = pendingReward(i,msg.sender);\\r\\n            totalDistribute += pending;\\r\\n            if (pending > 0) {\\r\\n                uint256 distributeRewardTokenAmt = (pending * RELATIONSHIP_REWARD) / 100;\\r\\n                 distributeRewardTokenAmtTotal += distributeRewardTokenAmt;\\r\\n                // 6% distribution \\r\\n                uint256 calculateDistrubutionReward = (pending * 6) / 100;\\r\\n                poolRewardsAmount += calculateDistrubutionReward; \\r\\n                \\r\\n                uint256 calcUserRewards = (pending-distributeRewardTokenAmt-calculateDistrubutionReward);\\r\\n                calcUserRewardsTotal += calcUserRewards;\\r\\n\\r\\n                user.totalClaimt += calcUserRewards;\\r\\n                totalClaimtInPool += pending;\\r\\n                depositDetails.rewardsClaimt += pending;\\r\\n                depositDetails.rewardDebt = (depositDetails.depositTokens * (pool.accRewardPerShare)) / (1e18);\\r\\n                emit ClaimUserReward(msg.sender,  calcUserRewards);\\r\\n                 depositDetails.rewardsGained = 0;\\r\\n            }\\r\\n            \\r\\n        }\\r\\n        token.safeTransfer(relationship, distributeRewardTokenAmtTotal);\\r\\n        IGymMLM(relationship).distributeRewards(totalDistribute, address(tokenAddress), msg.sender, 3);\\r\\n        safeRewardTransfer(tokenAddress, msg.sender, calcUserRewardsTotal);\\r\\n        if(reinvest == true) {\\r\\n          _deposit(calcUserRewardsTotal,reinvestPeriodId,false);\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * @notice Claim All Rewards in one Transaction.\\r\\n     */\\r\\n    function claimAll() public {\\r\\n         refreshMyLevel(msg.sender);\\r\\n        _claimAll(false,0);\\r\\n    }\\r\\n    /**\\r\\n     * @notice Claim and Reinvest all rewards public function to trigger internal _claimAll function.\\r\\n     */\\r\\n    function claimAndReinvest(bool reinvest,uint8 periodId) public {\\r\\n        require(isPoolActive,'Contract is not running yet');\\r\\n        _claimAll(reinvest,periodId);\\r\\n    }\\r\\n\\r\\n    function refreshMyLevel(address _user) public {\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        for (uint i = 0; i<levels.length ; i++) {\\r\\n            if(user.totalDepositDollarValue >= levels[i]) {\\r\\n                user.level=i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    function totalLockedTokens(address _user) public view returns (uint256) {\\r\\n        UserInfo storage user = userInfo[_user];\\r\\n        uint256 totalDepositLocked = 0;\\r\\n        for (uint256 i = 0; i<user.depositId ; i++) {\\r\\n            UserDeposits storage depositDetails = user_deposits[_user][i];\\r\\n            if(depositDetails.stakePeriod != 0 && !depositDetails.is_finished) {\\r\\n                totalDepositLocked += depositDetails.depositTokens;\\r\\n            } \\r\\n        }\\r\\n        return totalDepositLocked;\\r\\n    }\\r\\n\\r\\n    function switchToUnlocked(uint256 _depositId) public {\\r\\n        UserInfo storage user = userInfo[msg.sender];\\r\\n        UserDeposits storage depositDetails = user_deposits[msg.sender][_depositId];\\r\\n        require(depositDetails.depositTimestamp <= unlockedTimestampQualification,'Function is only for Users that deposited before Unlocked Staking Upgrade');\\r\\n        _claim(_depositId,1);\\r\\n        uint256 lockTimesamp = DateTime.addSeconds(block.timestamp,1);\\r\\n\\r\\n        depositDetails.stakePeriod = 0;\\r\\n        depositDetails.withdrawalTimestamp = lockTimesamp;\\r\\n        totalGymnetUnlocked += depositDetails.depositTokens;\\r\\n\\r\\n    }\\r\\n\\r\\n    \\r\\n\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.12;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 wad) external;\\n\\n    function transfer(address dst, uint256 wad) external;\\n\\n    function balanceOf(address dst) external view returns (uint256);\\n\\n    event Deposit(address indexed dst, uint256 wad);\\n    event Withdrawal(address indexed src, uint256 wad);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGymMLM.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.12;\\r\\n\\r\\ninterface IGymMLM {\\r\\n    function isOnGymMLM(address) external view returns (bool);\\r\\n\\r\\n    function addGymMLM(address, uint256) external;\\r\\n\\r\\n    function distributeRewards(\\r\\n        uint256,\\r\\n        address,\\r\\n        address,\\r\\n        uint32\\r\\n    ) external;\\r\\n\\r\\n    function updateInvestment(address _user, uint256 _newInvestment) external;\\r\\n\\r\\n    function investment(address _user) external view returns (uint256);\\r\\n\\r\\n    function getPendingRewards(address, uint32) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IPancakeRouter02.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.12;\\n\\nimport \\\"./IPancakeRouter01.sol\\\";\\n\\ninterface IPancakeRouter02 is IPancakeRouter01 {\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable;\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.12;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\ninterface IERC20Burnable is IERC20Upgradeable {\\n    function burn(uint256 _amount) external;\\n\\n    function burnFrom(address _account, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPancakePair.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\r\\n\\r\\ninterface IPancakePair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint value);\\r\\n    event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n    function symbol() external pure returns (string memory);\\r\\n    function decimals() external pure returns (uint8);\\r\\n    function totalSupply() external view returns (uint);\\r\\n    function balanceOf(address owner) external view returns (uint);\\r\\n    function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n    function approve(address spender, uint value) external returns (bool);\\r\\n    function transfer(address to, uint value) external returns (bool);\\r\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n    function nonces(address owner) external view returns (uint);\\r\\n\\r\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\r\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint amount0In,\\r\\n        uint amount1In,\\r\\n        uint amount0Out,\\r\\n        uint amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\r\\n    function factory() external view returns (address);\\r\\n    function token0() external view returns (address);\\r\\n    function token1() external view returns (address);\\r\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n    function price0CumulativeLast() external view returns (uint);\\r\\n    function price1CumulativeLast() external view returns (uint);\\r\\n    function kLast() external view returns (uint);\\r\\n\\r\\n    function mint(address to) external returns (uint liquidity);\\r\\n    function burn(address to) external returns (uint amount0, uint amount1);\\r\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\r\\n    function skim(address to) external;\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IPancakeFactory.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\r\\n\\r\\ninterface IPancakeFactory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n    function allPairs(uint) external view returns (address pair);\\r\\n    function allPairsLength() external view returns (uint);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n    function setFeeToSetter(address) external;\\r\\n}\"\r\n    },\r\n    \"@quant-finance/solidity-datetime/contracts/DateTime.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// ----------------------------------------------------------------------------\\n// DateTime Library v2.0\\n//\\n// A gas-efficient Solidity date and time library\\n//\\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\n//\\n// Tested date range 1970/01/01 to 2345/12/31\\n//\\n// Conventions:\\n// Unit      | Range         | Notes\\n// :-------- |:-------------:|:-----\\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\\n// year      | 1970 ... 2345 |\\n// month     | 1 ... 12      |\\n// day       | 1 ... 31      |\\n// hour      | 0 ... 23      |\\n// minute    | 0 ... 59      |\\n// second    | 0 ... 59      |\\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\\n//\\n//\\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\\n// ----------------------------------------------------------------------------\\n\\nlibrary DateTime {\\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\\n    uint256 constant SECONDS_PER_MINUTE = 60;\\n    int256 constant OFFSET19700101 = 2440588;\\n\\n    uint256 constant DOW_MON = 1;\\n    uint256 constant DOW_TUE = 2;\\n    uint256 constant DOW_WED = 3;\\n    uint256 constant DOW_THU = 4;\\n    uint256 constant DOW_FRI = 5;\\n    uint256 constant DOW_SAT = 6;\\n    uint256 constant DOW_SUN = 7;\\n\\n    // ------------------------------------------------------------------------\\n    // Calculate the number of days from 1970/01/01 to year/month/day using\\n    // the date conversion algorithm from\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\\n    //\\n    // days = day\\n    //      - 32075\\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\\n    //      - offset\\n    // ------------------------------------------------------------------------\\n    function _daysFromDate(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day\\n    ) internal pure returns (uint256 _days) {\\n        require(year >= 1970);\\n        int256 _year = int256(year);\\n        int256 _month = int256(month);\\n        int256 _day = int256(day);\\n\\n        int256 __days =\\n            _day -\\n                32075 +\\n                (1461 * (_year + 4800 + (_month - 14) / 12)) /\\n                4 +\\n                (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\\n                12 -\\n                (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\\n                4 -\\n                OFFSET19700101;\\n\\n        _days = uint256(__days);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Calculate year/month/day from the number of days since 1970/01/01 using\\n    // the date conversion algorithm from\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\\n    //\\n    // int L = days + 68569 + offset\\n    // int N = 4 * L / 146097\\n    // L = L - (146097 * N + 3) / 4\\n    // year = 4000 * (L + 1) / 1461001\\n    // L = L - 1461 * year / 4 + 31\\n    // month = 80 * L / 2447\\n    // dd = L - 2447 * month / 80\\n    // L = month / 11\\n    // month = month + 2 - 12 * L\\n    // year = 100 * (N - 49) + year + L\\n    // ------------------------------------------------------------------------\\n    function _daysToDate(uint256 _days)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day\\n        )\\n    {\\n        int256 __days = int256(_days);\\n\\n        int256 L = __days + 68569 + OFFSET19700101;\\n        int256 N = (4 * L) / 146097;\\n        L = L - (146097 * N + 3) / 4;\\n        int256 _year = (4000 * (L + 1)) / 1461001;\\n        L = L - (1461 * _year) / 4 + 31;\\n        int256 _month = (80 * L) / 2447;\\n        int256 _day = L - (2447 * _month) / 80;\\n        L = _month / 11;\\n        _month = _month + 2 - 12 * L;\\n        _year = 100 * (N - 49) + _year + L;\\n\\n        year = uint256(_year);\\n        month = uint256(_month);\\n        day = uint256(_day);\\n    }\\n\\n    function timestampFromDate(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day\\n    ) internal pure returns (uint256 timestamp) {\\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\\n    }\\n\\n    function timestampFromDateTime(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day,\\n        uint256 hour,\\n        uint256 minute,\\n        uint256 second\\n    ) internal pure returns (uint256 timestamp) {\\n        timestamp =\\n            _daysFromDate(year, month, day) *\\n            SECONDS_PER_DAY +\\n            hour *\\n            SECONDS_PER_HOUR +\\n            minute *\\n            SECONDS_PER_MINUTE +\\n            second;\\n    }\\n\\n    function timestampToDate(uint256 timestamp)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day\\n        )\\n    {\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n\\n    function timestampToDateTime(uint256 timestamp)\\n        internal\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day,\\n            uint256 hour,\\n            uint256 minute,\\n            uint256 second\\n        )\\n    {\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        uint256 secs = timestamp % SECONDS_PER_DAY;\\n        hour = secs / SECONDS_PER_HOUR;\\n        secs = secs % SECONDS_PER_HOUR;\\n        minute = secs / SECONDS_PER_MINUTE;\\n        second = secs % SECONDS_PER_MINUTE;\\n    }\\n\\n    function isValidDate(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day\\n    ) internal pure returns (bool valid) {\\n        if (year >= 1970 && month > 0 && month <= 12) {\\n            uint256 daysInMonth = _getDaysInMonth(year, month);\\n            if (day > 0 && day <= daysInMonth) {\\n                valid = true;\\n            }\\n        }\\n    }\\n\\n    function isValidDateTime(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day,\\n        uint256 hour,\\n        uint256 minute,\\n        uint256 second\\n    ) internal pure returns (bool valid) {\\n        if (isValidDate(year, month, day)) {\\n            if (hour < 24 && minute < 60 && second < 60) {\\n                valid = true;\\n            }\\n        }\\n    }\\n\\n    function isLeapYear(uint256 timestamp)\\n        internal\\n        pure\\n        returns (bool leapYear)\\n    {\\n        (uint256 year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        leapYear = _isLeapYear(year);\\n    }\\n\\n    function _isLeapYear(uint256 year) internal pure returns (bool leapYear) {\\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\\n    }\\n\\n    function isWeekDay(uint256 timestamp) internal pure returns (bool weekDay) {\\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\\n    }\\n\\n    function isWeekEnd(uint256 timestamp) internal pure returns (bool weekEnd) {\\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\\n    }\\n\\n    function getDaysInMonth(uint256 timestamp)\\n        internal\\n        pure\\n        returns (uint256 daysInMonth)\\n    {\\n        (uint256 year, uint256 month, ) =\\n            _daysToDate(timestamp / SECONDS_PER_DAY);\\n        daysInMonth = _getDaysInMonth(year, month);\\n    }\\n\\n    function _getDaysInMonth(uint256 year, uint256 month)\\n        internal\\n        pure\\n        returns (uint256 daysInMonth)\\n    {\\n        if (\\n            month == 1 ||\\n            month == 3 ||\\n            month == 5 ||\\n            month == 7 ||\\n            month == 8 ||\\n            month == 10 ||\\n            month == 12\\n        ) {\\n            daysInMonth = 31;\\n        } else if (month != 2) {\\n            daysInMonth = 30;\\n        } else {\\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\\n        }\\n    }\\n\\n    // 1 = Monday, 7 = Sunday\\n    function getDayOfWeek(uint256 timestamp)\\n        internal\\n        pure\\n        returns (uint256 dayOfWeek)\\n    {\\n        uint256 _days = timestamp / SECONDS_PER_DAY;\\n        dayOfWeek = ((_days + 3) % 7) + 1;\\n    }\\n\\n    function getYear(uint256 timestamp) internal pure returns (uint256 year) {\\n        (year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n\\n    function getMonth(uint256 timestamp) internal pure returns (uint256 month) {\\n        (, month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n\\n    function getDay(uint256 timestamp) internal pure returns (uint256 day) {\\n        (, , day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n\\n    function getHour(uint256 timestamp) internal pure returns (uint256 hour) {\\n        uint256 secs = timestamp % SECONDS_PER_DAY;\\n        hour = secs / SECONDS_PER_HOUR;\\n    }\\n\\n    function getMinute(uint256 timestamp)\\n        internal\\n        pure\\n        returns (uint256 minute)\\n    {\\n        uint256 secs = timestamp % SECONDS_PER_HOUR;\\n        minute = secs / SECONDS_PER_MINUTE;\\n    }\\n\\n    function getSecond(uint256 timestamp)\\n        internal\\n        pure\\n        returns (uint256 second)\\n    {\\n        second = timestamp % SECONDS_PER_MINUTE;\\n    }\\n\\n    function addYears(uint256 timestamp, uint256 _years)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        (uint256 year, uint256 month, uint256 day) =\\n            _daysToDate(timestamp / SECONDS_PER_DAY);\\n        year += _years;\\n        uint256 daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp =\\n            _daysFromDate(year, month, day) *\\n            SECONDS_PER_DAY +\\n            (timestamp % SECONDS_PER_DAY);\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addMonths(uint256 timestamp, uint256 _months)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        (uint256 year, uint256 month, uint256 day) =\\n            _daysToDate(timestamp / SECONDS_PER_DAY);\\n        month += _months;\\n        year += (month - 1) / 12;\\n        month = ((month - 1) % 12) + 1;\\n        uint256 daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp =\\n            _daysFromDate(year, month, day) *\\n            SECONDS_PER_DAY +\\n            (timestamp % SECONDS_PER_DAY);\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addDays(uint256 timestamp, uint256 _days)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addHours(uint256 timestamp, uint256 _hours)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addMinutes(uint256 timestamp, uint256 _minutes)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addSeconds(uint256 timestamp, uint256 _seconds)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        newTimestamp = timestamp + _seconds;\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function subYears(uint256 timestamp, uint256 _years)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        (uint256 year, uint256 month, uint256 day) =\\n            _daysToDate(timestamp / SECONDS_PER_DAY);\\n        year -= _years;\\n        uint256 daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp =\\n            _daysFromDate(year, month, day) *\\n            SECONDS_PER_DAY +\\n            (timestamp % SECONDS_PER_DAY);\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subMonths(uint256 timestamp, uint256 _months)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        (uint256 year, uint256 month, uint256 day) =\\n            _daysToDate(timestamp / SECONDS_PER_DAY);\\n        uint256 yearMonth = year * 12 + (month - 1) - _months;\\n        year = yearMonth / 12;\\n        month = (yearMonth % 12) + 1;\\n        uint256 daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp =\\n            _daysFromDate(year, month, day) *\\n            SECONDS_PER_DAY +\\n            (timestamp % SECONDS_PER_DAY);\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subDays(uint256 timestamp, uint256 _days)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subHours(uint256 timestamp, uint256 _hours)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subMinutes(uint256 timestamp, uint256 _minutes)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subSeconds(uint256 timestamp, uint256 _seconds)\\n        internal\\n        pure\\n        returns (uint256 newTimestamp)\\n    {\\n        newTimestamp = timestamp - _seconds;\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function diffYears(uint256 fromTimestamp, uint256 toTimestamp)\\n        internal\\n        pure\\n        returns (uint256 _years)\\n    {\\n        require(fromTimestamp <= toTimestamp);\\n        (uint256 fromYear, , ) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\n        (uint256 toYear, , ) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\n        _years = toYear - fromYear;\\n    }\\n\\n    function diffMonths(uint256 fromTimestamp, uint256 toTimestamp)\\n        internal\\n        pure\\n        returns (uint256 _months)\\n    {\\n        require(fromTimestamp <= toTimestamp);\\n        (uint256 fromYear, uint256 fromMonth, ) =\\n            _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\n        (uint256 toYear, uint256 toMonth, ) =\\n            _daysToDate(toTimestamp / SECONDS_PER_DAY);\\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\\n    }\\n\\n    function diffDays(uint256 fromTimestamp, uint256 toTimestamp)\\n        internal\\n        pure\\n        returns (uint256 _days)\\n    {\\n        require(fromTimestamp <= toTimestamp);\\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\\n    }\\n\\n    function diffHours(uint256 fromTimestamp, uint256 toTimestamp)\\n        internal\\n        pure\\n        returns (uint256 _hours)\\n    {\\n        require(fromTimestamp <= toTimestamp);\\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\\n    }\\n\\n    function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp)\\n        internal\\n        pure\\n        returns (uint256 _minutes)\\n    {\\n        require(fromTimestamp <= toTimestamp);\\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\\n    }\\n\\n    function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp)\\n        internal\\n        pure\\n        returns (uint256 _seconds)\\n    {\\n        require(fromTimestamp <= toTimestamp);\\n        _seconds = toTimestamp - fromTimestamp;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPancakeRouter01.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.12;\\n\\ninterface IPancakeRouter01 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function addLiquidityETH(\\n        address token,\\n        uint256 amountTokenDesired,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        returns (\\n            uint256 amountToken,\\n            uint256 amountETH,\\n            uint256 liquidity\\n        );\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETH(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint256 liquidity,\\n        uint256 amountTokenMin,\\n        uint256 amountETHMin,\\n        address to,\\n        uint256 deadline,\\n        bool approveMax,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external returns (uint256 amountToken, uint256 amountETH);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external payable returns (uint256[] memory amounts);\\n\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) external pure returns (uint256 amountB);\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountOut);\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountIn);\\n\\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = _setInitializedVersion(1);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        bool isTopLevelCall = _setInitializedVersion(version);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(version);\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        _setInitializedVersion(type(uint8).max);\\n    }\\n\\n    function _setInitializedVersion(uint8 version) private returns (bool) {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\\n        // of initializers, because in other contexts the contract may have been reentered.\\n        if (_initializing) {\\n            require(\\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\\n                \\\"Initializable: contract is already initialized\\\"\\n            );\\n            return false;\\n        } else {\\n            require(_initialized < version, \\\"Initializable: contract is already initialized\\\");\\n            _initialized = version;\\n            return true;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}",
    "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimUserReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"at\",\"type\":\"uint256\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"GymWBNBPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RELATIONSHIP_REWARD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"reinvest\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"periodId\",\"type\":\"uint8\"}],\"name\":\"claimAndReinvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_periodId\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_referrerId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isUnlocked\",\"type\":\"bool\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_periodId\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isUnlocked\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"depositFromOtherContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"farmingContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalDepositTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDepositDollarValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClaimt\",\"type\":\"uint256\"}],\"internalType\":\"struct GymSinglePool.UserInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getUserLevelInSinglePool\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holderRewardContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_gym\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mlm\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gymRewardRate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_pancakeRouterAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_wbnbAndUSDTTokenArray\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_GymWBNBPair\",\"type\":\"address[]\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInMigrationToVTwo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPoolActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"months\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pancakeRouterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accRewardPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolRewardsAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"refreshMyLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relationship\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"runnerScriptAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_farmingContractAddress\",\"type\":\"address\"}],\"name\":\"setFarmingContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_GymWBNBPair\",\"type\":\"address[]\"}],\"name\":\"setGymWBNBPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holderRewardContractAddress\",\"type\":\"address\"}],\"name\":\"setHolderRewardContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isInMigrationToVTwo\",\"type\":\"bool\"}],\"name\":\"setIsInMigrationToVTwo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isPoolActive\",\"type\":\"bool\"}],\"name\":\"setIsPoolActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[16]\",\"name\":\"_levels\",\"type\":\"uint256[16]\"}],\"name\":\"setLevels\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_relationship\",\"type\":\"address\"}],\"name\":\"setMLMAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_onlyRunnerScript\",\"type\":\"address\"}],\"name\":\"setOnlyRunnerScript\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pancakeRouterAddress\",\"type\":\"address\"}],\"name\":\"setPancakeRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accRewardPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardPerBlock\",\"type\":\"uint256\"}],\"name\":\"setPoolInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setRelationshipReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasuryAddress\",\"type\":\"address\"}],\"name\":\"setTreasuryAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_unlockedTimestampQualification\",\"type\":\"uint256\"}],\"name\":\"setUnlockedTimestampQualification\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultContractAddress\",\"type\":\"address\"}],\"name\":\"setVaultContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_wbnbAndUSDTTokenArray\",\"type\":\"address[]\"}],\"name\":\"setWbnbAndUSDTTokenArray\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositId\",\"type\":\"uint256\"}],\"name\":\"switchToUnlocked\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBurntInSinglePool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalClaimtInPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalGymnetLocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalGymnetUnlocked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"totalLockedTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferPoolRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasuryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockedTimestampQualification\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"}],\"name\":\"updateStartBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalDepositTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDepositDollarValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClaimt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"user_deposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"depositTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositDollarValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakePeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsGained\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardsClaimt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"is_finished\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"wbnbAndUSDTTokenArray\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depositId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
    "ContractName": "GymSinglePool",
    "CompilerVersion": "v0.8.12+commit.f00d7308",
    "OptimizationUsed": "1",
    "Runs": "200",
    "ConstructorArguments": "",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": ""
}