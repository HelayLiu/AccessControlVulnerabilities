{
    "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/RewardVaultDelegator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\nimport \\\"./Adminable.sol\\\";\\nimport \\\"./DelegatorInterface.sol\\\";\\n\\ncontract RewardVaultDelegator is DelegatorInterface, Adminable {\\n\\n    constructor(\\n        address payable _admin,\\n        address _distributor,\\n        uint64 _defaultExpireDuration,\\n        address implementation_){\\n        admin = payable(msg.sender);\\n        // Creator of the contract is admin during initialization\\n        // First delegate gets to initialize the delegator (i.e. storage contract)\\n        delegateTo(implementation_, abi.encodeWithSignature(\\\"initialize(address,address,uint64)\\\",\\n            _admin,\\n            _distributor,\\n            _defaultExpireDuration\\n            ));\\n        implementation = implementation_;\\n        // Set the proper admin now that initialization is done\\n        admin = _admin;\\n    }\\n\\n    /**\\n     * Called by the admin to update the implementation of the delegator\\n     * @param implementation_ The address of the new implementation for delegation\\n     */\\n    function setImplementation(address implementation_) public override onlyAdmin {\\n        address oldImplementation = implementation;\\n        implementation = implementation_;\\n        emit NewImplementation(oldImplementation, implementation);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/DelegatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.15;\\n\\nabstract contract DelegatorInterface {\\n    /**\\n     * Implementation address for this contract\\n     */\\n    address public implementation;\\n\\n    /**\\n     * Emitted when implementation is changed\\n     */\\n    event NewImplementation(address oldImplementation, address newImplementation);\\n\\n    /**\\n     * Called by the admin to update the implementation of the delegator\\n     * @param implementation_ The address of the new implementation for delegation\\n     */\\n    function setImplementation(address implementation_) public virtual;\\n\\n    /**\\n     * Internal method to delegate execution to another contract\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\n     * @param callee The contract to delegatecall\\n     * @param data The raw data to delegatecall\\n     * @return The returned bytes from the delegatecall\\n     */\\n    function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\\n        assembly {\\n            if eq(success, 0) {\\n                revert(add(returnData, 0x20), returndatasize())\\n            }\\n        }\\n        return returnData;\\n    }\\n\\n    /**\\n     * Delegates execution to the implementation contract\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\n     * @param data The raw data to delegatecall\\n     * @return The returned bytes from the delegatecall\\n     */\\n    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\\n        return delegateTo(implementation, data);\\n    }\\n\\n    /**\\n     * Delegates execution to an implementation contract\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\n     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\\n     * @param data The raw data to delegatecall\\n     * @return The returned bytes from the delegatecall\\n     */\\n    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\\\"delegateToImplementation(bytes)\\\", data));\\n        assembly {\\n            if eq(success, 0) {\\n                revert(add(returnData, 0x20), returndatasize())\\n            }\\n        }\\n        return abi.decode(returnData, (bytes));\\n    }\\n\\n    /**\\n     * Delegates execution to an implementation contract\\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\\n     */\\n    fallback() external payable {\\n        _fallback();\\n    }\\n\\n    receive() external payable {\\n        _fallback();\\n    }\\n\\n    function _fallback() internal {\\n        // delegate all other functions to current implementation\\n        if (msg.data.length > 0) {\\n            (bool success, ) = implementation.delegatecall(msg.data);\\n            assembly {\\n                let free_mem_ptr := mload(0x40)\\n                returndatacopy(free_mem_ptr, 0, returndatasize())\\n                switch success\\n                case 0 {\\n                    revert(free_mem_ptr, returndatasize())\\n                }\\n                default {\\n                    return(free_mem_ptr, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/Adminable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.15;\\n\\nabstract contract Adminable {\\n    address payable public admin;\\n    address payable public pendingAdmin;\\n    address payable public developer;\\n\\n    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\n    event NewAdmin(address oldAdmin, address newAdmin);\\n\\n    constructor() {\\n        developer = payable(msg.sender);\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"caller must be admin\\\");\\n        _;\\n    }\\n    modifier onlyAdminOrDeveloper() {\\n        require(msg.sender == admin || msg.sender == developer, \\\"caller must be admin or developer\\\");\\n        _;\\n    }\\n\\n    function setPendingAdmin(address payable newPendingAdmin) external virtual onlyAdmin {\\n        // Save current value, if any, for inclusion in log\\n        address oldPendingAdmin = pendingAdmin;\\n        // Store pendingAdmin with value newPendingAdmin\\n        pendingAdmin = newPendingAdmin;\\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n    }\\n\\n    function acceptAdmin() external virtual {\\n        require(msg.sender == pendingAdmin, \\\"only pendingAdmin can accept admin\\\");\\n        // Save current values for inclusion in log\\n        address oldAdmin = admin;\\n        address oldPendingAdmin = pendingAdmin;\\n        // Store admin with value pendingAdmin\\n        admin = payable(oldPendingAdmin);\\n        // Clear the pending value\\n        pendingAdmin = payable(0);\\n        emit NewAdmin(oldAdmin, admin);\\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}",
    "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_distributor\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_defaultExpireDuration\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"NewAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldImplementation\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"NewImplementation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPendingAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"NewPendingAdmin\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"delegateToImplementation\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"delegateToViewImplementation\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"developer\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"}],\"name\":\"setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"setPendingAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
    "ContractName": "RewardVaultDelegator",
    "CompilerVersion": "v0.8.15+commit.e14f2714",
    "OptimizationUsed": "1",
    "Runs": "200",
    "ConstructorArguments": "000000000000000000000000d67dfbbbe96d250331fc235c76dfb86dccc5e6f9000000000000000000000000d67dfbbbe96d250331fc235c76dfb86dccc5e6f9000000000000000000000000000000000000000000000000000000000076a70000000000000000000000000001112546736a99178bfebdd2678187a7d5ac3006",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "",
    "Proxy": "1",
    "Implementation": "0x3d11015d9044cabbb2504448e37f20d0d56e36f8",
    "SwarmSource": ""
}