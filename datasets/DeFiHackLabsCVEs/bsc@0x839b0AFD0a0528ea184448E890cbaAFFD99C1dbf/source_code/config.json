{
    "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBiswapFactoryV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\ninterface IBiswapFactoryV3 {\\n\\n    /// @notice emit when successfully create a new pool (calling iBiswapFactoryV3#newPool)\\n    /// @param tokenX address of erc-20 tokenX\\n    /// @param tokenY address of erc-20 tokenY\\n    /// @param fee fee amount of swap (3000 means 0.3%)\\n    /// @param pointDelta minimum number of distance between initialized or limitorder points\\n    /// @param pool address of swap pool\\n    event NewPool(\\n        address indexed tokenX,\\n        address indexed tokenY,\\n        uint16 indexed fee,\\n        uint24 pointDelta,\\n        address pool\\n    );\\n\\n    /// @notice emit when enabled new fee\\n    /// @param fee new available fee\\n    /// @param pointDelta delta between points on new fee\\n    event NewFeeEnabled(uint16 fee, uint24 pointDelta);\\n\\n    /// @notice emit when owner change delta fee on pools\\n    /// @param fee fee\\n    /// @param oldDelta delta was before\\n    /// @param newDelta new delta\\n    event FeeDeltaChanged(uint16 fee, uint16 oldDelta, uint16 newDelta);\\n\\n    /// @notice emit when owner change discount setters address\\n    /// @param newDiscountSetter new discount setter address\\n    event NewDiscountSetter(address newDiscountSetter);\\n\\n    /// @notice emit when owner change farms contract address\\n    /// @param newFarmsContract new farms contract address\\n    event NewFarmsContract(address newFarmsContract);\\n\\n    /// @notice emit when set new ratio on pool\\n    event NewFarmsRatio(address pool, uint ratio);\\n\\n    /// @notice emit when new discount was set\\n    /// @param discounts info for new discounts\\n    event SetDiscounts(DiscountStr[] discounts);\\n\\n    struct DiscountStr {\\n        address user;\\n        address pool;\\n        uint16 discount;\\n    }\\n\\n    struct Addresses {\\n        address swapX2YModule;\\n        address  swapY2XModule;\\n        address  liquidityModule;\\n        address  limitOrderModule;\\n        address  flashModule;\\n    }\\n\\n    /// @notice Add struct to save gas\\n    /// @return swapX2YModule address of module to support swapX2Y(DesireY)\\n    /// @return swapY2XModule address of module to support swapY2X(DesireX)\\n    /// @return liquidityModule address of module to support liquidity\\n    /// @return limitOrderModule address of module for user to manage limit orders\\n    /// @return flashModule address of module to support flash loan\\n    function addresses() external returns(\\n        address swapX2YModule,\\n        address swapY2XModule,\\n        address liquidityModule,\\n        address limitOrderModule,\\n        address flashModule\\n    );\\n\\n    /// @notice Set new Swap discounts for addresses\\n    /// @dev Only DiscountSetter calls\\n    /// @param discounts info for new discounts\\n    function setDiscount(DiscountStr[] calldata discounts) external;\\n\\n    /// @notice Set new farm ratio for pool\\n    /// @dev Only farm address calls\\n    /// @param _pool pool address\\n    /// @param ratio new ratio for pool\\n    function setFarmsRatio(address _pool, uint256 ratio) external;\\n\\n    /// @notice default fee rate from miner's fee gain\\n    /// @return defaultFeeChargePercent default fee rate * 100\\n    function defaultFeeChargePercent() external returns (uint24);\\n\\n    /// @notice Enables a fee amount with the given pointDelta\\n    /// @dev Fee amounts may never be removed once enabled\\n    /// @param fee fee amount (3000 means 0.3%)\\n    /// @param pointDelta The spacing between points to be enforced for all pools created with the given fee amount\\n    function enableFeeAmount(uint16 fee, uint24 pointDelta) external;\\n\\n    /// @notice Create a new pool which not exists.\\n    /// @param tokenX address of tokenX\\n    /// @param tokenY address of tokenY\\n    /// @param fee fee amount\\n    /// @param currentPoint initial point (log 1.0001 of price)\\n    /// @return address of newly created pool\\n    function newPool(\\n        address tokenX,\\n        address tokenY,\\n        uint16 fee,\\n        int24 currentPoint\\n    ) external returns (address);\\n\\n    /// @notice Charge receiver of all pools.\\n    /// @return address of charge receiver\\n    function chargeReceiver() external view returns(address);\\n\\n    /// @notice Get pool of (tokenX, tokenY, fee), address(0) for not exists.\\n    /// @param tokenX address of tokenX\\n    /// @param tokenY address of tokenY\\n    /// @param fee fee amount\\n    /// @return address of pool\\n    function pool(\\n        address tokenX,\\n        address tokenY,\\n        uint16 fee\\n    ) external view returns(address);\\n\\n    /// @notice farms ratio for pool\\n    /// @param _pool pool address\\n    /// @return farmRatio ratio for asked pool\\n    function farmsRatio(address _pool) external view returns(uint256 farmRatio);\\n\\n    /// @notice get farms reward contract address\\n    /// @return farms reward contract address\\n    function farmsContract() external view returns(address);\\n\\n    /// @notice Get point delta of a given fee amount.\\n    /// @param fee fee amount\\n    /// @return pointDelta the point delta\\n    function fee2pointDelta(uint16 fee) external view returns (int24 pointDelta);\\n\\n    /// @notice Get delta fee of a given fee amount.\\n    /// @param fee fee amount\\n    /// @return deltaFee fee delta [fee - %delta; fee + %delta] delta in percent base 10000\\n    function fee2DeltaFee(uint16 fee) external view returns (uint16 deltaFee);\\n\\n    /// @notice Change charge receiver, only owner of factory can call.\\n    /// @param _chargeReceiver address of new receiver\\n    function modifyChargeReceiver(address _chargeReceiver) external;\\n\\n    /// @notice Change defaultFeeChargePercent\\n    /// @param _defaultFeeChargePercent new charge percent\\n    function modifyDefaultFeeChargePercent(uint24 _defaultFeeChargePercent) external;\\n\\n    /// @notice return range of fee change\\n    /// @param fee fee for get range\\n    /// @return lowFee low range border\\n    /// @return highFee high range border\\n    function getFeeRange(uint16 fee) external view returns(uint16 lowFee, uint16 highFee);\\n\\n    /// @notice set fee delta to pools\\n    /// @param fee fee of pools on which the delta change\\n    /// @param delta new delta in base 10000\\n    function setFeeDelta(uint16 fee, uint16 delta) external;\\n\\n    /// @notice change discount setters address\\n    /// @param newDiscountSetter new discount setter address\\n    function setDiscountSetter(address newDiscountSetter) external;\\n\\n    /// @notice set new farms contract\\n    /// @param newFarmsContract address of new farms contract\\n    function setFarmsContract(address newFarmsContract) external;\\n\\n    /// @notice get discount from user address and pool\\n    /// @param user user address\\n    /// @param _pool pool address\\n    /// @return discount value of the discount base 10000\\n    function feeDiscount(address user, address _pool) external returns(uint16 discount);\\n\\n    function deployPoolParams() external view returns(\\n        address tokenX,\\n        address tokenY,\\n        uint16 fee,\\n        int24 currentPoint,\\n        int24 pointDelta,\\n        uint24 feeChargePercent\\n    );\\n\\n    /// @notice check fee in range\\n    /// @param fee fee of pools on which the delta change\\n    /// @param initFee initialize fee when pool created\\n    function checkFeeInRange(uint16 fee, uint16 initFee) external view returns(bool);\\n\\n    /// @notice return Init code hash\\n    function INIT_CODE_HASH() external pure returns(bytes32);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBiswapPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\n\\ninterface IBiswapPair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n    function swapFee() external view returns (uint32);\\n    function devFee() external view returns (uint32);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n    function setSwapFee(uint32) external;\\n    function setDevFee(uint32) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILiquidityManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\n\\n/// @title Interface for LiquidityManager\\ninterface ILiquidityManager is IERC721Enumerable {\\n\\n    /// @notice Emitted when miner successfully add liquidity on an existing liquidity-nft\\n    /// @param nftId id of minted liquidity nft\\n    /// @param pool address of swap pool\\n    /// @param liquidityDelta the amount of liquidity added\\n    /// @param amountX amount of tokenX deposit\\n    /// @param amountY amount of tokenY deposit\\n    event AddLiquidity(\\n        uint256 indexed nftId,\\n        address pool,\\n        uint128 liquidityDelta,\\n        uint256 amountX,\\n        uint256 amountY\\n    );\\n\\n    /// @notice Emitted when miner successfully add decrease liquidity on an existing liquidity-nft\\n    /// @param nftId id of minted liquidity nft\\n    /// @param pool address of swap pool\\n    /// @param liquidityDelta the amount of liquidity decreased\\n    /// @param amountX amount of tokenX withdrawn\\n    /// @param amountY amount of tokenY withdrawn\\n    event DecLiquidity(\\n        uint256 indexed nftId,\\n        address pool,\\n        uint128 liquidityDelta,\\n        uint256 amountX,\\n        uint256 amountY\\n    );\\n\\n    /// @notice Emitted when set new bonus pool manager contract\\n    /// @param _bonusPoolManager new bonus pool manager address\\n    event SetBonusPoolManager(address _bonusPoolManager);\\n\\n    /// @notice Emitted when get error on hook call\\n    /// @param receiver hook receiver address\\n    /// @param returnData retern revert data\\n    event HookError(address receiver,  bytes returnData);\\n\\n    /// @nitice parameters when calling mint, grouped together to avoid stake too deep\\n    /// @param miner miner address\\n    /// @param tokenX address of tokenX\\n    /// @param tokenY address of tokenY\\n    /// @param fee current fee of pool\\n    /// @param pl left point of added liquidity\\n    /// @param pr right point of added liquidity\\n    /// @param xLim amount limit of tokenX miner willing to deposit\\n    /// @param yLim amount limit tokenY miner willing to deposit\\n    /// @param amountXMin minimum amount of tokenX miner willing to deposit\\n    /// @param amountYMin minimum amount of tokenY miner willing to deposit\\n    /// @param deadline deadline of transaction\\n    struct MintParam {\\n        address miner;\\n        address tokenX;\\n        address tokenY;\\n        uint16 fee;\\n        int24 pl;\\n        int24 pr;\\n        uint128 xLim;\\n        uint128 yLim;\\n        uint128 amountXMin;\\n        uint128 amountYMin;\\n        uint256 deadline;\\n    }\\n\\n    /// @notice parameters when calling addLiquidity, grouped together\\n    /// @dev to avoid stake too deep\\n    /// @param lid id of nft\\n    /// @param xLim amount limit of tokenX user willing to deposit\\n    /// @param yLim amount limit of tokenY user willing to deposit\\n    /// @param amountXMin min amount of tokenX user willing to deposit\\n    /// @param amountYMin min amount of tokenY user willing to deposit\\n    /// @param deadline deadline for completing transaction\\n    struct AddLiquidityParam {\\n        uint256 lid;\\n        uint128 xLim;\\n        uint128 yLim;\\n        uint128 amountXMin;\\n        uint128 amountYMin;\\n        uint256 deadline;\\n    }\\n\\n    /// @notice pool data\\n    /// @param tokenX address of token X\\n    /// @param fee fee of pool\\n    /// @param tokenY address of token X\\n    /// @param pool pool address\\n    struct PoolMeta {\\n        address tokenX;\\n        uint16 fee;\\n        address tokenY;\\n        address pool;\\n    }\\n\\n    /// @notice information of liquidity provided by miner\\n    /// @param leftPt left point of liquidity-token, the range is [leftPt, rightPt)\\n    /// @param rightPt right point of liquidity-token, the range is [leftPt, rightPt)\\n    /// @param feeVote Vote for fee on liquidity position\\n    /// @param liquidity amount of liquidity on each point in [leftPt, rightPt)\\n    /// @param lastFeeScaleX_128 a 128-fixpoint number, as integral of { fee(pt, t)/L(pt, t) }\\n    /// @param lastFeeScaleY_128 a 128-fixpoint number, as integral of { fee(pt, t)/L(pt, t) }\\n    /// @dev here fee(pt, t) denotes fee generated on point pt at time t\\n    /// L(pt, t) denotes liquidity on point pt at time t\\n    /// pt varies in [leftPt, rightPt)\\n    /// t moves from pool created until miner last modify this liquidity-token (mint/addLiquidity/decreaseLiquidity/create)\\n    /// @param lastFPScale_128 a 128-fixpoint number last FPScale of 1 liquidity\\n    /// @param remainTokenX remained tokenX miner can collect, including fee and withdrawn token\\n    /// @param remainTokenY remained tokenY miner can collect, including fee and withdrawn token\\n    /// @param fpOwed Accrued fp for liquidity position\\n    /// @param poolId id of pool in which this liquidity is added\\n    struct Liquidity {\\n        int24 leftPt;\\n        int24 rightPt;\\n        uint16 feeVote;\\n        uint128 liquidity;\\n        uint256 lastFeeScaleX_128;\\n        uint256 lastFeeScaleY_128;\\n        uint256 lastFPScale_128;\\n        uint256 remainTokenX;\\n        uint256 remainTokenY;\\n        uint256 fpOwed;\\n        uint128 poolId;\\n    }\\n\\n    /// @notice callback data passed through BiswapPoolV3#mint to the callback\\n    /// @param tokenX tokenX of swap\\n    /// @param tokenY tokenY of swap\\n    /// @param fee fee amount of swap\\n    /// @param payer address to pay tokenX and tokenY to BiswapPoolV3\\n    struct MintCallbackData {\\n        address tokenX;\\n        address tokenY;\\n        uint16 fee;\\n        address payer;\\n    }\\n\\n\\n    /// @notice Add a new liquidity and generate a nft.\\n    /// @param mintParam params, see MintParam for more\\n    /// @return lid id of nft\\n    /// @return liquidity amount of liquidity added\\n    /// @return amountX amount of tokenX deposited\\n    /// @return amountY amount of tokenY depsoited\\n    function mint(MintParam calldata mintParam) external payable returns(\\n        uint256 lid,\\n        uint128 liquidity,\\n        uint256 amountX,\\n        uint256 amountY\\n    );\\n\\n    /// @notice Add a new liquidity and generate a nft.\\n    /// @param mintParam params, see MintParam for more\\n    /// @param feeVote vote for fee at liquidity position\\n    /// @return lid id of nft\\n    /// @return liquidity amount of liquidity added\\n    /// @return amountX amount of tokenX deposited\\n    /// @return amountY amount of tokenY deposited\\n    function mintWithFeeVote(MintParam calldata mintParam, uint16 feeVote) external payable returns(\\n        uint256 lid,\\n        uint128 liquidity,\\n        uint256 amountX,\\n        uint256 amountY\\n    );\\n\\n    /// @notice Burn a generated nft.\\n    /// @param lid nft (liquidity) id\\n    /// @return success successfully burn or not\\n    function burn(uint256 lid) external returns (bool success);\\n\\n    /// @notice Add liquidity to a existing nft.\\n    /// @param addLiquidityParam see AddLiquidityParam for more\\n    /// @return liquidityDelta amount of added liquidity\\n    /// @return amountX amount of tokenX deposited\\n    /// @return amountY amonut of tokenY deposited\\n    function addLiquidity(\\n        AddLiquidityParam calldata addLiquidityParam\\n    ) external payable returns (\\n        uint128 liquidityDelta,\\n        uint256 amountX,\\n        uint256 amountY\\n    );\\n\\n    /// @notice Decrease liquidity from a nft.\\n    /// @param lid id of nft\\n    /// @param liquidDelta amount of liqudity to decrease\\n    /// @param amountXMin min amount of tokenX user want to withdraw\\n    /// @param amountYMin min amount of tokenY user want to withdraw\\n    /// @param deadline deadline timestamp of transaction\\n    /// @return amountX amount of tokenX refund to user\\n    /// @return amountY amount of tokenY refund to user\\n    function decLiquidity(\\n        uint256 lid,\\n        uint128 liquidDelta,\\n        uint256 amountXMin,\\n        uint256 amountYMin,\\n        uint256 deadline\\n    ) external returns (\\n        uint256 amountX,\\n        uint256 amountY\\n    );\\n\\n    /// @notice Change vote for fee on exist NFT\\n    /// @param lid NFT Id\\n    /// @param newFeeVote new vote for fee on NFT position\\n    function changeFeeVote(uint256 lid, uint16 newFeeVote) external;\\n\\n    /// @notice get liquidity info from NFT Id\\n    /// @param lid NFT id\\n    /// @return leftPt left point of liquidity-token, the range is [leftPt, rightPt)\\n    /// @return rightPt right point of liquidity-token, the range is [leftPt, rightPt)\\n    /// @return feeVote Vote for fee on liquidity position\\n    /// @return liquidity amount of liquidity on each point in [leftPt, rightPt)\\n    /// @return lastFeeScaleX_128 a 128-fixpoint number, as integral of { fee(pt, t)/L(pt, t) }\\n    /// @return lastFeeScaleY_128 a 128-fixpoint number, as integral of { fee(pt, t)/L(pt, t) }\\n    /// @dev here fee(pt, t) denotes fee generated on point pt at time t\\n    /// L(pt, t) denotes liquidity on point pt at time t\\n    /// pt varies in [leftPt, rightPt)\\n    /// t moves from pool created until miner last modify this liquidity-token (mint/addLiquidity/decreaseLiquidity/create)\\n    /// @return lastFPScale_128 a 128-fixpoint number last FPScale of 1 liquidity\\n    /// @return remainTokenX remained tokenX miner can collect, including fee and withdrawn token\\n    /// @return remainTokenY remained tokenY miner can collect, including fee and withdrawn token\\n    /// @return fpOwed Accrued fp for liquidity position\\n    /// @return poolId id of pool in which this liquidity is added\\n    function liquidities(uint256 lid) external view returns(\\n        int24 leftPt,\\n        int24 rightPt,\\n        uint16 feeVote,\\n        uint128 liquidity,\\n        uint256 lastFeeScaleX_128,\\n        uint256 lastFeeScaleY_128,\\n        uint256 lastFPScale_128,\\n        uint256 remainTokenX,\\n        uint256 remainTokenY,\\n        uint256 fpOwed,\\n        uint128 poolId\\n    );\\n\\n    /// @notice info of pool from poolId\\n    /// @param poolId pool Id\\n    /// @return tokenX address of token X\\n    /// @return fee fee of pool\\n    /// @return tokenY address of token X\\n    /// @return pool pool address\\n    function poolMetas(uint128 poolId) external view returns(\\n        address tokenX,\\n        uint16 fee,\\n        address tokenY,\\n        address pool\\n    );\\n\\n    /// @notice Collect fee gained of token withdrawn from nft.\\n    /// @param recipient address to receive token\\n    /// @param lid id of nft\\n    /// @param amountXLim amount limit of tokenX to collect\\n    /// @param amountYLim amount limit of tokenY to collect\\n    /// @return amountX amount of tokenX actually collect\\n    /// @return amountY amount of tokenY actually collect\\n    function collect(\\n        address recipient,\\n        uint256 lid,\\n        uint128 amountXLim,\\n        uint128 amountYLim\\n    ) external payable returns (\\n        uint256 amountX,\\n        uint256 amountY\\n    );\\n\\n    /// @notice update farm point from pool\\n    /// @param lid NFT Id\\n    function updateFpOwed(uint256 lid) external;\\n\\n    /// @notice Set new bonus pool manager contract\\n    /// @dev only owner call\\n    /// @param _bonusPoolManager new bonus pool manager address\\n    function setBonusPoolManager(address _bonusPoolManager) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IV3Migrator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport '../interfaces/ILiquidityManager.sol';\\n\\n/// @title V3 Migrator\\n/// @notice Enables migration of liqudity from Uniswap v2-compatible pairs into Uniswap v3 pools\\ninterface IV3Migrator {\\n    struct MigrateParams {\\n        address pair; // the Uniswap v2-compatible pair\\n        uint256 liquidityToMigrate; // expected to be balanceOf(msg.sender)\\n        address token0;\\n        address token1;\\n        uint16 fee;\\n        int24 tickLower;\\n        int24 tickUpper;\\n        uint128 amount0Min; // must be discounted by percentageToMigrate\\n        uint128 amount1Min; // must be discounted by percentageToMigrate\\n        address recipient;\\n        uint256 deadline;\\n        bool refundAsETH;\\n    }\\n\\n    /// @notice Migrates liquidity to v3 by burning v2 liquidity and minting a new position for v3\\n    /// @dev Slippage protection is enforced via `amount{0,1}Min`, which should be a discount of the expected values of\\n    /// the maximum amount of v3 liquidity that the v2 liquidity can get. For the special case of migrating to an\\n    /// out-of-range position, `amount{0,1}Min` may be set to 0, enforcing that the position remains out of range\\n    /// @param params The params necessary to migrate v2 liquidity, encoded as `MigrateParams` in calldata\\n    function migrate(MigrateParams calldata params) external returns(uint refund0, uint refund1);\\n\\n    /// @notice Add a new liquidity and generate a nft at liquidity manager.\\n    /// @param mintParam params, see MintParam for more\\n    /// @return lid id of nft\\n    /// @return liquidity amount of liquidity added\\n    /// @return amountX amount of tokenX deposited\\n    /// @return amountY amount of tokenY depsoited\\n    function mint(ILiquidityManager.MintParam calldata mintParam) external payable returns(\\n        uint256 lid,\\n        uint128 liquidity,\\n        uint256 amountX,\\n        uint256 amountY\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/periphery/base/base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../../interfaces/IBiswapFactoryV3.sol\\\";\\n\\n/// @title Interface for WETH9\\ninterface IWETH9 is IERC20 {\\n    /// @notice Deposit ether to get wrapped ether\\n    function deposit() external payable;\\n\\n    /// @notice Withdraw wrapped ether to get ether\\n    function withdraw(uint256) external;\\n}\\n\\nabstract contract Base {\\n    /// @notice address of BiswapFactoryV3\\n    address public immutable factory;\\n\\n    /// @notice address of weth9 token\\n    address public immutable WETH9;\\n\\n    /// @notice factory provided init code hash\\n    bytes32  public immutable INIT_CODE_HASH;\\n\\n    modifier checkDeadline(uint256 deadline) {\\n        require(block.timestamp <= deadline, 'Out of time');\\n        _;\\n    }\\n\\n    receive() external payable {}\\n\\n    /// @notice Constructor of base.\\n    /// @param _factory address of BiswapFactoryV3\\n    /// @param _WETH9 address of weth9 token\\n    constructor(address _factory, address _WETH9) {\\n        factory = _factory;\\n        WETH9 = _WETH9;\\n        INIT_CODE_HASH = IBiswapFactoryV3(_factory).INIT_CODE_HASH();\\n    }\\n\\n    /// @notice Make multiple function calls in this contract in a single transaction\\n    ///     and return the data for each function call, revert if any function call fails\\n    /// @param data The encoded function data for each function call\\n    /// @return results result of each function call\\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\\n\\n            if (!success) {\\n                if (result.length < 68) revert();\\n                assembly {\\n                    result := add(result, 0x04)\\n                }\\n                revert(abi.decode(result, (string)));\\n            }\\n\\n            results[i] = result;\\n        }\\n    }\\n\\n    /// @notice Transfer tokens from the targeted address to the given destination\\n    /// @notice Errors with 'STF' if transfer fails\\n    /// @param token The contract address of the token to be transferred\\n    /// @param from The originating address from which the tokens will be transferred\\n    /// @param to The destination address of the transfer\\n    /// @param value The amount to be transferred\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) =\\n        token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'STF');\\n    }\\n\\n    /// @notice Transfer tokens from msg.sender to a recipient\\n    /// @dev Errors with ST if transfer fails\\n    /// @param token The contract address of the token which will be transferred\\n    /// @param to The recipient of the transfer\\n    /// @param value The value of the transfer\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'ST');\\n    }\\n\\n    /// @notice Approve the stipulated contract to spend the given allowance in the given token\\n    /// @dev Errors with 'SA' if transfer fails\\n    /// @param token The contract address of the token to be approved\\n    /// @param to The target of the approval\\n    /// @param value The amount of the given token the target will be allowed to spend\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'SA');\\n    }\\n\\n    /// @notice Transfer ETH to the recipient address\\n    /// @dev Fails with `STE`\\n    /// @param to The destination of the transfer\\n    /// @param value The value to be transferred\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'STE');\\n    }\\n\\n    /// @notice Withdraw all weth9 token of this contract and send the withdrawn eth to recipient\\n    ///    usually used in multicall when mint/swap/update limitorder with eth\\n    ///    normally this contract has no any erc20 token or eth after or before a transaction\\n    ///    we donot need to worry that some one can steal eth from this contract\\n    /// @param minAmount The minimum amount of WETH9 to withdraw\\n    /// @param recipient The address to receive all withdrawn eth from this contract\\n    function unwrapWETH9(uint256 minAmount, address recipient) external payable {\\n        uint256 all = IWETH9(WETH9).balanceOf(address(this));\\n        require(all >= minAmount, 'WETH9 Not Enough');\\n\\n        if (all > 0) {\\n            IWETH9(WETH9).withdraw(all);\\n            safeTransferETH(recipient, all);\\n        }\\n    }\\n\\n    /// @notice Send all balance of specified token in this contract to recipient\\n    ///    usually used in multicall when mint/swap/update limitorder with eth\\n    ///    normally this contract has no any erc20 token or eth after or before a transaction\\n    ///    we donot need to worry that some one can steal some token from this contract\\n    /// @param token address of the token\\n    /// @param minAmount balance should >= minAmount\\n    /// @param recipient the address to receive specified token from this contract\\n    function sweepToken(\\n        address token,\\n        uint256 minAmount,\\n        address recipient\\n    ) external payable {\\n        uint256 all = IERC20(token).balanceOf(address(this));\\n        require(all >= minAmount, 'WETH9 Not Enough');\\n\\n        if (all > 0) {\\n            safeTransfer(token, recipient, all);\\n        }\\n    }\\n\\n    /// @notice Send all balance of eth in this contract to msg.sender\\n    ///    usually used in multicall when mint/swap/update limitorder with eth\\n    ///    normally this contract has no any erc20 token or eth after or before a transaction\\n    ///    we donot need to worry that some one can steal some token from this contract\\n    function refundETH() external payable {\\n        if (address(this).balance > 0) safeTransferETH(msg.sender, address(this).balance);\\n    }\\n\\n    /// @param token The token to pay\\n    /// @param payer The entity that must pay\\n    /// @param recipient The entity that will receive payment\\n    /// @param value The amount to pay\\n    function pay(\\n        address token,\\n        address payer,\\n        address recipient,\\n        uint256 value\\n    ) internal {\\n        if (token == WETH9 && address(this).balance >= value) {\\n            // pay with WETH9\\n            IWETH9(WETH9).deposit{value: value}(); // wrap only what is needed to pay\\n            IWETH9(WETH9).transfer(recipient, value);\\n        } else if (payer == address(this)) {\\n            // pay with tokens already in the contract (for the exact input multihop case)\\n            safeTransfer(token, recipient, value);\\n        } else {\\n            // pull payment\\n            safeTransferFrom(token, payer, recipient, value);\\n        }\\n    }\\n\\n    /// @notice Query pool address from factory by (tokenX, tokenY, fee).\\n    /// @param tokenX tokenX of swap pool\\n    /// @param tokenY tokenY of swap pool\\n    /// @param fee fee amount of swap pool\\n    function pool(address tokenX, address tokenY, uint16 fee) public view returns(address) {\\n        (address token0, address token1) = tokenX < tokenY ? (tokenX, tokenY) : (tokenY, tokenX);\\n        return address(uint160(uint(keccak256(abi.encodePacked(\\n            hex'ff',\\n            factory,\\n            keccak256(abi.encode(token0, token1, fee)),\\n            INIT_CODE_HASH\\n        )))));\\n    }\\n\\n    /// @notice Get or create a pool for (tokenX/tokenY/fee) if not exists.\\n    /// @param tokenX tokenX of swap pool\\n    /// @param tokenY tokenY of swap pool\\n    /// @param fee fee amount of swap pool\\n    /// @param initialPoint initial point if need to create a new pool\\n    /// @return corresponding pool address\\n    function createPool(address tokenX, address tokenY, uint16 fee, int24 initialPoint) external payable returns (address) {\\n        return IBiswapFactoryV3(factory).newPool(tokenX, tokenY, fee, initialPoint);\\n    }\\n\\n    //\\n    function verify(address tokenX, address tokenY, uint16 fee) internal view {\\n        require (msg.sender == pool(tokenX, tokenY, fee), \\\"sp\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/periphery/V3Migrator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\nimport '../interfaces/IBiswapPair.sol';\\nimport '../interfaces/ILiquidityManager.sol';\\nimport '../interfaces/IV3Migrator.sol';\\n\\nimport './base/base.sol';\\n\\n/// @title Biswap V3 Migrator\\n/// @notice You can use this contract to migrate your V2 liquidity to V3 pool.\\ncontract V3Migrator is Base, IV3Migrator {\\n\\n    address public immutable liquidityManager;\\n\\n    int24 fullRangeLength = 800000;\\n\\n    event Migrate(\\n        MigrateParams params,\\n        uint amountRemoved0,\\n        uint amountRemoved1,\\n        uint amountAdded0,\\n        uint amountAdded1\\n    );\\n\\n    constructor(\\n        address _factory,\\n        address _WETH9,\\n        address _liquidityManager\\n    ) Base(_factory, _WETH9) {\\n        liquidityManager = _liquidityManager;\\n    }\\n\\n    /// @inheritdoc IV3Migrator\\n    function mint(ILiquidityManager.MintParam calldata mintParam) external payable returns(\\n        uint256 lid,\\n        uint128 liquidity,\\n        uint256 amountX,\\n        uint256 amountY\\n    ){\\n        return ILiquidityManager(liquidityManager).mint(mintParam);\\n    }\\n\\n    /// @notice This function burn V2 liquidity, and mint V3 liquidity with received tokens\\n    /// @param params see IV3Migrator.MigrateParams\\n    /// @return refund0 amount of token0 that burned from V2 but not used to mint V3 liquidity\\n    /// @return refund1 amount of token1 that burned from V2 but not used to mint V3 liquidity\\n    function migrate(MigrateParams calldata params) external override returns(uint refund0, uint refund1){\\n\\n        // burn v2 liquidity to this address\\n        IBiswapPair(params.pair).transferFrom(params.recipient, params.pair, params.liquidityToMigrate);\\n        (uint256 amount0V2, uint256 amount1V2) = IBiswapPair(params.pair).burn(address(this));\\n\\n        // calculate the amounts to migrate to v3\\n        uint128 amount0V2ToMigrate = uint128(amount0V2);\\n        uint128 amount1V2ToMigrate = uint128(amount1V2);\\n\\n        // approve the position manager up to the maximum token amounts\\n        safeApprove(params.token0, liquidityManager, amount0V2ToMigrate);\\n        safeApprove(params.token1, liquidityManager, amount1V2ToMigrate);\\n\\n        // mint v3 position\\n        (, , uint256 amount0V3, uint256 amount1V3) = ILiquidityManager(liquidityManager).mint(\\n            ILiquidityManager.MintParam({\\n                miner: params.recipient,\\n                tokenX: params.token0,\\n                tokenY: params.token1,\\n                fee: params.fee,\\n                pl: params.tickLower,\\n                pr: params.tickUpper,\\n                xLim: amount0V2ToMigrate,\\n                yLim: amount1V2ToMigrate,\\n                amountXMin: params.amount0Min,\\n                amountYMin: params.amount1Min,\\n                deadline: params.deadline\\n            })\\n        );\\n\\n        // if necessary, clear allowance and refund dust\\n        if (amount0V3 < amount0V2) {\\n            if (amount0V3 < amount0V2ToMigrate) {\\n                safeApprove(params.token0, liquidityManager, 0);\\n            }\\n\\n            refund0 = amount0V2 - amount0V3;\\n            if (params.refundAsETH && params.token0 == WETH9) {\\n                IWETH9(WETH9).withdraw(refund0);\\n                safeTransferETH(params.recipient, refund0);\\n            } else {\\n                safeTransfer(params.token0, params.recipient, refund0);\\n            }\\n        }\\n        if (amount1V3 < amount1V2) {\\n            if (amount1V3 < amount1V2ToMigrate) {\\n                safeApprove(params.token1, liquidityManager, 0);\\n            }\\n\\n            refund1 = amount1V2 - amount1V3;\\n            if (params.refundAsETH && params.token1 == WETH9) {\\n                IWETH9(WETH9).withdraw(refund1);\\n                safeTransferETH(params.recipient, refund1);\\n            } else {\\n                safeTransfer(params.token1, params.recipient, refund1);\\n            }\\n        }\\n\\n        emit Migrate(\\n            params,\\n            amount0V2,\\n            amount1V2,\\n            amount0V3,\\n            amount1V3\\n        );\\n    }\\n\\n    function stretchToPD(int24 point, int24 pd) private pure returns(int24 stretchedPoint){\\n        if (point < -pd) return ((point / pd) * pd) + pd;\\n        if (point > pd) return ((point / pd) * pd);\\n        return 0;\\n    }\\n\\n    /// @notice returns maximum possible range in points, used in 'full range' mint variant\\n    /// @param cp \\\"current point\\\"\\n    /// @param pd \\\"point delta\\\"\\n    /// @return pl calculated left point for full range\\n    /// @return pr calculated right point for full range\\n    function getFullRangeTicks(int24 cp, int24 pd) public view returns(int24 pl, int24 pr){\\n        cp = (cp / pd) * pd;\\n        int24 minPoint = -800000;\\n        int24 maxPoint = 800000;\\n\\n        if (cp >= fullRangeLength/2)  return (stretchToPD(maxPoint - fullRangeLength, pd), stretchToPD(maxPoint, pd));\\n        if (cp <= -fullRangeLength/2) return (stretchToPD(minPoint, pd),  stretchToPD(minPoint + fullRangeLength, pd));\\n        return (stretchToPD(cp - fullRangeLength/2, pd), stretchToPD(cp + fullRangeLength/2, pd));\\n    }\\n\\n    /// @notice returns all requiered info for creating full range position\\n    /// @param _tokenX target pool tokenX\\n    /// @param _tokenY target pool tokenY\\n    /// @param _fee target pool swap fee\\n    /// @return currentPoint pool current point\\n    /// @return leftTick calculated left point for full range\\n    /// @return rightTick calculated right point for full range\\n    function getPoolState(address _tokenX, address _tokenY, uint16 _fee) public view returns(\\n        int24 currentPoint,\\n        int24 leftTick,\\n        int24 rightTick\\n    ){\\n        address poolAddress = pool(_tokenX, _tokenY, _fee);\\n        (bool success, bytes memory d_state) = poolAddress.staticcall(abi.encodeWithSelector(0xc19d93fb)); //\\\"state()\\\"\\n        if (!success) revert('pool not created yet!');\\n        (, bytes memory d_pointDelta) = poolAddress.staticcall(abi.encodeWithSelector(0x58c51ce6)); //\\\"pointDelta()\\\"\\n\\n        (,currentPoint,,,,,,,,) = abi.decode(d_state, (uint160,int24,uint16,uint16,uint16,bool,uint240,uint16,uint128,uint128));\\n        (int24 pointDelta) = abi.decode(d_pointDelta, (int24));\\n        (leftTick, rightTick) = getFullRangeTicks(currentPoint, pointDelta);\\n\\n        return (currentPoint, leftTick, rightTick);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}",
    "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH9\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidityManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidityToMigrate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"fee\",\"type\":\"uint16\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"uint128\",\"name\":\"amount0Min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"amount1Min\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"refundAsETH\",\"type\":\"bool\"}],\"indexed\":false,\"internalType\":\"struct IV3Migrator.MigrateParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountRemoved0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountRemoved1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountAdded0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountAdded1\",\"type\":\"uint256\"}],\"name\":\"Migrate\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INIT_CODE_HASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH9\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"fee\",\"type\":\"uint16\"},{\"internalType\":\"int24\",\"name\":\"initialPoint\",\"type\":\"int24\"}],\"name\":\"createPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"cp\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"pd\",\"type\":\"int24\"}],\"name\":\"getFullRangeTicks\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"pl\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"pr\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenX\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_fee\",\"type\":\"uint16\"}],\"name\":\"getPoolState\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"currentPoint\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"leftTick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"rightTick\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidityToMigrate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"fee\",\"type\":\"uint16\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"uint128\",\"name\":\"amount0Min\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"amount1Min\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"refundAsETH\",\"type\":\"bool\"}],\"internalType\":\"struct IV3Migrator.MigrateParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"migrate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"refund0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refund1\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"miner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"fee\",\"type\":\"uint16\"},{\"internalType\":\"int24\",\"name\":\"pl\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"pr\",\"type\":\"int24\"},{\"internalType\":\"uint128\",\"name\":\"xLim\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"yLim\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"amountXMin\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"amountYMin\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct ILiquidityManager.MintParam\",\"name\":\"mintParam\",\"type\":\"tuple\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lid\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"amountX\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountY\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenX\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenY\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"fee\",\"type\":\"uint16\"}],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"sweepToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"unwrapWETH9\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
    "ContractName": "V3Migrator",
    "CompilerVersion": "v0.8.16+commit.07a7930e",
    "OptimizationUsed": "1",
    "Runs": "200",
    "ConstructorArguments": "0000000000000000000000007c3d53606f9c03e7f54abddffc3868e1c5466863000000000000000000000000bb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c00000000000000000000000024ba8d2a15fe60618039c398cf9fd093b1c1feb5",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "",
    "Proxy": "1",
    "Implementation": "0x839b0afd0a0528ea184448e890cbaaffd99c1dbf",
    "SwarmSource": ""
}