{
    "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Reward.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\ncontract Context {\\n    // Empty internal constructor, to prevent people from mistakenly deploying\\n    // an instance of this contract, which should be used via inheritance.\\n    constructor() {}\\n\\n    function _msgSender() internal view returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\\nlibrary SafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\\ncontract Reward is Context {\\n    using SafeMath for uint256;\\n    struct RewardData {\\n        address reward;\\n        uint256 amount;\\n        uint256 remain;\\n        uint256 price;\\n        uint256 timestemp;\\n    }\\n\\n    struct RewardHistory {\\n        uint256 amount;\\n        uint256 goldAmount;\\n        uint256 coinAmount;\\n        uint256 price;\\n        uint256 timesptemp;\\n    }\\n\\n    uint256 _totalMineCnt = 0;\\n    uint256 _totalRemainCnt = 0;\\n    uint256 _mineDaliyRatio;\\n    uint256 _fixMineCoinRatio = 30;\\n    uint256 _decimals;\\n    mapping(address => RewardData[]) reward;\\n    address[] rewardKeys;\\n    mapping(address => uint256) waitRelease;\\n    mapping(address => RewardHistory[]) history;\\n    mapping(address => uint256) historyTotal;\\n\\n    address _mainPair;\\n\\n    function init(\\n        uint256 mineDaliyRatio,\\n        uint256 decimals,\\n        address mainPair\\n    ) public {\\n        _mineDaliyRatio = mineDaliyRatio;\\n        _decimals = decimals;\\n        _mainPair = mainPair;\\n    }\\n\\n    function setReward(\\n        address rewardSender,\\n        uint256 amount,\\n        uint256 remain,\\n        uint256 price\\n    ) public {\\n        if (reward[rewardSender].length == 0) {\\n            rewardKeys.push(rewardSender);\\n        }\\n\\n        reward[rewardSender].push(\\n            RewardData(rewardSender, amount, remain, price, block.timestamp)\\n        );\\n        _totalRemainCnt += remain;\\n    }\\n\\n    event CoinReward(\\n        address adr,\\n        uint256 amount,\\n        uint256 price,\\n        uint256 sameCoin,\\n        uint256 finxMineCoin\\n    );\\n\\n    function generateReward(uint256 coinPrice) public {\\n        coinPrice = coinPrice == 0 ? 1 * 10**_decimals : coinPrice;\\n        for (uint256 i = 0; i < rewardKeys.length; i++) {\\n            for (uint256 j = 0; j < reward[rewardKeys[i]].length; j++) {\\n                if (reward[rewardKeys[i]][j].remain == 0) {\\n                    continue;\\n                }\\n\\n                uint256 pawnPrice = reward[rewardKeys[i]][j].price;\\n                uint256 targetRelease = reward[rewardKeys[i]][j].amount.mul(\\n                    _mineDaliyRatio\\n                ) / 100;\\n                uint256 fixMineCoin = targetRelease.mul(_fixMineCoinRatio).div(\\n                    100\\n                );\\n                uint256 sameCoinValue = (\\n                    ((targetRelease - fixMineCoin) * pawnPrice).div(coinPrice)\\n                );\\n\\n                uint256 release = sameCoinValue + fixMineCoin;\\n                if (reward[rewardKeys[i]][j].remain < release) {\\n                    release = reward[rewardKeys[i]][j].remain;\\n                }\\n\\n                if (waitRelease[rewardKeys[i]] != 0) {\\n                    waitRelease[rewardKeys[i]] += release;\\n                } else {\\n                    waitRelease[rewardKeys[i]] = release;\\n                }\\n\\n                if (historyTotal[rewardKeys[i]] != 0) {\\n                    historyTotal[rewardKeys[i]] += release;\\n                } else {\\n                    historyTotal[rewardKeys[i]] = release;\\n                }\\n                reward[rewardKeys[i]][j].remain =\\n                    reward[rewardKeys[i]][j].remain -\\n                    release;\\n                history[rewardKeys[i]].push(\\n                    RewardHistory(\\n                        release,\\n                        sameCoinValue,\\n                        fixMineCoin,\\n                        coinPrice,\\n                        block.timestamp\\n                    )\\n                );\\n                _totalMineCnt += release;\\n                emit CoinReward(\\n                    rewardKeys[i],\\n                    release,\\n                    coinPrice,\\n                    sameCoinValue,\\n                    fixMineCoin\\n                );\\n            }\\n        }\\n    }\\n\\n    function releaseCoin(address sender) public returns (uint256) {\\n        uint256 release = waitRelease[sender];\\n        waitRelease[sender] = 0;\\n        _totalRemainCnt -= release;\\n        return release;\\n    }\\n\\n    function getWaitReleaseCoin(address sender) public view returns (uint256) {\\n        return waitRelease[sender];\\n    }\\n\\n    function getRewardList(address sender)\\n        public\\n        view\\n        returns (RewardData[] memory)\\n    {\\n        return reward[sender];\\n    }\\n\\n    function getRewardAddressList() public view returns (address[] memory) {\\n        return rewardKeys;\\n    }\\n\\n    function getHistory(address sender)\\n        public\\n        view\\n        returns (RewardHistory[] memory)\\n    {\\n        return history[sender];\\n    }\\n\\n    function getHistoryMineTotal(address sender) public view returns (uint256) {\\n        return historyTotal[sender];\\n    }\\n\\n    function getTotalMineCnt() external view returns (uint256) {\\n        return _totalMineCnt;\\n    }\\n\\n    function getTotalRemainCnt() external view returns (uint256) {\\n        return _totalRemainCnt;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}",
    "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sameCoin\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"finxMineCoin\",\"type\":\"uint256\"}],\"name\":\"CoinReward\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coinPrice\",\"type\":\"uint256\"}],\"name\":\"generateReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getHistory\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"goldAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coinAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timesptemp\",\"type\":\"uint256\"}],\"internalType\":\"struct Reward.RewardHistory[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getHistoryMineTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardAddressList\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getRewardList\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestemp\",\"type\":\"uint256\"}],\"internalType\":\"struct Reward.RewardData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalMineCnt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalRemainCnt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"getWaitReleaseCoin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mineDaliyRatio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"mainPair\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"releaseCoin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardSender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remain\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
    "ContractName": "Reward",
    "CompilerVersion": "v0.8.18+commit.87f61d96",
    "OptimizationUsed": "0",
    "Runs": "200",
    "ConstructorArguments": "",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": ""
}