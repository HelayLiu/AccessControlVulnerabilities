{
    "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/BoringSolidity/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IERC20 {\\n    // transfer and tranferFrom have been removed, because they don't work on all tokens (some aren't ERC20 complaint).\\n    // By removing them you can't accidentally use them.\\n    // name, symbol and decimals have been removed, because they are optional and sometimes wrongly implemented (MKR).\\n    // Use BoringERC20 with `using BoringERC20 for IERC20` and call `safeTransfer`, `safeTransferFrom`, etc instead.\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice EIP 2612\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\\ninterface IStrictERC20 {\\n    // This is the strict ERC20 interface. Don't use this, certainly not if you don't control the ERC20 token you're calling.\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\n    function transfer(address _to, uint256 _value) external returns (bool success);\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\n    function approve(address _spender, uint256 _value) external returns (bool success);\\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /// @notice EIP 2612\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/BoringSolidity/contracts/libraries/BoringERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"../interfaces/IERC20.sol\\\";\\n\\n// solhint-disable avoid-low-level-calls\\n\\nlibrary BoringERC20 {\\n    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\\n    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\\n    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\\n    bytes4 private constant SIG_BALANCE_OF = 0x70a08231; // balanceOf(address)\\n    bytes4 private constant SIG_TOTALSUPPLY = 0x18160ddd; // balanceOf(address)\\n    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\\n    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\\n\\n    function returnDataToString(bytes memory data) internal pure returns (string memory) {\\n        if (data.length >= 64) {\\n            return abi.decode(data, (string));\\n        } else if (data.length == 32) {\\n            uint8 i = 0;\\n            while (i < 32 && data[i] != 0) {\\n                i++;\\n            }\\n            bytes memory bytesArray = new bytes(i);\\n            for (i = 0; i < 32 && data[i] != 0; i++) {\\n                bytesArray[i] = data[i];\\n            }\\n            return string(bytesArray);\\n        } else {\\n            return \\\"???\\\";\\n        }\\n    }\\n\\n    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\\n    /// @param token The address of the ERC-20 token contract.\\n    /// @return (string) Token symbol.\\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\\n        return success ? returnDataToString(data) : \\\"???\\\";\\n    }\\n\\n    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\\n    /// @param token The address of the ERC-20 token contract.\\n    /// @return (string) Token name.\\n    function safeName(IERC20 token) internal view returns (string memory) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\\n        return success ? returnDataToString(data) : \\\"???\\\";\\n    }\\n\\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\\n    /// @param token The address of the ERC-20 token contract.\\n    /// @return (uint8) Token decimals.\\n    function safeDecimals(IERC20 token) internal view returns (uint8) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\\n    }\\n\\n    /// @notice Provides a gas-optimized balance check to avoid a redundant extcodesize check in addition to the returndatasize check.\\n    /// @param token The address of the ERC-20 token.\\n    /// @param to The address of the user to check.\\n    /// @return amount The token amount.\\n    function safeBalanceOf(IERC20 token, address to) internal view returns (uint256 amount) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_BALANCE_OF, to));\\n        require(success && data.length >= 32, \\\"BoringERC20: BalanceOf failed\\\");\\n        amount = abi.decode(data, (uint256));\\n    }\\n\\n    /// @notice Provides a gas-optimized totalSupply to avoid a redundant extcodesize check in addition to the returndatasize check.\\n    /// @param token The address of the ERC-20 token.\\n    /// @return totalSupply The token totalSupply.\\n    function safeTotalSupply(IERC20 token) internal view returns (uint256 totalSupply) {\\n        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_TOTALSUPPLY));\\n        require(success && data.length >= 32, \\\"BoringERC20: totalSupply failed\\\");\\n        totalSupply = abi.decode(data, (uint256));\\n    }\\n\\n    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\\n    /// Reverts on a failed transfer.\\n    /// @param token The address of the ERC-20 token.\\n    /// @param to Transfer tokens to.\\n    /// @param amount The token amount.\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"BoringERC20: Transfer failed\\\");\\n    }\\n\\n    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\\n    /// Reverts on a failed transfer.\\n    /// @param token The address of the ERC-20 token.\\n    /// @param from Transfer tokens from.\\n    /// @param to Transfer tokens to.\\n    /// @param amount The token amount.\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"BoringERC20: TransferFrom failed\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/BoringSolidity/contracts/libraries/BoringRebase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nstruct Rebase {\\n    uint128 elastic;\\n    uint128 base;\\n}\\n\\n/// @notice A rebasing library using overflow-/underflow-safe math.\\nlibrary RebaseLibrary {\\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\\n    function toBase(\\n        Rebase memory total,\\n        uint256 elastic,\\n        bool roundUp\\n    ) internal pure returns (uint256 base) {\\n        if (total.elastic == 0) {\\n            base = elastic;\\n        } else {\\n            base = (elastic * total.base) / total.elastic;\\n            if (roundUp && (base * total.elastic) / total.base < elastic) {\\n                base++;\\n            }\\n        }\\n    }\\n\\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\\n    function toElastic(\\n        Rebase memory total,\\n        uint256 base,\\n        bool roundUp\\n    ) internal pure returns (uint256 elastic) {\\n        if (total.base == 0) {\\n            elastic = base;\\n        } else {\\n            elastic = (base * total.elastic) / total.base;\\n            if (roundUp && (elastic * total.base) / total.elastic < base) {\\n                elastic++;\\n            }\\n        }\\n    }\\n\\n    /// @notice Add `elastic` to `total` and doubles `total.base`.\\n    /// @return (Rebase) The new total.\\n    /// @return base in relationship to `elastic`.\\n    function add(\\n        Rebase memory total,\\n        uint256 elastic,\\n        bool roundUp\\n    ) internal pure returns (Rebase memory, uint256 base) {\\n        base = toBase(total, elastic, roundUp);\\n        total.elastic += uint128(elastic);\\n        total.base += uint128(base);\\n        return (total, base);\\n    }\\n\\n    /// @notice Sub `base` from `total` and update `total.elastic`.\\n    /// @return (Rebase) The new total.\\n    /// @return elastic in relationship to `base`.\\n    function sub(\\n        Rebase memory total,\\n        uint256 base,\\n        bool roundUp\\n    ) internal pure returns (Rebase memory, uint256 elastic) {\\n        elastic = toElastic(total, base, roundUp);\\n        total.elastic -= uint128(elastic);\\n        total.base -= uint128(base);\\n        return (total, elastic);\\n    }\\n\\n    /// @notice Add `elastic` and `base` to `total`.\\n    function add(\\n        Rebase memory total,\\n        uint256 elastic,\\n        uint256 base\\n    ) internal pure returns (Rebase memory) {\\n        total.elastic += uint128(elastic);\\n        total.base += uint128(base);\\n        return total;\\n    }\\n\\n    /// @notice Subtract `elastic` and `base` to `total`.\\n    function sub(\\n        Rebase memory total,\\n        uint256 elastic,\\n        uint256 base\\n    ) internal pure returns (Rebase memory) {\\n        total.elastic -= uint128(elastic);\\n        total.base -= uint128(base);\\n        return total;\\n    }\\n\\n    /// @notice Add `elastic` to `total` and update storage.\\n    /// @return newElastic Returns updated `elastic`.\\n    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\\n        newElastic = total.elastic += uint128(elastic);\\n    }\\n\\n    /// @notice Subtract `elastic` from `total` and update storage.\\n    /// @return newElastic Returns updated `elastic`.\\n    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\\n        newElastic = total.elastic -= uint128(elastic);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IBentoBoxV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport \\\"BoringSolidity/interfaces/IERC20.sol\\\";\\nimport \\\"BoringSolidity/libraries/BoringRebase.sol\\\";\\nimport \\\"interfaces/IStrategy.sol\\\";\\n\\ninterface IFlashBorrower {\\n    /// @notice The flashloan callback. `amount` + `fee` needs to repayed to msg.sender before this call returns.\\n    /// @param sender The address of the invoker of this flashloan.\\n    /// @param token The address of the token that is loaned.\\n    /// @param amount of the `token` that is loaned.\\n    /// @param fee The fee that needs to be paid on top for this loan. Needs to be the same as `token`.\\n    /// @param data Additional data that was passed to the flashloan function.\\n    function onFlashLoan(\\n        address sender,\\n        IERC20 token,\\n        uint256 amount,\\n        uint256 fee,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ninterface IBatchFlashBorrower {\\n    /// @notice The callback for batched flashloans. Every amount + fee needs to repayed to msg.sender before this call returns.\\n    /// @param sender The address of the invoker of this flashloan.\\n    /// @param tokens Array of addresses for ERC-20 tokens that is loaned.\\n    /// @param amounts A one-to-one map to `tokens` that is loaned.\\n    /// @param fees A one-to-one map to `tokens` that needs to be paid on top for each loan. Needs to be the same token.\\n    /// @param data Additional data that was passed to the flashloan function.\\n    function onBatchFlashLoan(\\n        address sender,\\n        IERC20[] calldata tokens,\\n        uint256[] calldata amounts,\\n        uint256[] calldata fees,\\n        bytes calldata data\\n    ) external;\\n}\\n\\ninterface IBentoBoxV1 {\\n    function balanceOf(IERC20, address) external view returns (uint256);\\n\\n    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results);\\n\\n    function batchFlashLoan(\\n        IBatchFlashBorrower borrower,\\n        address[] calldata receivers,\\n        IERC20[] calldata tokens,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n\\n    function claimOwnership() external;\\n\\n    function flashLoan(\\n        IFlashBorrower borrower,\\n        address receiver,\\n        IERC20 token,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    function deploy(\\n        address masterContract,\\n        bytes calldata data,\\n        bool useCreate2\\n    ) external payable returns (address);\\n\\n    function deposit(\\n        IERC20 token_,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 share\\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\\n\\n    function harvest(\\n        IERC20 token,\\n        bool balance,\\n        uint256 maxChangeAmount\\n    ) external;\\n\\n    function masterContractApproved(address, address) external view returns (bool);\\n\\n    function masterContractOf(address) external view returns (address);\\n\\n    function nonces(address) external view returns (uint256);\\n\\n    function owner() external view returns (address);\\n\\n    function pendingOwner() external view returns (address);\\n\\n    function pendingStrategy(IERC20) external view returns (IStrategy);\\n\\n    function permitToken(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function registerProtocol() external;\\n\\n    function setMasterContractApproval(\\n        address user,\\n        address masterContract,\\n        bool approved,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function setStrategy(IERC20 token, IStrategy newStrategy) external;\\n\\n    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) external;\\n\\n    function strategy(IERC20) external view returns (IStrategy);\\n\\n    function strategyData(IERC20)\\n        external\\n        view\\n        returns (\\n            uint64 strategyStartDate,\\n            uint64 targetPercentage,\\n            uint128 balance\\n        );\\n\\n    function toAmount(\\n        IERC20 token,\\n        uint256 share,\\n        bool roundUp\\n    ) external view returns (uint256 amount);\\n\\n    function toShare(\\n        IERC20 token,\\n        uint256 amount,\\n        bool roundUp\\n    ) external view returns (uint256 share);\\n\\n    function totals(IERC20) external view returns (Rebase memory totals_);\\n\\n    function transfer(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 share\\n    ) external;\\n\\n    function transferMultiple(\\n        IERC20 token,\\n        address from,\\n        address[] calldata tos,\\n        uint256[] calldata shares\\n    ) external;\\n\\n    function transferOwnership(\\n        address newOwner,\\n        bool direct,\\n        bool renounce\\n    ) external;\\n\\n    function whitelistMasterContract(address masterContract, bool approved) external;\\n\\n    function whitelistedMasterContracts(address) external view returns (bool);\\n\\n    function withdraw(\\n        IERC20 token_,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        uint256 share\\n    ) external returns (uint256 amountOut, uint256 shareOut);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStargatePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface IStargatePool {\\n    function deltaCredit() external view returns (uint256);\\n\\n    function totalLiquidity() external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function decimals() external view returns (uint256);\\n\\n    function poolId() external view returns (uint256);\\n\\n    function localDecimals() external view returns (uint256);\\n\\n    function token() external view returns (address);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStargateRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// solhint-disable contract-name-camelcase\\npragma solidity >=0.8.0;\\n\\ninterface IStargateRouter {\\n    struct lzTxObj {\\n        uint256 dstGasForCall;\\n        uint256 dstNativeAmount;\\n        bytes dstNativeAddr;\\n    }\\n\\n    function addLiquidity(\\n        uint256 _poolId,\\n        uint256 _amountLD,\\n        address _to\\n    ) external;\\n\\n    function swap(\\n        uint16 _dstChainId,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        address payable _refundAddress,\\n        uint256 _amountLD,\\n        uint256 _minAmountLD,\\n        lzTxObj memory _lzTxParams,\\n        bytes calldata _to,\\n        bytes calldata _payload\\n    ) external payable;\\n\\n    function redeemRemote(\\n        uint16 _dstChainId,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        address payable _refundAddress,\\n        uint256 _amountLP,\\n        uint256 _minAmountLD,\\n        bytes calldata _to,\\n        lzTxObj memory _lzTxParams\\n    ) external payable;\\n\\n    function instantRedeemLocal(\\n        uint16 _srcPoolId,\\n        uint256 _amountLP,\\n        address _to\\n    ) external returns (uint256);\\n\\n    function redeemLocal(\\n        uint16 _dstChainId,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        address payable _refundAddress,\\n        uint256 _amountLP,\\n        bytes calldata _to,\\n        lzTxObj memory _lzTxParams\\n    ) external payable;\\n\\n    function sendCredits(\\n        uint16 _dstChainId,\\n        uint256 _srcPoolId,\\n        uint256 _dstPoolId,\\n        address payable _refundAddress\\n    ) external payable;\\n\\n    function quoteLayerZeroFee(\\n        uint16 _dstChainId,\\n        uint8 _functionType,\\n        bytes calldata _toAddress,\\n        bytes calldata _transferAndCallPayload,\\n        lzTxObj memory _lzTxParams\\n    ) external view returns (uint256, uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.8.0;\\n\\ninterface IStrategy {\\n    /// @notice Send the assets to the Strategy and call skim to invest them.\\n    /// @param amount The amount of tokens to invest.\\n    function skim(uint256 amount) external;\\n\\n    /// @notice Harvest any profits made converted to the asset and pass them to the caller.\\n    /// @param balance The amount of tokens the caller thinks it has invested.\\n    /// @param sender The address of the initiator of this transaction. Can be used for reimbursements, etc.\\n    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.\\n    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\\n\\n    /// @notice Withdraw assets. The returned amount can differ from the requested amount due to rounding.\\n    /// @dev The `actualAmount` should be very close to the amount.\\n    /// The difference should NOT be used to report a loss. That's what harvest is for.\\n    /// @param amount The requested amount the caller wants to withdraw.\\n    /// @return actualAmount The real amount that is withdrawn.\\n    function withdraw(uint256 amount) external returns (uint256 actualAmount);\\n\\n    /// @notice Withdraw all assets in the safest way possible. This shouldn't fail.\\n    /// @param balance The amount of tokens the caller thinks it has invested.\\n    /// @return amountAdded The delta (+profit or -loss) that occured in contrast to `balance`.\\n    function exit(uint256 balance) external returns (int256 amountAdded);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ISwapperV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\ninterface ISwapperV2 {\\n    /// @notice Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.\\n    /// Swaps it for at least 'amountToMin' of token 'to'.\\n    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain IERC20 transfer.\\n    /// Returns the amount of tokens 'to' transferred to BentoBox.\\n    /// (The BentoBox skim function will be used by the caller to get the swapped funds).\\n    function swap(\\n        address fromToken,\\n        address toToken,\\n        address recipient,\\n        uint256 shareToMin,\\n        uint256 shareFrom,\\n        bytes calldata data\\n    ) external returns (uint256 extraShare, uint256 shareReturned);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.8.0;\\n\\ninterface IUniswapV2Pair {\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n\\n    function skim(address to) external;\\n\\n    function sync() external;\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n\\n    function token0() external pure returns (address);\\n\\n    function token1() external pure returns (address);\\n}\\n\"\r\n    },\r\n    \"src/libraries/SafeApprove.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport \\\"BoringSolidity/interfaces/IERC20.sol\\\";\\n\\nlibrary SafeApprove {\\n    error ErrApproveFailed();\\n    error ErrApproveFailedWithData(bytes data);\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(abi.encodeCall(IERC20.approve, (to, value)));\\n        if (!success) {\\n            revert ErrApproveFailed();\\n        }\\n        if (data.length != 0 && !abi.decode(data, (bool))) {\\n            revert ErrApproveFailedWithData(data);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"src/swappers/ZeroXStargateLPSwapper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// solhint-disable avoid-low-level-calls\\npragma solidity >=0.8.0;\\n\\nimport \\\"BoringSolidity/interfaces/IERC20.sol\\\";\\nimport \\\"BoringSolidity/libraries/BoringERC20.sol\\\";\\nimport \\\"interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"interfaces/IBentoBoxV1.sol\\\";\\nimport \\\"interfaces/ISwapperV2.sol\\\";\\nimport \\\"interfaces/IStargatePool.sol\\\";\\nimport \\\"interfaces/IStargateRouter.sol\\\";\\nimport \\\"libraries/SafeApprove.sol\\\";\\n\\n/// @notice LP liquidation/deleverage swapper for Stargate LPs using Matcha/0x aggregator\\ncontract ZeroXStargateLPSwapper is ISwapperV2 {\\n    using BoringERC20 for IERC20;\\n    using SafeApprove for IERC20;\\n\\n    error ErrSwapFailed();\\n\\n    IBentoBoxV1 public immutable bentoBox;\\n    IStargatePool public immutable pool;\\n    IERC20 public immutable mim;\\n    IERC20 public immutable underlyingToken;\\n    IStargateRouter public immutable stargateRouter;\\n    address public immutable zeroXExchangeProxy;\\n    uint16 public immutable poolId;\\n\\n    constructor(\\n        IBentoBoxV1 _bentoBox,\\n        IStargatePool _pool,\\n        uint16 _poolId,\\n        IStargateRouter _stargateRouter,\\n        IERC20 _mim,\\n        address _zeroXExchangeProxy\\n    ) {\\n        bentoBox = _bentoBox;\\n        pool = _pool;\\n        poolId = _poolId;\\n        mim = _mim;\\n        stargateRouter = _stargateRouter;\\n        zeroXExchangeProxy = _zeroXExchangeProxy;\\n        underlyingToken = IERC20(_pool.token());\\n\\n        underlyingToken.safeApprove(_zeroXExchangeProxy, type(uint256).max);\\n        mim.approve(address(_bentoBox), type(uint256).max);\\n    }\\n\\n    /// @inheritdoc ISwapperV2\\n    function swap(\\n        address,\\n        address,\\n        address recipient,\\n        uint256 shareToMin,\\n        uint256 shareFrom,\\n        bytes calldata swapData\\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\\n        bentoBox.withdraw(IERC20(address(pool)), address(this), address(this), 0, shareFrom);\\n\\n        // use the full balance so it's easier to check if everything has been redeemed.\\n        uint256 amount = IERC20(address(pool)).balanceOf(address(this));\\n\\n        // Stargate Pool LP -> Underlying Token\\n        stargateRouter.instantRedeemLocal(poolId, amount, address(this));\\n        require(IERC20(address(pool)).balanceOf(address(this)) == 0, \\\"Cannot fully redeem\\\");\\n\\n        // underlying -> MIM\\n        (bool success, ) = zeroXExchangeProxy.call(swapData);\\n        if (!success) {\\n            revert ErrSwapFailed();\\n        }\\n\\n        (, shareReturned) = bentoBox.deposit(mim, address(this), recipient, mim.balanceOf(address(this)), 0);\\n        extraShare = shareReturned - shareToMin;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"/=src/\",\r\n      \"BoringSolidity/=lib/BoringSolidity/contracts/\",\r\n      \"OpenZeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"cauldrons/=src/cauldrons/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"interfaces/=src/interfaces/\",\r\n      \"libraries/=src/libraries/\",\r\n      \"mocks/=src/mocks/\",\r\n      \"oracles/=src/oracles/\",\r\n      \"periphery/=src/periphery/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"strategies/=src/strategies/\",\r\n      \"swappers/=src/swappers/\",\r\n      \"tokens/=src/tokens/\",\r\n      \"utils/=utils/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}",
    "ABI": "[{\"inputs\":[{\"internalType\":\"contract IBentoBoxV1\",\"name\":\"_bentoBox\",\"type\":\"address\"},{\"internalType\":\"contract IStargatePool\",\"name\":\"_pool\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_poolId\",\"type\":\"uint16\"},{\"internalType\":\"contract IStargateRouter\",\"name\":\"_stargateRouter\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_mim\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_zeroXExchangeProxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ErrApproveFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ErrApproveFailedWithData\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ErrSwapFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"bentoBox\",\"outputs\":[{\"internalType\":\"contract IBentoBoxV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mim\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"contract IStargatePool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stargateRouter\",\"outputs\":[{\"internalType\":\"contract IStargateRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"shareToMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shareFrom\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"swapData\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"extraShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shareReturned\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zeroXExchangeProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
    "ContractName": "ZeroXStargateLPSwapper",
    "CompilerVersion": "v0.8.16+commit.07a7930e",
    "OptimizationUsed": "1",
    "Runs": "200",
    "ConstructorArguments": "000000000000000000000000d96f48665a1410c0cd669a88898eca36b9fc2cce00000000000000000000000038ea452219524bb87e18de1c24d3bb59510bd78300000000000000000000000000000000000000000000000000000000000000020000000000000000000000008731d54e9d02c286767d56ac03e8037c07e01e9800000000000000000000000099d8a9c45b2eca8864373a26d1459e3dff1e17f3000000000000000000000000def1c0ded9bec7f1a1670819833240f027b25eff",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": ""
}