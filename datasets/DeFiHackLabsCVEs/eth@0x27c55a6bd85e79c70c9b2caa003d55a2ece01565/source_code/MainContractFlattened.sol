// SPDX-License-Identifier: MIT
// This file was auto-generated by a flattening script.

pragma solidity 0.8.15;




library console {
	address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);

	function _sendLogPayload(bytes memory payload) private view {
		uint256 payloadLength = payload.length;
		address consoleAddress = CONSOLE_ADDRESS;
		assembly {
			let payloadStart := add(payload, 32)
			let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
		}
	}

	function log() internal view {
		_sendLogPayload(abi.encodeWithSignature("log()"));
	}

	function logInt(int256 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
	}

	function logUint(uint256 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
	}

	function logString(string memory p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string)", p0));
	}

	function logBool(bool p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
	}

	function logAddress(address p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address)", p0));
	}

	function logBytes(bytes memory p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
	}

	function logBytes1(bytes1 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
	}

	function logBytes2(bytes2 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
	}

	function logBytes3(bytes3 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
	}

	function logBytes4(bytes4 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
	}

	function logBytes5(bytes5 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
	}

	function logBytes6(bytes6 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
	}

	function logBytes7(bytes7 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
	}

	function logBytes8(bytes8 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
	}

	function logBytes9(bytes9 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
	}

	function logBytes10(bytes10 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
	}

	function logBytes11(bytes11 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
	}

	function logBytes12(bytes12 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
	}

	function logBytes13(bytes13 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
	}

	function logBytes14(bytes14 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
	}

	function logBytes15(bytes15 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
	}

	function logBytes16(bytes16 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
	}

	function logBytes17(bytes17 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
	}

	function logBytes18(bytes18 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
	}

	function logBytes19(bytes19 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
	}

	function logBytes20(bytes20 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
	}

	function logBytes21(bytes21 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
	}

	function logBytes22(bytes22 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
	}

	function logBytes23(bytes23 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
	}

	function logBytes24(bytes24 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
	}

	function logBytes25(bytes25 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
	}

	function logBytes26(bytes26 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
	}

	function logBytes27(bytes27 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
	}

	function logBytes28(bytes28 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
	}

	function logBytes29(bytes29 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
	}

	function logBytes30(bytes30 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
	}

	function logBytes31(bytes31 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
	}

	function logBytes32(bytes32 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
	}

	function log(uint256 p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
	}

	function log(string memory p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string)", p0));
	}

	function log(bool p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
	}

	function log(address p0) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address)", p0));
	}

	function log(uint256 p0, uint256 p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256)", p0, p1));
	}

	function log(uint256 p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string)", p0, p1));
	}

	function log(uint256 p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool)", p0, p1));
	}

	function log(uint256 p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address)", p0, p1));
	}

	function log(string memory p0, uint256 p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256)", p0, p1));
	}

	function log(string memory p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
	}

	function log(string memory p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
	}

	function log(string memory p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
	}

	function log(bool p0, uint256 p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256)", p0, p1));
	}

	function log(bool p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
	}

	function log(bool p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
	}

	function log(bool p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
	}

	function log(address p0, uint256 p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256)", p0, p1));
	}

	function log(address p0, string memory p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
	}

	function log(address p0, bool p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
	}

	function log(address p0, address p1) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
	}

	function log(uint256 p0, uint256 p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256)", p0, p1, p2));
	}

	function log(uint256 p0, uint256 p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string)", p0, p1, p2));
	}

	function log(uint256 p0, uint256 p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool)", p0, p1, p2));
	}

	function log(uint256 p0, uint256 p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address)", p0, p1, p2));
	}

	function log(uint256 p0, string memory p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256)", p0, p1, p2));
	}

	function log(uint256 p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string)", p0, p1, p2));
	}

	function log(uint256 p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool)", p0, p1, p2));
	}

	function log(uint256 p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address)", p0, p1, p2));
	}

	function log(uint256 p0, bool p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256)", p0, p1, p2));
	}

	function log(uint256 p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string)", p0, p1, p2));
	}

	function log(uint256 p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool)", p0, p1, p2));
	}

	function log(uint256 p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address)", p0, p1, p2));
	}

	function log(uint256 p0, address p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256)", p0, p1, p2));
	}

	function log(uint256 p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string)", p0, p1, p2));
	}

	function log(uint256 p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool)", p0, p1, p2));
	}

	function log(uint256 p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address)", p0, p1, p2));
	}

	function log(string memory p0, uint256 p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256)", p0, p1, p2));
	}

	function log(string memory p0, uint256 p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string)", p0, p1, p2));
	}

	function log(string memory p0, uint256 p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool)", p0, p1, p2));
	}

	function log(string memory p0, uint256 p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
	}

	function log(string memory p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
	}

	function log(string memory p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
	}

	function log(string memory p0, address p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256)", p0, p1, p2));
	}

	function log(string memory p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
	}

	function log(string memory p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
	}

	function log(string memory p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
	}

	function log(bool p0, uint256 p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256)", p0, p1, p2));
	}

	function log(bool p0, uint256 p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string)", p0, p1, p2));
	}

	function log(bool p0, uint256 p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool)", p0, p1, p2));
	}

	function log(bool p0, uint256 p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
	}

	function log(bool p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
	}

	function log(bool p0, bool p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256)", p0, p1, p2));
	}

	function log(bool p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
	}

	function log(bool p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
	}

	function log(bool p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
	}

	function log(bool p0, address p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256)", p0, p1, p2));
	}

	function log(bool p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
	}

	function log(bool p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
	}

	function log(bool p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
	}

	function log(address p0, uint256 p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256)", p0, p1, p2));
	}

	function log(address p0, uint256 p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string)", p0, p1, p2));
	}

	function log(address p0, uint256 p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool)", p0, p1, p2));
	}

	function log(address p0, uint256 p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address)", p0, p1, p2));
	}

	function log(address p0, string memory p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256)", p0, p1, p2));
	}

	function log(address p0, string memory p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
	}

	function log(address p0, string memory p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
	}

	function log(address p0, string memory p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
	}

	function log(address p0, bool p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256)", p0, p1, p2));
	}

	function log(address p0, bool p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
	}

	function log(address p0, bool p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
	}

	function log(address p0, bool p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
	}

	function log(address p0, address p1, uint256 p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256)", p0, p1, p2));
	}

	function log(address p0, address p1, string memory p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
	}

	function log(address p0, address p1, bool p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
	}

	function log(address p0, address p1, address p2) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
	}

	function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, uint256 p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,address)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,uint256)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,string)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,bool)", p0, p1, p2, p3));
	}

	function log(uint256 p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, uint256 p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint256)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
	}

	function log(string memory p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, uint256 p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint256)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
	}

	function log(bool p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, uint256 p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, string memory p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, bool p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint256 p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint256 p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint256 p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, uint256 p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, string memory p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, bool p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, uint256 p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint256)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, string memory p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, bool p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
	}

	function log(address p0, address p1, address p2, address p3) internal view {
		_sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
	}

}

abstract contract TensorpricerInterface {
    /// @notice Indicator that this is a Tensorpricer contract (for inspection)
    bool public constant isTensorpricer = true;

//    uint public fxMult = 100;   // tmp variable

    /*** Supported functions ***/
    function mintAllowed(address levToken, address minter) virtual external returns (uint);

    function redeemAllowed(address levToken, address redeemer, uint redeemTokens) virtual external returns (uint);

    function transferAllowed(address levToken, address src, address dst, uint transferTokens) virtual external returns (uint);

    function getFx(string memory fxname) virtual external view returns (uint);

    function _setMintPausedLev(address levToken, bool state) virtual public returns (bool);

    function _setRedeemPausedLev(address levToken, bool state) virtual public returns (bool);

//    function setFxMult(uint mult) virtual external; // tmp function to be removed after testing
}

/**
  * @title Vortex's InterestRateModel Interface
  * @author Vortex
  */
abstract contract InterestRateModel {
    /// @notice contract property
    bool public constant isInterestRateModel = true;

    /**
      * @notice Calculates the current borrow interest rate per block
      * @param iur ideal utilisation rate
      * @param cRatePerBlock compound rate
      * @return The borrow rate per block (as a percentage, and scaled by 1e18)
      */
    function getBorrowRate(uint iur, uint cRatePerBlock) virtual external view returns (uint);

    /**
      * @notice Calculates the current supply interest rate per block
      * @param iur ideal utilisation rate
      * @param cRatePerBlock compound rate
      * @return The supply rate per block (as a percentage, and scaled by 1e18)
      */
    function getSupplyRate(uint iur, uint cRatePerBlock) virtual external view returns (uint);
}

abstract contract MatrixpricerInterface {
    /// @notice Indicator that this is a Matrixpricer contract (for inspection)
    bool public constant isMatrixpricer = true;

    /*** Supported functions ***/
    function mintAllowed(address depToken, address minter) virtual external returns (uint);

    function redeemAllowed(address depToken, address redeemer, uint redeemTokens) virtual external returns (uint);

    function borrowAllowed(address depToken, address borrower) virtual external returns (uint);

    function repayBorrowAllowed(
        address depToken,
        address borrower) virtual external returns (uint);

    function transferAllowed(address depToken, address src, address dst, uint transferTokens) virtual external returns (uint);
}

/**
 * @title EIP20NonStandardInterface
 * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`
 *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
 */
interface EIP20NonStandardInterface {

    /**
     * @notice Get the total number of tokens in circulation
     * @return The supply of tokens
     */
    function totalSupply() external view returns (uint256);

    /**
     * @notice Gets the balance of the specified address
     * @param owner The address from which the balance will be retrieved
     * @return balance The balance
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    ///
    /// !!!!!!!!!!!!!!
    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification
    /// !!!!!!!!!!!!!!
    ///

    /**
      * @notice Transfer `amount` tokens from `msg.sender` to `dst`
      * @param dst The address of the destination account
      * @param amount The number of tokens to transfer
      */
    function transfer(address dst, uint256 amount) external;

    ///
    /// !!!!!!!!!!!!!!
    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification
    /// !!!!!!!!!!!!!!
    ///

    /**
      * @notice Transfer `amount` tokens from `src` to `dst`
      * @param src The address of the source account
      * @param dst The address of the destination account
      * @param amount The number of tokens to transfer
      */
    function transferFrom(address src, address dst, uint256 amount) external;

    /**
      * @notice Approve `spender` to transfer up to `amount` from `src`
      * @dev This will overwrite the approval amount for `spender`
      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
      * @param spender The address of the account which may transfer tokens
      * @param amount The number of tokens that are approved
      * @return success Whether or not the approval succeeded
      */
    function approve(address spender, uint256 amount) external returns (bool success);

    /**
      * @notice Get the current allowance from `owner` for `spender`
      * @param owner The address of the account which owns the tokens to be spent
      * @param spender The address of the account which may transfer tokens
      * @return remaining The number of tokens allowed to be spent
      */
    function allowance(address owner, address spender) external view returns (uint256 remaining);

    event Transfer(address indexed from, address indexed to, uint256 amount);
    event Approval(address indexed owner, address indexed spender, uint256 amount);
}

contract managerErrorReporter {
    enum Error {
        NO_ERROR,
        UNAUTHORIZED,
        MATRIXPRICER_MISMATCH,
        INSUFFICIENT_SHORTFALL,
        INSUFFICIENT_LIQUIDITY,
        INVALID_CLOSE_FACTOR,
        INVALID_COLLATERAL_FACTOR,
        INVALID_LIQUIDATION_INCENTIVE,
        MARKET_NOT_ENTERED, // no longer possible
        MARKET_NOT_LISTED,
        MARKET_ALREADY_LISTED,
        MATH_ERROR,
        NONZERO_BORROW_BALANCE,
        PRICE_ERROR,
        REJECTION,
        SNAPSHOT_ERROR,
        TOO_MANY_ASSETS,
        TOO_MUCH_REPAY
    }

    enum FailureInfo {
        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,
        ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,
        EXIT_MARKET_BALANCE_OWED,
        EXIT_MARKET_REJECTION,
        SET_CLOSE_FACTOR_OWNER_CHECK,
        SET_CLOSE_FACTOR_VALIDATION,
        SET_COLLATERAL_FACTOR_OWNER_CHECK,
        SET_COLLATERAL_FACTOR_NO_EXISTS,
        SET_COLLATERAL_FACTOR_VALIDATION,
        SET_COLLATERAL_FACTOR_WITHOUT_PRICE,
        SET_IMPLEMENTATION_OWNER_CHECK,
        SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,
        SET_LIQUIDATION_INCENTIVE_VALIDATION,
        SET_MAX_ASSETS_OWNER_CHECK,
        SET_PAUSE_GUARDIAN_OWNER_CHECK,
        SET_PENDING_ADMIN_OWNER_CHECK,
        SET_PENDING_IMPLEMENTATION_OWNER_CHECK,
        SET_PRICE_ORACLE_OWNER_CHECK,
        SUPPORT_MARKET_EXISTS,
        SUPPORT_MARKET_OWNER_CHECK
    }

    /**
      * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary
      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.
      **/
    event Failure(uint error, uint info, uint detail);

    /**
      * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator
      */
    function fail(Error err, FailureInfo info) internal returns (uint) {
        emit Failure(uint(err), uint(info), 0);

        return uint(err);
    }

    /**
      * @dev use this when reporting an opaque error from an upgradeable collaborator contract
      */
    function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {
        emit Failure(uint(err), uint(info), opaqueError);

        return uint(err);
    }
}

contract TokenErrorReporter {
    uint public constant NO_ERROR = 0; // support legacy return codes

    error TransferMatrixpricerRejection(uint256 errorCode);
    error TransferTensorpricerRejection(uint256 errorCode);
    error TransferNotAllowed();
    error TransferNotEnough();
    error TransferNotEnoughAllowance();
    error TransferTooMuch();

    error MintMatrixpricerRejection(uint256 errorCode);
    error MintTensorpricerRejection(uint256 errorCode);
    error MintFreshnessCheck();

    error RedeemMatrixpricerRejection(uint256 errorCode);
    error RedeemTensorpricerRejection(uint256 errorCode);
    error RedeemFreshnessCheck();
    error RedeemTransferOutNotPossible();

    error BorrowMatrixpricerRejection(uint256 errorCode);
    error BorrowFreshnessCheck();
    error BorrowCashNotAvailable();

    error RepayBorrowMatrixpricerRejection(uint256 errorCode);
    error RepayBorrowFreshnessCheck();

    error LiquidateMatrixpricerRejection(uint256 errorCode);
    error LiquidateFreshnessCheck();
    error LiquidateCollateralFreshnessCheck();
    error LiquidateAccrueBorrowInterestFailed(uint256 errorCode);
    error LiquidateAccrueCollateralInterestFailed(uint256 errorCode);
    error LiquidateLiquidatorIsBorrower();
    error LiquidateCloseAmountIsZero();
    error LiquidateCloseAmountIsUintMax();
    error LiquidateRepayBorrowFreshFailed(uint256 errorCode);

    error LiquidateSeizeMatrixpricerRejection(uint256 errorCode);
    error LiquidateSeizeLiquidatorIsBorrower();

    error AcceptAdminPendingAdminCheck();

    error SetMatrixpricerOwnerCheck();
    error SetTensorpricerOwnerCheck();
    error SetPendingAdminOwnerCheck();

    error SetReserveFactorAdminCheck();
    error SetReserveFactorFreshCheck();
    error SetReserveFactorBoundsCheck();

    error AddReservesFactorFreshCheck(uint256 actualAddAmount);

    error ReduceReservesAdminCheck();
    error ReduceReservesFreshCheck();
    error ReduceReservesCashNotAvailable();
    error ReduceReservesCashValidation();

    error SetInterestRateModelOwnerCheck();
    error SetInterestRateModelFreshCheck();
}
// import "./DepositWithdraw.sol";

contract DepTokenStorage {
    //uint internal constant MAXGAS = 0;
    /**
     * @dev protection against contract calling itself (re-entrancy check)
     */
    bool internal _notEntered;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token, we use 6 to stay consistent with usdt
     */
    uint8 public decimals;

    // Maximum fraction of interest that can be set aside for reserves
    uint internal constant reserveFactorMaxMantissa = 1e18;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice the brain of this contract
     */
    MatrixpricerInterface public matrixpricer;

    /**
     * @notice Model that computes deposit and lending rate
     */
    InterestRateModel public interestRateModel;

    /**
     * @notice associated levErc20
     */
    LevErc20Interface public levErc20;

    // when totalSupply = 0, need to initialise an exchangeRate
    uint internal initialExchangeRateMantissa;  // 1e18

    /**
     * @notice Fraction of interest currently set aside for reserves
     */
    uint public reserveFactorMantissa;  //1e18

    /**
     * @notice Block number that interest was last accrued at
     */
    uint public accrualBlockNumber;

    /**
     * @notice Accumulator of the total earned interest rate since the opening of the market
     */
    uint public borrowIndex;

    /**
     * @notice Total amount of outstanding borrows of the underlying in this market
     */
    uint public totalBorrows;   // decimals = 6, same as underlying(=usdt)

    /**
     * @notice Total amount of reserves of the underlying held in this market
     */
    uint public totalReserves;   // decimals = 6, same as underlying(=usdt)

    /**
     * @notice Total number of tokens in circulation
     */
    uint public totalSupply;    // decimals = 6

    // Official record of token balances for each account
    mapping (address => uint) internal accountTokens;

    // Approved token transfer amounts on behalf of others
    mapping (address => mapping (address => uint)) internal transferAllowances;

    // usdt decimals is 6
    uint internal constant minTransferAmtUSDT = 50000e6;
    uint internal constant thresholdUSDT = 300000e6;
    uint internal constant extraUSDT = 100000e6;

    /**
     * @notice Container for borrow balance information
     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action
     * @member interestIndex Global borrowIndex as of the most recent balance-changing action
     */
    struct BorrowSnapshot {
        uint principal;
        uint interestIndex;
    }

    // Mapping of account addresses to outstanding borrow balances
    mapping(address => BorrowSnapshot) internal accountBorrows;

    /**
     * @notice Share of seized collateral that is added to reserves
     */
    uint public constant protocolSeizeShareMantissa = 2.8e16; //2.8%
}

abstract contract DepTokenInterface is DepTokenStorage {
    /**
     * @notice Indicator that this is a DepToken contract (for inspection)
     */
    bool public constant isDepToken = true;


    /*** Market Events ***/

    /**
     * @notice Event emitted when interest is accrued
     */
    event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens, uint apy);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens, uint apy);

    /**
     * @notice Event emitted when underlying is borrowed
     */
    event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);

    /**
     * @notice Event emitted when a borrow is repaid
     */
    event RepayBorrow(address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows, bool liquidate);

    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when matrixpricer is changed
     */
    event NewMatrixpricer(MatrixpricerInterface oldMatrixpricer, MatrixpricerInterface newMatrixpricer);

    /**
     * @notice Event emitted when interestRateModel is changed
     */
    //event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);

    /**
     * @notice Event emitted when the reserve factor is changed
     */
    event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);

    /**
     * @notice Event emitted when the reserves are added
     */
    event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);

    /**
     * @notice EIP20 Transfer event
     */
    event Transfer(address indexed from, address indexed to, uint amount);

    /**
     * @notice EIP20 Approval event
     */
    event Approval(address indexed owner, address indexed spender, uint amount);


    /*** User Interface ***/

    function transfer(address dst, uint amount) virtual external returns (bool);
    function transferFrom(address src, address dst, uint amount) virtual external returns (bool);
    function approve(address spender, uint amount) virtual external returns (bool);
    function allowance(address owner, address spender) virtual external view returns (uint);
    function balanceOf(address owner) virtual external view returns (uint);
    function balanceOfUnderlying(address owner) virtual external returns (uint);
    function balanceOfUnderlyingView(address owner) virtual external view returns (uint);
    function getAccountSnapshot(address account) virtual external view returns (uint, uint, uint, uint);
    function borrowRatePerBlock() virtual external view returns (uint);
    function supplyRatePerBlock() virtual public view returns (uint);
    function totalBorrowsCurrent() virtual external returns (uint);
    //function borrowBalanceCurrent(address account) virtual external returns (uint);
    //function borrowBalanceStored(address account) virtual internal view returns (uint);
    function exchangeRateCurrent() virtual external returns (uint);
    function exchangeRateStored() virtual external view returns (uint);
    function getCash() virtual external view returns (uint);
    function getCompoundBalance() virtual external view returns (uint);
    function accrueInterest() virtual external returns (uint);

    /*** Admin Functions ***/

    function _setPendingAdmin(address payable newPendingAdmin) virtual external returns (uint);
    function _acceptAdmin() virtual external returns (uint);
    function _setMatrixpricer(MatrixpricerInterface newMatrixpricer) virtual external returns (uint);
    function _setReserveFactor(uint newReserveFactorMantissa) virtual external returns (uint);
    function _reduceReserves(uint reduceAmount) virtual external returns (uint);
    function _setInterestRateModel(InterestRateModel newInterestRateModel) virtual external returns (uint);
}

contract DepErc20Storage {
    /**
     * @notice Underlying asset for this DepToken
     */
    address public underlying;
}

abstract contract DepErc20Interface is DepErc20Storage {

    /*** User Interface ***/

    function mint(uint mintAmount) virtual external returns (uint);
    function redeem(uint redeemTokens, uint redeemAmount) virtual external returns (uint);
    function borrow(uint borrowAmount) virtual external returns (uint);
    function repayBorrow(uint repayAmount, bool liquidate) virtual external returns (uint);
    function getUnborrowedUSDTBalance() virtual external view returns (uint);
    function getTotalBorrows() virtual external view returns (uint);    // only 1 borrower
    function getTotalBorrowsAfterAccrueInterest() virtual external returns (uint);    // only 1 borrower

    /*** Admin Functions ***/

    function _addReserves(uint addAmount) virtual external returns (uint);
}


interface ICompoundV2 {
    function mint(uint mintAmount) external returns (uint);
    function redeem(uint redeemTokens) external returns (uint);
    function redeemUnderlying(uint redeemAmount) external returns (uint);
    function balanceOf(address owner) external view returns (uint256);
    function borrowRatePerBlock() external view returns (uint);
    function supplyRatePerBlock() external view returns (uint);
    function exchangeRateStored() external view returns (uint);
}

interface INNERIERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
}

interface DepositWithdrawInterface {

    //function setAddresses(address depoAddr_, address leveAddr_) external;
    //function getCUSDTNumber() external view returns (uint);
    //function getCmpUSDTBalance() external view returns (uint);
    //function getCUSDCNumber() external view returns (uint);
    //function getCmpUSDCBalance() external view returns (uint);
    //function supplyUSDC(uint amount) external;
    //function withdrawcUSDC(uint amount) external;
    //function supplyUSDT2Cmp(uint amount) external;
    //function withdrawcUSDT(uint amount) external;
    //function withdrawUSDTfromCmp(uint amount) external;
    //function getCmpUSDTBorrowRate() external view returns (uint);
    //function getUSDTSupplyRate() external view returns (uint);
}// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)


/**
 * @dev Interface of the ERC20 standard as defined in the EIP.
 */
interface IERC20 {
    /**
     * @dev Emitted when `value` tokens are moved from one account (`from`) to
     * another (`to`).
     *
     * Note that `value` may be zero.
     */
    event Transfer(address indexed from, address indexed to, uint256 value);

    /**
     * @dev Emitted when the allowance of a `spender` for an `owner` is set by
     * a call to {approve}. `value` is the new allowance.
     */
    event Approval(address indexed owner, address indexed spender, uint256 value);

    /**
     * @dev Returns the amount of tokens in existence.
     */
    function totalSupply() external view returns (uint256);

    /**
     * @dev Returns the amount of tokens owned by `account`.
     */
    function balanceOf(address account) external view returns (uint256);

    /**
     * @dev Moves `amount` tokens from the caller's account to `to`.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transfer(address to, uint256 amount) external returns (bool);

    /**
     * @dev Returns the remaining number of tokens that `spender` will be
     * allowed to spend on behalf of `owner` through {transferFrom}. This is
     * zero by default.
     *
     * This value changes when {approve} or {transferFrom} are called.
     */
    function allowance(address owner, address spender) external view returns (uint256);

    /**
     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * IMPORTANT: Beware that changing an allowance with this method brings the risk
     * that someone may use both the old and the new allowance by unfortunate
     * transaction ordering. One possible solution to mitigate this race
     * condition is to first reduce the spender's allowance to 0 and set the
     * desired value afterwards:
     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
     *
     * Emits an {Approval} event.
     */
    function approve(address spender, uint256 amount) external returns (bool);

    /**
     * @dev Moves `amount` tokens from `from` to `to` using the
     * allowance mechanism. `amount` is then deducted from the caller's
     * allowance.
     *
     * Returns a boolean value indicating whether the operation succeeded.
     *
     * Emits a {Transfer} event.
     */
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)


// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)


/**
 * @dev Collection of functions related to the address type
 */
library Address {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionDelegateCall(target, data, "Address: low-level delegate call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a delegate call.
     *
     * _Available since v3.4._
     */
    function functionDelegateCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        (bool success, bytes memory returndata) = target.delegatecall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
     *
     * _Available since v4.8._
     */
    function verifyCallResultFromTarget(
        address target,
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        if (success) {
            if (returndata.length == 0) {
                // only check isContract if the call was successful and the return data is empty
                // otherwise we already know that it was a contract
                require(isContract(target), "Address: call to non-contract");
            }
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    /**
     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason or using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    function _revert(bytes memory returndata, string memory errorMessage) private pure {
        // Look for revert reason and bubble it up if present
        if (returndata.length > 0) {
            // The easiest way to bubble the revert reason is using memory via assembly
            /// @solidity memory-safe-assembly
            assembly {
                let returndata_size := mload(returndata)
                revert(add(32, returndata), returndata_size)
            }
        } else {
            revert(errorMessage);
        }
    }
}
/**
 * @title SafeERC20
 * @dev Wrappers around ERC20 operations that throw on failure (when the token
 * contract returns false). Tokens that return no value (and instead revert or
 * throw on failure) are also supported, non-reverting calls are assumed to be
 * successful.
 * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
 * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
 */
library SafeERC20 {
    using Address for address;

    function safeTransfer(
        IERC20 token,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(
        IERC20 token,
        address from,
        address to,
        uint256 value
    ) internal {
        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    /**
     * @dev Deprecated. This function has issues similar to the ones found in
     * {IERC20-approve}, and its usage is discouraged.
     *
     * Whenever possible, use {safeIncreaseAllowance} and
     * {safeDecreaseAllowance} instead.
     */
    function safeApprove(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        // safeApprove should only be called when setting an initial allowance,
        // or when resetting it to zero. To increase and decrease it, use
        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
        require(
            (value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function safeIncreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        uint256 newAllowance = token.allowance(address(this), spender) + value;
        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
    }

    function safeDecreaseAllowance(
        IERC20 token,
        address spender,
        uint256 value
    ) internal {
        unchecked {
            uint256 oldAllowance = token.allowance(address(this), spender);
            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
            uint256 newAllowance = oldAllowance - value;
            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));
        }
    }

    // function safePermit(
    //     IERC20Permit token,
    //     address owner,
    //     address spender,
    //     uint256 value,
    //     uint256 deadline,
    //     uint8 v,
    //     bytes32 r,
    //     bytes32 s
    // ) internal {
    //     uint256 nonceBefore = token.nonces(owner);
    //     token.permit(owner, spender, value, deadline, v, r, s);
    //     uint256 nonceAfter = token.nonces(owner);
    //     require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
    // }

    /**
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     */
    function _callOptionalReturn(IERC20 token, bytes memory data) private {
        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
        // the target address contains contract code and also asserts for success in the low-level call.

        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
        if (returndata.length > 0) {
            // Return data is optional
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}
contract DepositWithdraw is DepositWithdrawInterface {
    using SafeERC20 for IERC20;

    address internal compoundV2cUSDCAddress;
    address internal compoundV2cUSDTAddress;
    address internal USDCAddress;
    address internal USDTAddress;

    function setAddresses(address compoundV2cUSDCAddress_, address compoundV2cUSDTAddress_, address USDCAddress_, address USDTAddress_) internal {
        compoundV2cUSDCAddress = compoundV2cUSDCAddress_;
        compoundV2cUSDTAddress = compoundV2cUSDTAddress_;
        USDCAddress = USDCAddress_;
        USDTAddress = USDTAddress_;
    }

    function getCUSDTNumber() internal view returns (uint) {
        uint value = ICompoundV2(compoundV2cUSDTAddress).balanceOf(address(this));
        return value;
    }

    function getCmpUSDTExchRate() public virtual view returns (uint) {
        uint value = ICompoundV2(compoundV2cUSDTAddress).exchangeRateStored();
        return value;
    }

    function getCUSDCNumber() internal view returns (uint) {
        uint value = ICompoundV2(compoundV2cUSDCAddress).balanceOf(address(this));
        return value;
    }

    function getCmpUSDCExchRate() internal view returns (uint) {
        uint value = ICompoundV2(compoundV2cUSDCAddress).exchangeRateStored();
        return value;
    }

    /*function getCmpUSDTBorrowRate() public view returns (uint) {
        return ICompoundV2(compoundV2cUSDTAddress).borrowRatePerBlock();
    }*/

    function getCmpUSDTSupplyRate() virtual public view returns (uint) {
        return ICompoundV2(compoundV2cUSDTAddress).supplyRatePerBlock();
    }

    /*
     * Supply USDC that this contract holds to Compound V2
     */
    function supplyUSDC(uint amount) internal {
        IERC20(USDCAddress).safeApprove(compoundV2cUSDCAddress, amount);
        ICompoundV2(compoundV2cUSDCAddress).mint(amount);
    }

    /*
     * Withdraws cUSDC from Compound V2 to this contract
     */
    function withdrawcUSDC(uint amount) internal {
        ICompoundV2(compoundV2cUSDCAddress).redeem(amount);
    }

    /*
     * Withdraws USDC from Compound V2 to this contract
     */
    function withdrawUSDCfromCmp(uint amount) internal {
        ICompoundV2(compoundV2cUSDCAddress).redeemUnderlying(amount);
    }   

    /*
     * Supply USDT that this contract holds to Compound V2
     */
    function supplyUSDT2Cmp(uint amount) internal {
        IERC20(USDTAddress).safeApprove(compoundV2cUSDTAddress, amount);
        ICompoundV2(compoundV2cUSDTAddress).mint(amount);
    }

    /*
     * Withdraws cUSDT from Compound V2 to this contract
     */
    function withdrawcUSDT(uint amount) internal {
        ICompoundV2(compoundV2cUSDTAddress).redeem(amount);
    }   

    /*
     * Withdraws USDT from Compound V2 to this contract
     */
    function withdrawUSDTfromCmp(uint amount) internal {
        ICompoundV2(compoundV2cUSDTAddress).redeemUnderlying(amount);
    }    
}


interface ICurveFi {
    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external;
    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external;
}
interface IRegistry {
    // Get a list of decimal places for each coin within a pool.
    function get_decimals(address pool) external view returns (uint[8] memory);
    // Perform an token exchange using a specific pool.
    function exchange(address _pool, address _from, address _to, uint _amound, uint _expected, address _receiver) external returns (uint);
    // Get the current number of coins received in an exchange.
    // Returns the quantity of _to to be received in the exchange.
    function get_exchange_amount(address _pool, address _from, address _to, uint _amount) external view returns (uint);
}
interface IAddressProvider {
    // Get the address of the main registry contract.
    function get_registry() external view;
    function get_address(uint id) external view returns (address);
    // function get_id_info(uint id) external view returns (address, bool, uint, uint, string);

}
interface CurveContractInterface {
    // Functions in interfaces must be declared external,
    // function QueryAddressProvider(uint id) virtual internal view returns (address);
//    function QueryPoolInfo(address pool) virtual external view;
//    function QueryChangeRate(address _from, address _to, uint _dx) virtual external view returns (uint256);
    //function setAddresses(address depoAddr_, address leveAddr_) external;
    //function changeUSDT2USDC(uint _amount, uint _expected, address _receiver) external returns (uint256);
    //function changeUSDC2USDT(uint _amount, uint _expected, address _receiver) external returns (uint256);
    //function PerformExchange(address _from, address _to, uint _amount, uint _expected, address _receiver) external returns (uint256);
    // approveToken is a public func
    // function approveToken(address token, address spender, uint _amount) virtual public returns (bool);
}
contract CurveSwap is CurveContractInterface{
    using SafeERC20 for IERC20;
    address public TriPool;
    address public ADDRESSPROVIDER;
    address public USDC_ADDRESS;
    address public USDT_ADDRESS;

    function setAddressesCurve(address TriPool_, address ADDRESSPROVIDER_, address USDC_ADDRESS_, address USDT_ADDRESS_) internal {
//        TriPool = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;
//        ADDRESSPROVIDER = 0x0000000022D53366457F9d5E68Ec105046FC4383;
//        USDC_ADDRESS = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
//        USDT_ADDRESS = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
        TriPool = TriPool_;
        ADDRESSPROVIDER = ADDRESSPROVIDER_;
        USDC_ADDRESS = USDC_ADDRESS_;
        USDT_ADDRESS = USDT_ADDRESS_;
    }

    function QueryAddressProvider(uint id) internal view returns (address) {
        return IAddressProvider(ADDRESSPROVIDER).get_address(id);
    }

//    function QueryChangeRate(address _from, address _to, uint _dx) external view returns (uint256) {
//        address Registry = QueryAddressProvider(2);
//        uint dy = IRegistry(Registry).get_exchange_amount(TriPool, _from, _to, _dx);
//        return dy;
//    }

    function PerformExchange(address _from, address _to, uint _amount, uint _expected, address _receiver) internal returns (uint256) {
        address Registry = QueryAddressProvider(2);
        uint receToken = IRegistry(Registry).exchange(TriPool, _from, _to, _amount, _expected, _receiver);
        return receToken;
    }

    function changeUSDT2USDC(uint _amount, uint _expected, address _receiver) virtual internal returns (uint256) {
        address Registry = QueryAddressProvider(2);
        approveToken(USDT_ADDRESS, Registry, _amount);
        uint receToken = IRegistry(Registry).exchange(TriPool, USDT_ADDRESS, USDC_ADDRESS, _amount, _expected, _receiver);
        return receToken;
    }

    function changeUSDC2USDT(uint _amount, uint _expected, address _receiver) internal returns (uint256) {
        address Registry = QueryAddressProvider(2);
        approveToken(USDC_ADDRESS, Registry, _amount);
        uint receToken = IRegistry(Registry).exchange(TriPool, USDC_ADDRESS, USDT_ADDRESS, _amount, _expected, _receiver);
        return receToken;
    }

    function approveToken(address token, address spender, uint _amount) public returns (bool) {
        IERC20(token).safeApprove(spender, _amount);
        return true;
    }
}
contract LevTokenStorage {
    /**
     * @dev protection against contract calling itself (re-entrancy check)
     */
    bool internal _notEntered;

    /**
     * @notice EIP-20 token name for this token
     */
    string public name;

    /**
     * @notice EIP-20 token symbol for this token
     */
    string public symbol;

    /**
     * @notice EIP-20 token decimals for this token, we use 6 to stay consistent with usdc
     */
    uint8 public decimals;

    /**
     * @notice Administrator for this contract
     */
    address payable public admin;

    /**
     * @notice Pending administrator for this contract
     */
    address payable public pendingAdmin;

    /**
     * @notice the brain of this contract
     */
    TensorpricerInterface public tensorpricer;

    /**
     * @notice associated depErc20
     */
    DepErc20Interface public depErc20;

    // when totalSupply = 0, need to initialise a NAV
    uint internal constant initialNetAssetValueMantissa = 1e18;  // treat like fx rate, 1e18

    // when totalSupply = 0, need to initialise a targetLevRatio
    uint internal constant initialTargetLevRatio = 5e18;

    /**
     * @notice Total number of tokens in circulation
     */
    uint public totalSupply;    // 1e6

    /**
     * @notice Total amount of outstanding borrow in USDT in this market
     */
    uint public borrowBalanceUSDT;  // in usdt, decimals=6

    /**
     * @notice Total amount of outstanding borrow valued in USDC in this market
     */
    uint public borrowBalanceUSDC;  // in usdc, decimals=6

    /**
     * @notice Total asset value in USDC
     */
    uint public totalAssetValue;  // in usdc, decimals=6

    /**
     * @notice net asset value in USDC
     */
    uint public netAssetValue;  // in usdc, BUT decimals=18, asset per levToken

    /**
     * @notice leverage ratio
     */
    uint public levRatio;   // 1e18

    /**
     * @notice
     */
    uint public extraBorrowDemand;  // in usdt, decimals=6

    /**
     * @notice
     */
    uint public extraBorrowSupply;  // in usdt, decimals=6

    uint public targetLevRatio; // 1e18

    // Official record of token balances for each account
    mapping (address => uint) internal accountTokens;

    // Approved token transfer amounts on behalf of others
    mapping (address => mapping (address => uint)) internal transferAllowances;

    // usdc decimals is 6
    uint internal constant minTransferAmtUSDC = 50000e6;
    uint internal constant thresholdUSDC = 300000e6;
    uint internal constant extraUSDC = 100000e6;

    struct checkRebalanceRes {
        uint res;
        uint targetLevRatio;
        uint tmpBorrowBalanceUSDC;
        uint tmpTotalAssetValue;
        uint tmpLevRatio;
    }

    uint internal hisHighNav;
    uint internal levReserve;   // 1e6
    uint internal constant redeemFeePC = 1e15;
    uint internal constant perfPC = 1e17;

    uint internal redeemAmountInUSDC;
}

abstract contract LevTokenInterface is LevTokenStorage {
    /**
     * @notice Indicator that this is a LevToken contract (for inspection)
     */
    bool public constant isLevToken = true;


    /*** Market Events ***/

    /**
     * @notice Event emitted when tokens are minted
     */
    event Mint(address minter, uint mintAmount, uint mintTokens, uint nav);

    /**
     * @notice Event emitted when tokens are redeemed
     */
    event Redeem(address redeemer, uint redeemAmount, uint redeemTokens, uint nav);

    /**
     * @notice Event emitted when forceRepay is triggered
     */
    event ForceRepay(address forcer, uint repayAmount);


    /*** Admin Events ***/

    /**
     * @notice Event emitted when pendingAdmin is changed
     */
    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);

    /**
     * @notice Event emitted when pendingAdmin is accepted, which means admin is updated
     */
    event NewAdmin(address oldAdmin, address newAdmin);

    /**
     * @notice Event emitted when tensorpricer is changed
     */
    event NewTensorpricer(TensorpricerInterface oldTensorpricer, TensorpricerInterface newTensorpricer);

    /**
     * @notice EIP20 Transfer event
     */
    event Transfer(address indexed from, address indexed to, uint amount);

    /**
     * @notice EIP20 Approval event
     */
    event Approval(address indexed owner, address indexed spender, uint amount);

    /**
     * @notice Event emitted when the reserves are reduced
     */
    event ReservesReduced(address admin, uint reduceAmount, uint newLevReserve);

    /*** User Interface ***/

    function transfer(address dst, uint amount) virtual external returns (bool);
    function transferFrom(address src, address dst, uint amount) virtual external returns (bool);
    function approve(address spender, uint amount) virtual external returns (bool);
    function allowance(address owner, address spender) virtual external view returns (uint);
    function balanceOf(address owner) virtual external view returns (uint);
    function getNAV(address owner) virtual external view returns (uint);
    function getAccountSnapshot(address account) virtual external view returns (uint, uint);
    function getCash() virtual external view returns (uint);
    function getCompoundBalance() virtual external view returns (uint);
    function getLevReserve() virtual external view returns (uint);
    function getHisHighNav() virtual external view returns (uint);
    
    /*** Admin Functions ***/

    function _setPendingAdmin(address payable newPendingAdmin) virtual external returns (uint);
    function _acceptAdmin() virtual external returns (uint);
    function _setTensorpricer(TensorpricerInterface newTensorpricer) virtual external returns (uint);
    function _reduceReserves(uint reduceAmount) virtual external returns (uint);
}

contract LevErc20Storage {
    /**
     * @notice Underlying asset for this LevToken
     */
    address public underlying;  // USDC
    address public borrowUnderlying;    // USDT
}

abstract contract LevErc20Interface is LevErc20Storage {

    /*** User Interface ***/

    function getAdmin() virtual external returns (address payable);
    function mint(uint mintAmount) virtual external returns (uint);
    function redeem(uint redeemTokens) virtual external returns (uint);
    function sweepToken(EIP20NonStandardInterface token) virtual external;
    function getExtraBorrowDemand() virtual external view returns (uint256);
    function getExtraBorrowSupply() virtual external view returns (uint256);
    function forceRepay(uint256 repayAmount) virtual external returns (uint);
    function updateLedger() virtual external;
}
/**
 * @title ERC 20 Token Standard Interface
 *  https://eips.ethereum.org/EIPS/eip-20
 */
interface EIP20Interface {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);

    /**
      * @notice Get the total number of tokens in circulation
      * @return The supply of tokens
      */
    function totalSupply() external view returns (uint256);

    /**
     * @notice Gets the balance of the specified address
     * @param owner The address from which the balance will be retrieved
     * @return balance The balance
     */
    function balanceOf(address owner) external view returns (uint256 balance);

    /**
      * @notice Transfer `amount` tokens from `msg.sender` to `dst`
      * @param dst The address of the destination account
      * @param amount The number of tokens to transfer
      * @return success Whether or not the transfer succeeded
      */
    function transfer(address dst, uint256 amount) external returns (bool success);

    /**
      * @notice Transfer `amount` tokens from `src` to `dst`
      * @param src The address of the source account
      * @param dst The address of the destination account
      * @param amount The number of tokens to transfer
      * @return success Whether or not the transfer succeeded
      */
    function transferFrom(address src, address dst, uint256 amount) external returns (bool success);

    /**
      * @notice Approve `spender` to transfer up to `amount` from `src`
      * @dev This will overwrite the approval amount for `spender`
      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
      * @param spender The address of the account which may transfer tokens
      * @param amount The number of tokens that are approved (-1 means infinite)
      * @return success Whether or not the approval succeeded
      */
    function approve(address spender, uint256 amount) external returns (bool success);

    /**
      * @notice Get the current allowance from `owner` for `spender`
      * @param owner The address of the account which owns the tokens to be spent
      * @param spender The address of the account which may transfer tokens
      * @return remaining The number of tokens allowed to be spent (-1 means infinite)
      */
    function allowance(address owner, address spender) external view returns (uint256 remaining);

    event Transfer(address indexed from, address indexed to, uint256 amount);
    event Approval(address indexed owner, address indexed spender, uint256 amount);
}

/**
 * @title Exponential module for storing fixed-precision decimals
 * @author Compound
 * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.
 *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:
 *         `Exp({mantissa: 5100000000000000000})`.
 */
contract ExponentialNoError {
    uint constant expScale = 1e18;
    uint constant doubleScale = 1e36;
    uint constant halfExpScale = expScale/2;
    uint constant mantissaOne = expScale;

    struct Exp {
        uint mantissa;
    }

    struct Double {
        uint mantissa;
    }

    /**
     * @dev Truncates the given exp to a whole number value.
     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15
     */
    function truncate(Exp memory exp) pure internal returns (uint) {
        // Note: We are not using careful math here as we're performing a division that cannot fail
        return exp.mantissa / expScale;
    }

    /**
     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.
     */
    function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {
        Exp memory product = mul_(a, scalar);
        return truncate(product);
    }

    /**
     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.
     */
    function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {
        Exp memory product = mul_(a, scalar);
        return add_(truncate(product), addend);
    }

    /**
     * @dev Checks if first Exp is less than second Exp.
     */
    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {
        return left.mantissa < right.mantissa;
    }

    /**
     * @dev Checks if left Exp <= right Exp.
     */
    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {
        return left.mantissa <= right.mantissa;
    }

    /**
     * @dev Checks if left Exp > right Exp.
     */
    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {
        return left.mantissa > right.mantissa;
    }

    /**
     * @dev returns true if Exp is exactly zero
     */
    function isZeroExp(Exp memory value) pure internal returns (bool) {
        return value.mantissa == 0;
    }

    function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {
        require(n < 2**224, errorMessage);
        return uint224(n);
    }

    function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {
        require(n < 2**32, errorMessage);
        return uint32(n);
    }

    function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {
        return Exp({mantissa: add_(a.mantissa, b.mantissa)});
    }

    function add_(Double memory a, Double memory b) pure internal returns (Double memory) {
        return Double({mantissa: add_(a.mantissa, b.mantissa)});
    }

    function add_(uint a, uint b) pure internal returns (uint) {
        return a + b;
    }

    function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {
        return Exp({mantissa: sub_(a.mantissa, b.mantissa)});
    }

    function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {
        return Double({mantissa: sub_(a.mantissa, b.mantissa)});
    }

    function sub_(uint a, uint b) pure internal returns (uint) {
        return a - b;
    }

    function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {
        return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});
    }

    function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {
        return Exp({mantissa: mul_(a.mantissa, b)});
    }

    function mul_(uint a, Exp memory b) pure internal returns (uint) {
        return mul_(a, b.mantissa) / expScale;
    }

    function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {
        return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});
    }

    function mul_(Double memory a, uint b) pure internal returns (Double memory) {
        return Double({mantissa: mul_(a.mantissa, b)});
    }

    function mul_(uint a, Double memory b) pure internal returns (uint) {
        return mul_(a, b.mantissa) / doubleScale;
    }

    function mul_(uint a, uint b) pure internal returns (uint) {
        return a * b;
    }

    function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {
        return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});
    }

    function div_(Exp memory a, uint b) pure internal returns (Exp memory) {
        return Exp({mantissa: div_(a.mantissa, b)});
    }

    function div_(uint a, Exp memory b) pure internal returns (uint) {
        return div_(mul_(a, expScale), b.mantissa);
    }

    function div_(Double memory a, Double memory b) pure internal returns (Double memory) {
        return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});
    }

    function div_(Double memory a, uint b) pure internal returns (Double memory) {
        return Double({mantissa: div_(a.mantissa, b)});
    }

    function div_(uint a, Double memory b) pure internal returns (uint) {
        return div_(mul_(a, doubleScale), b.mantissa);
    }

    function div_(uint a, uint b) pure internal returns (uint) {
        return a / b;
    }

    function fraction(uint a, uint b) pure internal returns (Double memory) {
        return Double({mantissa: div_(mul_(a, doubleScale), b)});
    }
}
// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)


// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)


/**
 * @dev Collection of functions related to the address type
 */
library AddressUpgradeable {
    /**
     * @dev Returns true if `account` is a contract.
     *
     * [IMPORTANT]
     * ====
     * It is unsafe to assume that an address for which this function returns
     * false is an externally-owned account (EOA) and not a contract.
     *
     * Among others, `isContract` will return false for the following
     * types of addresses:
     *
     *  - an externally-owned account
     *  - a contract in construction
     *  - an address where a contract will be created
     *  - an address where a contract lived, but was destroyed
     * ====
     *
     * [IMPORTANT]
     * ====
     * You shouldn't rely on `isContract` to protect against flash loan attacks!
     *
     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
     * constructor.
     * ====
     */
    function isContract(address account) internal view returns (bool) {
        // This method relies on extcodesize/address.code.length, which returns 0
        // for contracts in construction, since the code is only stored at the end
        // of the constructor execution.

        return account.code.length > 0;
    }

    /**
     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
     * `recipient`, forwarding all available gas and reverting on errors.
     *
     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
     * of certain opcodes, possibly making contracts go over the 2300 gas limit
     * imposed by `transfer`, making them unable to receive funds via
     * `transfer`. {sendValue} removes this limitation.
     *
     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].
     *
     * IMPORTANT: because control is transferred to `recipient`, care must be
     * taken to not create reentrancy vulnerabilities. Consider using
     * {ReentrancyGuard} or the
     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
     */
    function sendValue(address payable recipient, uint256 amount) internal {
        require(address(this).balance >= amount, "Address: insufficient balance");

        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Address: unable to send value, recipient may have reverted");
    }

    /**
     * @dev Performs a Solidity function call using a low level `call`. A
     * plain `call` is an unsafe replacement for a function call: use this
     * function instead.
     *
     * If `target` reverts with a revert reason, it is bubbled up by this
     * function (like regular Solidity function calls).
     *
     * Returns the raw returned data. To convert to the expected return value,
     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
     *
     * Requirements:
     *
     * - `target` must be a contract.
     * - calling `target` with `data` must not revert.
     *
     * _Available since v3.1._
     */
    function functionCall(address target, bytes memory data) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, "Address: low-level call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
     * `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, 0, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but also transferring `value` wei to `target`.
     *
     * Requirements:
     *
     * - the calling contract must have an ETH balance of at least `value`.
     * - the called Solidity function must be `payable`.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value
    ) internal returns (bytes memory) {
        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
    }

    /**
     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
     * with `errorMessage` as a fallback revert reason when `target` reverts.
     *
     * _Available since v3.1._
     */
    function functionCallWithValue(
        address target,
        bytes memory data,
        uint256 value,
        string memory errorMessage
    ) internal returns (bytes memory) {
        require(address(this).balance >= value, "Address: insufficient balance for call");
        (bool success, bytes memory returndata) = target.call{value: value}(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
        return functionStaticCall(target, data, "Address: low-level static call failed");
    }

    /**
     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
     * but performing a static call.
     *
     * _Available since v3.3._
     */
    function functionStaticCall(
        address target,
        bytes memory data,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        (bool success, bytes memory returndata) = target.staticcall(data);
        return verifyCallResultFromTarget(target, success, returndata, errorMessage);
    }

    /**
     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
     *
     * _Available since v4.8._
     */
    function verifyCallResultFromTarget(
        address target,
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal view returns (bytes memory) {
        if (success) {
            if (returndata.length == 0) {
                // only check isContract if the call was successful and the return data is empty
                // otherwise we already know that it was a contract
                require(isContract(target), "Address: call to non-contract");
            }
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    /**
     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
     * revert reason or using the provided one.
     *
     * _Available since v4.3._
     */
    function verifyCallResult(
        bool success,
        bytes memory returndata,
        string memory errorMessage
    ) internal pure returns (bytes memory) {
        if (success) {
            return returndata;
        } else {
            _revert(returndata, errorMessage);
        }
    }

    function _revert(bytes memory returndata, string memory errorMessage) private pure {
        // Look for revert reason and bubble it up if present
        if (returndata.length > 0) {
            // The easiest way to bubble the revert reason is using memory via assembly
            /// @solidity memory-safe-assembly
            assembly {
                let returndata_size := mload(returndata)
                revert(add(32, returndata), returndata_size)
            }
        } else {
            revert(errorMessage);
        }
    }
}

/**
 * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed
 * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an
 * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer
 * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.
 *
 * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be
 * reused. This mechanism prevents re-execution of each "step" but allows the creation of new initialization steps in
 * case an upgrade adds a module that needs to be initialized.
 *
 * For example:
 *
 * [.hljs-theme-light.nopadding]
 * ```
 * contract MyToken is ERC20Upgradeable {
 *     function initialize() initializer public {
 *         __ERC20_init("MyToken", "MTK");
 *     }
 * }
 * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {
 *     function initializeV2() reinitializer(2) public {
 *         __ERC20Permit_init("MyToken");
 *     }
 * }
 * ```
 *
 * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as
 * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.
 *
 * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure
 * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.
 *
 * [CAUTION]
 * ====
 * Avoid leaving a contract uninitialized.
 *
 * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation
 * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke
 * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:
 *
 * [.hljs-theme-light.nopadding]
 * ```
 * /// @custom:oz-upgrades-unsafe-allow constructor
 * constructor() {
 *     _disableInitializers();
 * }
 * ```
 * ====
 */
abstract contract Initializable {
    /**
     * @dev Indicates that the contract has been initialized.
     * @custom:oz-retyped-from bool
     */
    uint8 private _initialized;

    /**
     * @dev Indicates that the contract is in the process of being initialized.
     */
    bool private _initializing;

    /**
     * @dev Triggered when the contract has been initialized or reinitialized.
     */
    event Initialized(uint8 version);

    /**
     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,
     * `onlyInitializing` functions can be used to initialize parent contracts.
     *
     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a
     * constructor.
     *
     * Emits an {Initialized} event.
     */
    modifier initializer() {
        bool isTopLevelCall = !_initializing;
        require(
            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),
            "Initializable: contract is already initialized"
        );
        _initialized = 1;
        if (isTopLevelCall) {
            _initializing = true;
        }
        _;
        if (isTopLevelCall) {
            _initializing = false;
            emit Initialized(1);
        }
    }

    /**
     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the
     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be
     * used to initialize parent contracts.
     *
     * A reinitializer may be used after the original initialization step. This is essential to configure modules that
     * are added through upgrades and that require initialization.
     *
     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`
     * cannot be nested. If one is invoked in the context of another, execution will revert.
     *
     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in
     * a contract, executing them in the right order is up to the developer or operator.
     *
     * WARNING: setting the version to 255 will prevent any future reinitialization.
     *
     * Emits an {Initialized} event.
     */
    modifier reinitializer(uint8 version) {
        require(!_initializing && _initialized < version, "Initializable: contract is already initialized");
        _initialized = version;
        _initializing = true;
        _;
        _initializing = false;
        emit Initialized(version);
    }

    /**
     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the
     * {initializer} and {reinitializer} modifiers, directly or indirectly.
     */
    modifier onlyInitializing() {
        require(_initializing, "Initializable: contract is not initializing");
        _;
    }

    /**
     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.
     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized
     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called
     * through proxies.
     *
     * Emits an {Initialized} event the first time it is successfully executed.
     */
    function _disableInitializers() internal virtual {
        require(!_initializing, "Initializable: contract is initializing");
        if (_initialized < type(uint8).max) {
            _initialized = type(uint8).max;
            emit Initialized(type(uint8).max);
        }
    }

    /**
     * @dev Returns the highest version that has been initialized. See {reinitializer}.
     */
    function _getInitializedVersion() internal view returns (uint8) {
        return _initialized;
    }

    /**
     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.
     */
    function _isInitializing() internal view returns (bool) {
        return _initializing;
    }
}

/**
 * @title LevToken Contract
 * @notice Abstract base for LevTokens
 * @author Vortex
 */
abstract contract LevToken is LevTokenInterface, DepositWithdraw, CurveSwap, ExponentialNoError, TokenErrorReporter, Initializable {

    /**
     * @notice set the depErc20 token
     * @param depErc20_ The address of the associated depErc20
     */
    function setDepErc20(DepErc20Interface depErc20_) public virtual{
        require(msg.sender == admin, "only admin may set depErc20");
        depErc20 = depErc20_;
    }

    /**
     * @notice Initialize the money market
     * @param tensorpricer_ The address of the Tensorpricer
     * @param name_ EIP-20 name of this token
     * @param symbol_ EIP-20 symbol of this token
     * @param decimals_ EIP-20 decimal precision of this token
     */
    function initialize(address underlying_,
                        address borrowUnderlying_,
                        TensorpricerInterface tensorpricer_,
                        string memory name_,
                        string memory symbol_,
                        uint8 decimals_) public virtual onlyInitializing {
        require(msg.sender == admin, "only admin may initialize the market");
        
        // Set the tensorpricer
        uint err = _setTensorpricer(tensorpricer_);
        require(err == NO_ERROR, "setting tensorpricer failed");

        name = name_;
        symbol = symbol_;
        decimals = decimals_;

        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)
        _notEntered = true;
    }

    /**
     * @notice Initialize the compound portion
     * @param compoundV2cUSDCAddress_ The address of the cUSDC
     * @param compoundV2cUSDTAddress_ The address of the cUSDT
     * @param USDCAddress_ The address of USDC
     * @param USDTAddress_ The address of USDT
    */
    function setAddressesForCompound(address compoundV2cUSDCAddress_, address compoundV2cUSDTAddress_, address USDCAddress_, address USDTAddress_) public {
        require(msg.sender==admin, "only admin can set addresses in general");
        setAddresses(compoundV2cUSDCAddress_, compoundV2cUSDTAddress_, USDCAddress_, USDTAddress_);
    }

    /**
     * @notice Initialize the curve portion
     * @param TriPool_ The address of the Tripool
     * @param ADDRESSPROVIDER_ The address of the curve provider
     * @param USDC_ADDRESS_ The address of USDC
     * @param USDT_ADDRESS_ The address of USDT
    */
    function setAddressesForCurve(address TriPool_, address ADDRESSPROVIDER_, address USDC_ADDRESS_, address USDT_ADDRESS_) public {
        require(msg.sender==admin, "only admin can set addresses in general");
        setAddressesCurve(TriPool_, ADDRESSPROVIDER_, USDC_ADDRESS_, USDT_ADDRESS_);
    }

    /**
     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`
     * @dev Called by both `transfer` and `transferFrom` internally
     * @param spender The address of the account performing the transfer
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param tokens The number of tokens to transfer
     * @return 0 if the transfer succeeded, else revert
     */
    function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {
        /* Fail if transfer not allowed */
        uint allowed = tensorpricer.transferAllowed(address(this), src, dst, tokens);
        if (allowed != 0) {
            revert TransferTensorpricerRejection(allowed);   // change the name
        }

        /* Do not allow self-transfers */
        if (src == dst) {
            revert TransferNotAllowed();
        }

        /* Get the allowance, infinite for the account owner */
        uint startingAllowance = 0;
        if (spender == src) {
            startingAllowance = type(uint).max;
        } else {
            startingAllowance = transferAllowances[src][spender];
            if(startingAllowance < tokens){
                revert TransferNotEnoughAllowance();
            }
        }

        /* Do the calculations, checking for {under,over}flow */
        uint allowanceNew = startingAllowance - tokens;
        uint srLevTokensNew = accountTokens[src] - tokens;
        uint dstTokensNew = accountTokens[dst] + tokens;

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        accountTokens[src] = srLevTokensNew;
        accountTokens[dst] = dstTokensNew;

        /* Eat some of the allowance (if necessary) */
        if (startingAllowance != type(uint).max) {
            transferAllowances[src][spender] = allowanceNew;
        }

        /* We emit a Transfer event */
        emit Transfer(src, dst, tokens);

        return NO_ERROR;
    }

    /**
     * @notice Transfer `amount` tokens from `msg.sender` to `dst`
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transfer(address dst, uint256 amount) override external nonReentrant returns (bool) {
        return transferTokens(msg.sender, msg.sender, dst, amount) == NO_ERROR;
    }

    /**
     * @notice Transfer `amount` tokens from `src` to `dst`
     * @param src The address of the source account
     * @param dst The address of the destination account
     * @param amount The number of tokens to transfer
     * @return Whether or not the transfer succeeded
     */
    function transferFrom(address src, address dst, uint256 amount) override external nonReentrant returns (bool) {
        return transferTokens(msg.sender, src, dst, amount) == NO_ERROR;
    }

    /**
     * @notice Approve `spender` to transfer up to `amount` from `src`
     * @dev This will overwrite the approval amount for `spender`
     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)
     * @param spender The address of the account which may transfer tokens
     * @param amount The number of tokens that are approved (uint256.max means infinite)
     * @return Whether or not the approval succeeded
     */
    function approve(address spender, uint256 amount) override external returns (bool) {
        address src = msg.sender;
        transferAllowances[src][spender] = amount;
        emit Approval(src, spender, amount);
        return true;
    }

    /**
     * @notice Get the current allowance from `owner` for `spender`
     * @param owner The address of the account which owns the tokens to be spent
     * @param spender The address of the account which may transfer tokens
     * @return The number of tokens allowed to be spent (-1 means infinite)
     */
    function allowance(address owner, address spender) override external view returns (uint256) {
        return transferAllowances[owner][spender];
    }

    /**
     * @notice Get the token balance of the `owner`
     * @param owner The address of the account to query
     * @return The number of tokens owned by `owner`
     */
    function balanceOf(address owner) override external view returns (uint256) {
        return accountTokens[owner];
    }

    /**
     * @notice Get the nav of the `owner`
     * @dev
     * @param owner The address of the account to query
     * @return The amount of nav owned by `owner`
     */
    function getNAV(address owner) override external view returns (uint) {
        Exp memory nav = Exp({mantissa: netAssetValue});
        return mul_ScalarTruncate(nav, accountTokens[owner]);
    }

    /**
     * @notice Get a snapshot of the account's balances, and the cached exchange rate
     * @dev This is used by tensorpricer to more efficiently perform liquidity checks.
     * @param account Address of the account to snapshot
     * @return (possible error, token balance, borrow balance, exchange rate mantissa)
     */
    function getAccountSnapshot(address account) override external view returns (uint, uint) {
        return (
            NO_ERROR,
            accountTokens[account]
        );
    }

    /**
     * @notice Get cash balance of this LevToken in USDC
     * @return The quantity of USDC owned by this contract (deposits + amt obtained from sale of USDT)
     */
    function getCash() override external view returns (uint) {
        return getCashPrior();
    }

    /**
     * @notice Get cash balance deposited at compound
     * @return The quantity of underlying asset owned by this contract
     */
    function getCompoundBalance() override external view returns (uint) {
        return getCmpBalanceInternal();
    }

    function getCmpBalanceInternal() internal view returns (uint) {
        Exp memory exchangeRate = Exp({mantissa: getCmpUSDCExchRate()});
        return mul_ScalarTruncate(exchangeRate, getCUSDCNumber());
    }

    function getLevReserve() override external view returns (uint) {
        return levReserve;
    }

    function getHisHighNav() override external view returns (uint) {
        return hisHighNav;
    }

    // rebalance specific:

    /**
     * @notice Calculates the net asset value of the levToken
     * @dev
     * @return calculated net asset value scaled by 1e18
     */
    function updateNetAssetValue(uint latestBorrowBalanceUSDC, uint offset) internal {//nonReentrant {
        netAssetValue = calcNetAssetValue(latestBorrowBalanceUSDC, offset);
    }

    /**
     * @notice Calculates the net asset value of the levToken
     * @dev
     * @return calculated net asset value scaled by 1e18
     */
    function calcNetAssetValue(uint latestBorrowBalanceUSDC, uint offset) internal view returns (uint){//nonReentrant {
        uint _totalSupply = totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  NAV = initialNAV
             */
            return initialNetAssetValueMantissa;
        } else {
            /*
             * Otherwise:
             *  NAV = (USDC_Balance - borrowed_USDT_Balance * fx_USDTUSDC) / totalSupply
             */
            uint balanceUSDCExReserves = getCashExReserves() + getCmpBalanceInternal();
            if(balanceUSDCExReserves > latestBorrowBalanceUSDC + offset){
                return (balanceUSDCExReserves - latestBorrowBalanceUSDC - offset) * expScale / _totalSupply;
            }else{
                return 0;
            }
        }
    }

    function updateStats(bool recalc, uint tmpTotalAssetValue, uint tmpLevRatio, uint redeemTokensIn) internal {
        if(recalc){
            uint availCash = getCashExReserves() + getCmpBalanceInternal();
            if(redeemTokensIn > 0){
                uint currTotalAssetValue;
                uint amtToSubtract;
                if(availCash > borrowBalanceUSDC){
                    currTotalAssetValue = availCash - borrowBalanceUSDC;
                    uint currNav = currTotalAssetValue * expScale / totalSupply;
                    redeemAmountInUSDC = currNav * redeemTokensIn / expScale;
                    //console.log("calc redeemAmountInUSDC=",redeemAmountInUSDC);
                    amtToSubtract = borrowBalanceUSDC + redeemAmountInUSDC;
                }else{
                    currTotalAssetValue = 0;
                    amtToSubtract = borrowBalanceUSDC;
                }
                if(availCash > amtToSubtract){
                    totalAssetValue = availCash - amtToSubtract;
                    levRatio = borrowBalanceUSDC*expScale / totalAssetValue;
                }else{
                    totalAssetValue = 0;
                    levRatio = 0;
                }
            }else{
                uint amtToSubtract = borrowBalanceUSDC;
                if(availCash > amtToSubtract){
                    totalAssetValue = availCash - amtToSubtract;
                    levRatio = borrowBalanceUSDC*expScale / totalAssetValue;
                }else{
                    totalAssetValue = 0;
                    levRatio = 0;
                }
            }
        }else{
            if(redeemTokensIn > 0){
                uint availCash = getCashExReserves() + getCmpBalanceInternal();
                //uint currNav = tmpTotalAssetValue * expScale / totalSupply; // wrong
                uint currNav = tmpTotalAssetValue * expScale / (totalSupply - redeemTokensIn);
                //console.log("tmpTotalAssetValue=",tmpTotalAssetValue);
                redeemAmountInUSDC = currNav * redeemTokensIn / expScale;
                //console.log("non calc redeemAmountInUSDC=",redeemAmountInUSDC);
                //console.log("currNav=",currNav);
                uint amtToSubtract = borrowBalanceUSDC + redeemAmountInUSDC;
                if(availCash > amtToSubtract){
                    totalAssetValue = availCash - amtToSubtract;
                    levRatio = borrowBalanceUSDC*expScale / totalAssetValue;
                }else{
                    totalAssetValue = 0;
                    levRatio = 0;
                }
            }else{  
                totalAssetValue = tmpTotalAssetValue;
                levRatio = tmpLevRatio; 
            }
        }
    }

    function refreshTargetLevRatio(uint fx_USDTUSDC_Mantissa) public pure returns (uint, uint, uint) {
        // targetLevRatio, releverageTrigger, deleverageTrigger
        if(fx_USDTUSDC_Mantissa < 6e17 || fx_USDTUSDC_Mantissa > 14e17){
            return (1e18, 0, 2e18);
        }else if(fx_USDTUSDC_Mantissa < 9e17 || fx_USDTUSDC_Mantissa > 11e17){
            return (3e18, 2e18, 4e18);
        }else{
            return (5e18, 4e18, 6e18);
        }
    }

    function updateExtraBorrow(Exp memory fx_USDTUSDC, uint tmpTotalAssetValue, uint targetLevRatio) internal {
        uint targetBorrowUSDT = div_(targetLevRatio*tmpTotalAssetValue/expScale, fx_USDTUSDC);
//        console.log("tmpTotalAssetValue,targetLevRatio=%d,%d",tmpTotalAssetValue,targetLevRatio);
//        console.log("targetBorrowUSDT,borrowBalanceUSDT=%d,%d",targetBorrowUSDT,borrowBalanceUSDT);
        if(targetBorrowUSDT > borrowBalanceUSDT){
            extraBorrowDemand = targetBorrowUSDT - borrowBalanceUSDT;
            extraBorrowSupply = 0;
        }else{
            extraBorrowDemand = 0;
            extraBorrowSupply = borrowBalanceUSDT - targetBorrowUSDT;
        }
    }

    function updateBorrowBalances(uint fxToUse, uint newBorrowBalanceUSDT) internal {
        borrowBalanceUSDT = newBorrowBalanceUSDT;
        borrowBalanceUSDC = newBorrowBalanceUSDT * fxToUse / expScale;
    }

    function releverage(uint newBorrowDemand) internal {
        // depToken goes to curve to sell its own USDT to USDC pushing USDC to leverager directly. simple
        uint transFx = depErc20.borrow(newBorrowDemand);
        updateBorrowBalances(transFx, depErc20.getTotalBorrows());  // only 1 borrower, no need to parse in address
    }

    function deleverage(Exp memory fx_USDTUSDC, uint newBorrowSupply, bool isRedeemAll) internal returns (bool) {
        uint amtUSDC = mul_(newBorrowSupply, fx_USDTUSDC);
        if(isRedeemAll){
            amtUSDC = amtUSDC * 105 / 100;  // add 5% buffer
            withdrawUSDCfromCmp(getCmpBalanceInternal());  // taking out all we have
        }else{
            uint cashOnBook = getCashExReserves();
            if(amtUSDC > cashOnBook){   // we still have cash in wallet, may not need to go to compound
                uint amtUSDCmissing = amtUSDC - cashOnBook;
                // need to go to compound to get the USDC
                uint compoundBalance = getCmpBalanceInternal();
                if(compoundBalance > (amtUSDCmissing + extraUSDC)){
                    withdrawUSDCfromCmp(amtUSDCmissing + extraUSDC);
                }else{
                    withdrawUSDCfromCmp(compoundBalance);  // taking out all we have, but may not be enough still!
                }
            }
        }
        // levToken goes to curve to sell its USDC to USDT pushing USDT to depositor directly
        uint latestCashOnBook = getCashExReserves();
        uint finalRepayAmount;
        if(latestCashOnBook >= amtUSDC){ // normal case
            finalRepayAmount = changeUSDC2USDT(amtUSDC, 0, address(depErc20));
//            console.log("changed %d usdc into %d usdt",amtUSDC,finalRepayAmount);
            uint transFx = amtUSDC * expScale / finalRepayAmount;
            // we accrueInterest & update the ledgers in depErc20 after the transfer!
            depErc20.repayBorrow(finalRepayAmount, false);
            updateBorrowBalances(transFx, depErc20.getTotalBorrows());  // only 1 borrower, no need to parse in address
        }else{
            finalRepayAmount = changeUSDC2USDT(latestCashOnBook, 0, address(depErc20)); // best efforts
//            console.log("(insufficient) changed %d usdc into %d usdt",latestCashOnBook,finalRepayAmount);
            uint transFx = latestCashOnBook * expScale / finalRepayAmount;
            if(isRedeemAll){
//                console.log("liquidation during deleverage, nav -> 0");
                uint depTotalBorrows = depErc20.getTotalBorrows();
                if(depTotalBorrows > finalRepayAmount){ // insufficient, record how much owed
                    updateBorrowBalances(transFx, depTotalBorrows - finalRepayAmount);
                }else{
                    updateBorrowBalances(transFx, 0); // repaid too much, deptoken will push back extra, and zero its totalBorrows
                }
                depErc20.repayBorrow(finalRepayAmount, true);
                return true;    // liquidation triggered
            }else{
                // we accrueInterest & update the ledgers in depErc20 after the transfer!
                depErc20.repayBorrow(finalRepayAmount, false);
                updateBorrowBalances(transFx, depErc20.getTotalBorrows());  // only 1 borrower, no need to parse in address
            }
        }
        return false;
    }

    function deleverageAll() internal returns (bool) {
//        console.log("deleverageAll triggered!");
        uint cashOnBook = getCashExReserves();
        // need to go to compound to get the USDC
        uint compoundBalance = getCmpBalanceInternal();
//        console.log("cashOnBook,compoundBalance=%d,%d", cashOnBook, compoundBalance);
        if(compoundBalance > 0) {
            withdrawUSDCfromCmp(compoundBalance);  // taking out all we have
        }
        cashOnBook = getCashExReserves();   // query again, since withdrawal from cmp costs gas. this now includes true amt withdrawn from cmp
        // levToken goes to curve to sell all its USDC to USDT pushing USDT to depositor directly
        if(cashOnBook > 0){
            uint finalRepayAmount = changeUSDC2USDT(cashOnBook, 0, address(depErc20));
//            console.log("changed %d usdc into %d usdt",cashOnBook,finalRepayAmount);
            uint transFx = cashOnBook * expScale / finalRepayAmount;
            // we accrueInterest & update the ledgers in depErc20 after the transfer!
            uint origBorrowBalanceUSDT = depErc20.getTotalBorrowsAfterAccrueInterest();    // hasnt taken into account the repayment above yet
            extraBorrowDemand = 0;
            extraBorrowSupply = 0;
//            console.log("finalRepayAmount,origBorrowBalanceUSDT=%d,%d", finalRepayAmount, origBorrowBalanceUSDT);
            if(origBorrowBalanceUSDT > finalRepayAmount){
                updateBorrowBalances(transFx, origBorrowBalanceUSDT - finalRepayAmount);  // record in borrowBalanceUSDT the bad debt
                depErc20.repayBorrow(finalRepayAmount, true);
                updateStats(false, 0, 0, 0);
                tensorpricer._setMintPausedLev(address(this), true);
                tensorpricer._setRedeemPausedLev(address(this), true);
            }else{  // enough to pay
                updateBorrowBalances(transFx, 0);
                depErc20.repayBorrow(finalRepayAmount, false);
                updateStats(true, 0, 0, 0);
                return false;
            }
        }
        return true;
    }

    function checkRebalanceExt() external view returns (checkRebalanceRes memory) {
        return checkRebalance(2, 0);
    }

    function checkRebalance(uint callingSrc, uint tmpRedeemAmountInUSDC) internal view returns (checkRebalanceRes memory) {
        uint fx_USDTUSDC_Mantissa = tensorpricer.getFx('USDTUSDC');
        (uint targetLevRatio, uint releverageTrigger, uint deleverageTrigger) = refreshTargetLevRatio(fx_USDTUSDC_Mantissa);
        Exp memory fx_USDTUSDC = Exp({mantissa: fx_USDTUSDC_Mantissa});
        
        //uint fxmantissa = fx_USDTUSDC.mantissa;
        //console.log("fx,",fxmantissa);
        //console.log("checkrebalance,%d,%d,%d",targetLevRatio,releverageTrigger,deleverageTrigger);
        if(callingSrc==0){   // mint. new USDC already in
            uint tmpBorrowBalanceUSDC = mul_(borrowBalanceUSDT, fx_USDTUSDC);
            uint tmpBalanceUSDC = getCashExReserves() + getCmpBalanceInternal();
            if(tmpBalanceUSDC > tmpBorrowBalanceUSDC){
                uint tmpTotalAssetValue = tmpBalanceUSDC - tmpBorrowBalanceUSDC;
                uint tmpLevRatio = tmpBorrowBalanceUSDC*expScale / tmpTotalAssetValue;
                
                if(tmpLevRatio < releverageTrigger){    // need to leverage up
                    return checkRebalanceRes({res:1, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:tmpTotalAssetValue, tmpLevRatio:tmpLevRatio});
                }else if(tmpLevRatio > deleverageTrigger){
                    return checkRebalanceRes({res:2, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:tmpTotalAssetValue, tmpLevRatio:tmpLevRatio});
                }else{  //no changes
                    return checkRebalanceRes({res:0, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:tmpTotalAssetValue, tmpLevRatio:tmpLevRatio});
                }
            }else{
                return checkRebalanceRes({res:3, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:0, tmpLevRatio:0});
            }
        }else if (callingSrc==1){  // redeem. USDC NOT transferred out yet
            if(totalSupply > 0){
                //console.log("getCashExReserves=",getCashExReserves());
                //console.log("getCmpBalanceInternal=",getCmpBalanceInternal());
                //console.log("tmpRedeemAmountInUSDC=",tmpRedeemAmountInUSDC);
                uint tmpBalanceUSDC = getCashExReserves() + getCmpBalanceInternal() - tmpRedeemAmountInUSDC;
                //console.log("tmpBalanceUSDC=",tmpBalanceUSDC);

                //console.log("borrowBalanceUSDT=",borrowBalanceUSDT);
                //console.log("fx_USDTUSDC=",fx_USDTUSDC_Mantissa);
                uint tmpBorrowBalanceUSDC = mul_(borrowBalanceUSDT, fx_USDTUSDC);
                //console.log("tmpBorrowBalanceUSDC=",tmpBorrowBalanceUSDC);
                
                if(tmpBalanceUSDC > tmpBorrowBalanceUSDC){
                    uint tmpTotalAssetValue = tmpBalanceUSDC - tmpBorrowBalanceUSDC;
                    uint tmpLevRatio = tmpBorrowBalanceUSDC*expScale / tmpTotalAssetValue;
//                    console.log("tmpBalanceUSDC,tmpBorrowBalanceUSDC=%d,%d",tmpBalanceUSDC,tmpBorrowBalanceUSDC);
                    if(tmpLevRatio > deleverageTrigger){ // need to work out a new nav
                        return checkRebalanceRes({res:2, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:tmpTotalAssetValue, tmpLevRatio:tmpLevRatio});
                    }else if(tmpLevRatio < releverageTrigger){
                        return checkRebalanceRes({res:1, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:tmpTotalAssetValue, tmpLevRatio:tmpLevRatio});
                    }else{  // no changes, only redeemAmount*nav USDC will be transferred out
                        return checkRebalanceRes({res:0, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:tmpTotalAssetValue, tmpLevRatio:tmpLevRatio});
                    }
                }else{
                    return checkRebalanceRes({res:3, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:0, tmpLevRatio:0});
                }
            }else{
                return checkRebalanceRes({res:0, targetLevRatio:0, tmpBorrowBalanceUSDC:0, tmpTotalAssetValue:0, tmpLevRatio:0});
            }
        }else{  // regular check due to fx
            if(totalSupply > 0){
                uint tmpBorrowBalanceUSDC = mul_(borrowBalanceUSDT, fx_USDTUSDC);
                uint tmpBalanceUSDC = getCashExReserves() + getCmpBalanceInternal();
                if(tmpBalanceUSDC > tmpBorrowBalanceUSDC){
                    uint tmpTotalAssetValue = tmpBalanceUSDC - tmpBorrowBalanceUSDC;
                    uint tmpLevRatio = tmpBorrowBalanceUSDC*expScale / tmpTotalAssetValue;

                    if(tmpLevRatio < releverageTrigger){    // need to leverage up
                        return checkRebalanceRes({res:1, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:tmpTotalAssetValue, tmpLevRatio:tmpLevRatio});
                    }else if(tmpLevRatio > deleverageTrigger){ // need to work out a new nav
                        return checkRebalanceRes({res:2, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:tmpTotalAssetValue, tmpLevRatio:tmpLevRatio});
                    }else{
                        return checkRebalanceRes({res:0, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:tmpTotalAssetValue, tmpLevRatio:tmpLevRatio});
                    }
                }else{
                    return checkRebalanceRes({res:3, targetLevRatio:targetLevRatio, tmpBorrowBalanceUSDC:tmpBorrowBalanceUSDC, tmpTotalAssetValue:0, tmpLevRatio:0});
                }
            }else{
                return checkRebalanceRes({res:0, targetLevRatio:0, tmpBorrowBalanceUSDC:0, tmpTotalAssetValue:0, tmpLevRatio:0});
            }
        }
    }

    function doRebalanceExt() public {//nonReentrant {
        checkRebalanceRes memory myRes = checkRebalance(2, 0);
        doRebalance(2, myRes, 0);
    }

    function doRebalance(uint callingSrc, checkRebalanceRes memory myRes, uint redeemTokensIn) internal {//nonReentrant {
        uint fx_USDTUSDC_Mantissa = tensorpricer.getFx('USDTUSDC');
        Exp memory fx_USDTUSDC = Exp({mantissa: fx_USDTUSDC_Mantissa});
        targetLevRatio = myRes.targetLevRatio;  // if we go to do reBalance, update it, else needs to pay gas
        if(myRes.res == 3){ // need to clear all positions
            if(deleverageAll()){
                netAssetValue = 0;
            }else{
                updateNetAssetValue(borrowBalanceUSDC, 0);
            }
        }else{
            if(callingSrc==0){   // mint. new USDC already in
                if(myRes.res==1){    // need to leverage up
                    updateExtraBorrow(fx_USDTUSDC, myRes.tmpTotalAssetValue, myRes.targetLevRatio);
                    // releverage
                    if(extraBorrowDemand > 0) {
                        releverage(extraBorrowDemand);
                    }else{
                        borrowBalanceUSDC = myRes.tmpBorrowBalanceUSDC;
                    }
                    updateStats(true, 0, 0, 0);
                }else if(myRes.res==2){
                    updateExtraBorrow(fx_USDTUSDC, myRes.tmpTotalAssetValue, myRes.targetLevRatio);
                    // deleverage
                    if(extraBorrowSupply > 0){
                        deleverage(fx_USDTUSDC, extraBorrowSupply, false);
                    }else{
                        borrowBalanceUSDC = myRes.tmpBorrowBalanceUSDC;
                    }
                    updateStats(true, 0, 0, 0);
                }else if(myRes.res==0){  //no changes. do NOT expect deleverage here
                    borrowBalanceUSDC = myRes.tmpBorrowBalanceUSDC;
                    updateStats(false, myRes.tmpTotalAssetValue, myRes.tmpLevRatio, 0);
                    extraBorrowDemand = 0;
                    extraBorrowSupply = 0;
                }
            }else if (callingSrc==1){  // redeem. USDC NOT transferred out yet
                if(myRes.res==2){ // need to work out a new nav
                    updateExtraBorrow(fx_USDTUSDC, myRes.tmpTotalAssetValue, myRes.targetLevRatio);
                    // deleverage
                    if(extraBorrowSupply > 0){
                        deleverage(fx_USDTUSDC, extraBorrowSupply, false);
                    }else{
                        borrowBalanceUSDC = myRes.tmpBorrowBalanceUSDC;
                    }
                    updateStats(true, 0, 0, redeemTokensIn);
                }else if(myRes.res==1){
                    updateExtraBorrow(fx_USDTUSDC, myRes.tmpTotalAssetValue, myRes.targetLevRatio);
                    // releverage
                    if(extraBorrowDemand > 0) {
                        releverage(extraBorrowDemand);
                    }else{
                        borrowBalanceUSDC = myRes.tmpBorrowBalanceUSDC;
                    }
                    updateStats(true, 0, 0, redeemTokensIn);
                }else if(myRes.res==0){  // no changes, only redeemAmount*nav USDC will be transferred out
                    borrowBalanceUSDC = myRes.tmpBorrowBalanceUSDC;
                    updateStats(false, myRes.tmpTotalAssetValue, myRes.tmpLevRatio, redeemTokensIn);
                    extraBorrowDemand = 0;
                    extraBorrowSupply = 0;
                }
            }else{  // this is for Keeper. dont come to this function at all if res==0
                if(myRes.res==1){    // need to leverage up
                    updateExtraBorrow(fx_USDTUSDC, myRes.tmpTotalAssetValue, myRes.targetLevRatio);
                    // releverage
                    if(extraBorrowDemand > 0) {
                        releverage(extraBorrowDemand);
                    }else{
                        borrowBalanceUSDC = myRes.tmpBorrowBalanceUSDC;
                    }
                    // only need to do supplyUSDC for callingSrc 2, but not callingSrc 0, 
                    // because callingSrc 0 calls it separately
                    uint currUSDCBalance = getCashExReserves();
                    if(checkCompound(currUSDCBalance)){
                        supplyUSDC(currUSDCBalance - thresholdUSDC);
                    }
                    updateStats(true, 0, 0, 0);
                    updateNetAssetValue(borrowBalanceUSDC, 0);  // again only for callingSrc!=0, coz callingSrc 0 calls it after totalSupply update
                }else if(myRes.res==2){ // need to work out a new nav
                    updateExtraBorrow(fx_USDTUSDC, myRes.tmpTotalAssetValue, myRes.targetLevRatio);
                    // deleverage
                    if(extraBorrowSupply > 0){
                        deleverage(fx_USDTUSDC, extraBorrowSupply, false);
                    }else{
                        borrowBalanceUSDC = myRes.tmpBorrowBalanceUSDC;
                    }
                    updateStats(true, 0, 0, 0);
                    updateNetAssetValue(borrowBalanceUSDC, 0);
                }
            }
        }
    }

    function redeemAllRebalance() internal returns (uint){
        uint fx_USDTUSDC_Mantissa = tensorpricer.getFx('USDTUSDC');
        Exp memory fx_USDTUSDC = Exp({mantissa: fx_USDTUSDC_Mantissa});
        extraBorrowDemand = 0;
        extraBorrowSupply = borrowBalanceUSDT;
        bool isLiquidate = deleverage(fx_USDTUSDC, extraBorrowSupply, true);    // this takes out everything we have in cmp
        if(isLiquidate){
            updateStats(false, 0, 0, 0);
            netAssetValue = 0;
            tensorpricer._setMintPausedLev(address(this), true);
            tensorpricer._setRedeemPausedLev(address(this), true);
//            console.log("redeemAllRebalance liquidate triggered");
            return 0;
        }else{
            uint currUSDCBalance = getCashExReserves(); // all available cash on the book now
            uint redeemFeeBeforeLevRatio = (redeemFeePC * currUSDCBalance) / expScale;
            uint redeemFee = (targetLevRatio * redeemFeeBeforeLevRatio) / expScale;
            
//            console.log("redeemFee =",redeemFee);
            if(currUSDCBalance <= redeemFee){
                redeemFee = currUSDCBalance;
//                console.log("currUSDCBalance not enough. redeemFee reduced to =",redeemFee);
                currUSDCBalance = 0;
            }else{
                currUSDCBalance = currUSDCBalance - redeemFee;
            }

            levReserve = levReserve + redeemFee;
            updateStats(false, 0, 0, 0);
            netAssetValue = initialNetAssetValueMantissa;

            return currUSDCBalance;
        }
    }

    /**
     * @notice check if sufficient USDC to push to compound
     * @dev
     * @return if true, then transfer
     */
    function checkCompound(uint currUSDCBalance) internal pure returns (bool) {
        if(currUSDCBalance > minTransferAmtUSDC+thresholdUSDC){
            return true;
        }else{
            return false;
        }
    }

    function checkLeveragibility(Exp memory fx_USDTUSDC, uint mintAmount) internal view returns (bool) {
        uint tmpBorrowBalanceUSDC = mul_(borrowBalanceUSDT, fx_USDTUSDC);
        uint availCash = getCashExReserves() + getCmpBalanceInternal();
        uint tmpLevRatio = 0;
//        console.log("tmpBorrowBalanceUSDC",tmpBorrowBalanceUSDC);
//        console.log("availCash",availCash);
        if(availCash > tmpBorrowBalanceUSDC){   // minting may still be possible, depending on unborrowedCashAtDep > loanNeeded
            uint tmpTotalAssetValue = availCash - tmpBorrowBalanceUSDC;
            tmpLevRatio = tmpBorrowBalanceUSDC*expScale / tmpTotalAssetValue;
//            console.log("tmpLevRatio",tmpLevRatio);
        }else{  // both availCash & tmpBorrowBalanceUSDC are zero
            (uint initLevRatio,,) = refreshTargetLevRatio(fx_USDTUSDC.mantissa);
            tmpLevRatio = initLevRatio;
        }
        uint loanNeeded = tmpLevRatio * div_(mintAmount, fx_USDTUSDC) / expScale;
        uint unborrowedCashAtDep = depErc20.getUnborrowedUSDTBalance();
        
//        console.log("loanNeeded",loanNeeded);
//        console.log("unborrowedCashAtDep",unborrowedCashAtDep);
        return unborrowedCashAtDep > loanNeeded;
    }

    function payback(address minter, uint _totalAssetValue) internal {
        if(_totalAssetValue > 0){
            // this is another undesirable scenario. dont issue new tokens, return as much to minter as possible. stop further mint/redeem
            uint compoundBalance = getCmpBalanceInternal();
            if(compoundBalance > 0){
                withdrawUSDCfromCmp(compoundBalance);  // taking out all we have
            }
            doTransferOut(payable(minter), _totalAssetValue);
//            console.log("return as much as possible,",_totalAssetValue);
            emit Transfer(minter, address(this), 0);
        }
        updateStats(false, 0, 0, 0);
        extraBorrowDemand = 0;
        extraBorrowSupply = 0;
        netAssetValue = 0;
        tensorpricer._setMintPausedLev(address(this), true);
        tensorpricer._setRedeemPausedLev(address(this), true);
    }

    /**
     * @notice User supplies USDC into the market and receives levErc20s in exchange
     * @param mintAmount The amount of USDC to supply
     */
    function mintInternal(uint mintAmount) internal nonReentrant {
        address minter = msg.sender;   //The address of the account which is supplying USDC
        /* Fail if mint not allowed */
        uint allowed = tensorpricer.mintAllowed(address(this), minter);
        if (allowed != 0) {
            revert MintTensorpricerRejection(allowed);
        }

        uint fx_USDTUSDC_Mantissa = tensorpricer.getFx('USDTUSDC');
        Exp memory fx_USDTUSDC = Exp({mantissa: fx_USDTUSDC_Mantissa});
//        console.log("mint fx=",fx_USDTUSDC_Mantissa);

        //require(checkLeveragibility(fx_USDTUSDC, mintAmount), "not enough deposit to create");
        if(!checkLeveragibility(fx_USDTUSDC, mintAmount)){
//            console.log("not enough deposit to create");
            return;
        }
        // require(checkLeveragibility(fx_USDTUSDC, mintAmount), "not enough deposit to create");
        // start executing transfers according to the completed calculations

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  Note: The levErc20 can only handle USDC!
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if side-effects occurred. 
         *  The function returns the amount actually transferred, in case of a fee. 
         *  On success, the levErc20 holds an additional `actualMintAmount` of cash.
         *  getCash() will reflect this transfer
         */
        uint actualMintAmount = doTransferIn(minter, mintAmount);

        uint mintTokens;
        uint navAfterTradeMantissa;
        // update a tmp new nav
        Exp memory tmpNav;
        uint tmpBorrowBalanceUSDC = mul_(borrowBalanceUSDT, fx_USDTUSDC);
        uint tmpNavMantissa = calcNetAssetValue(tmpBorrowBalanceUSDC, actualMintAmount);
        bool skipRebalance = false;
        if(tmpNavMantissa == 0){
            if(deleverageAll()){
                return;
            }
            skipRebalance = true;
        }
        
        tmpNav = Exp({mantissa: takePerfFee(tmpNavMantissa)});

        /*
        *  calculate the number of levErc20s to be minted:
        *  mintTokens = actualMintAmount / netassetvalue
        */
        
        checkRebalanceRes memory myRes;
        if(!skipRebalance){
            myRes = checkRebalance(0, 0);
//            console.log("checkRebalance res:",myRes.res);
//            console.log("checkRebalance targetLevRatio:",myRes.targetLevRatio);
            doRebalance(0, myRes, 0);    // rebalance will have been done if needed
        }
        
        if(!skipRebalance && myRes.res==0){   // no rebalances
            mintTokens = div_(actualMintAmount, tmpNav);
        }else{  // use rebalance fx
            // totalassetvalue already updated by now
            uint _totalSupply = totalSupply;
            if(_totalSupply == 0){
                navAfterTradeMantissa = initialNetAssetValueMantissa;
                mintTokens = div_(actualMintAmount, Exp({mantissa: navAfterTradeMantissa}));
            }else{
                uint _totalAssetValue = totalAssetValue;
                if(_totalAssetValue > actualMintAmount){
                    navAfterTradeMantissa = (_totalAssetValue - actualMintAmount) * expScale / _totalSupply;
                    mintTokens = div_(actualMintAmount, Exp({mantissa: navAfterTradeMantissa}));
                }else{
                    payback(minter, _totalAssetValue);
                    return;
                }
            }
        }

        uint currUSDCBalance = getCashExReserves();
        if(checkCompound(currUSDCBalance)){
            supplyUSDC(currUSDCBalance - thresholdUSDC);
        }
        
        /*
         * We calculate the new total supply of levErc20s and minter token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[minter] + mintTokens
         * And write them into storage
         */
        totalSupply = totalSupply + mintTokens;
        accountTokens[minter] = accountTokens[minter] + mintTokens;
        // once totalSupply updated, we update nav
        updateNetAssetValue(borrowBalanceUSDC, 0);
        /* We emit a Mint event, and a Transfer event */
        emit Mint(minter, actualMintAmount, mintTokens, netAssetValue);
        emit Transfer(address(this), minter, mintTokens);
    }

    /**
     * @notice Sender redeems levErc20s in exchange for the underlying asset
     * @dev
     * @param redeemTokens The number of levErc20s to redeem into underlying
     */
    function redeemInternal(uint redeemTokensIn) internal nonReentrant {
        address payable redeemer = payable(msg.sender);

        /* Fail if redeem not allowed */
        uint allowed = tensorpricer.redeemAllowed(address(this), redeemer, redeemTokensIn);
        if (allowed != 0) {
            revert RedeemTensorpricerRejection(allowed);
        }

        uint fx_USDTUSDC_Mantissa = tensorpricer.getFx('USDTUSDC');
        //console.log("redeem fx=",fx_USDTUSDC_Mantissa);

        // work out a tmpNetAssetValue here
        uint tmpBorrowBalanceUSDC = mul_(borrowBalanceUSDT, Exp({mantissa: fx_USDTUSDC_Mantissa}));
        //console.log("tmpBorrowBalanceUSDC=%d",tmpBorrowBalanceUSDC);
        uint tmpNetAssetValue = calcNetAssetValue(tmpBorrowBalanceUSDC, 0);
        (uint targetLevRatio,,) = refreshTargetLevRatio(fx_USDTUSDC_Mantissa);

        /*
        *  We calculate the nav and the amount of underlying to be redeemed:
        *  redeemTokens = redeemTokensIn
        *  redeemAmount = redeemTokensIn x nav
        */
        
        uint updatedTmpNavMantissa = takePerfFee(tmpNetAssetValue);  // take fees first before calculating the latest redeemable nav
        uint tmpRedeemAmount = mul_ScalarTruncate(Exp({mantissa: updatedTmpNavMantissa}), redeemTokensIn);

        uint trueRedeemAmount;
        if(totalSupply == redeemTokensIn){  // redeem all, special logic
            trueRedeemAmount = redeemAllRebalance();
            totalSupply = 0;
        }else{
            redeemAmountInUSDC = 0; // let do rebalance update it
            if(tmpNetAssetValue > 0){
                doRebalance(1, checkRebalance(1, tmpRedeemAmount), redeemTokensIn);    // rebalance will have been done if needed
            }else{
                if(deleverageAll()){
                    emit Redeem(redeemer, 0, redeemTokensIn, netAssetValue);
                    return;
                }
            }
        
            // then we use the new latest (but not final) nav (updated in doRebalance) to work out how much to pay client
            // we dont subtract redeemAmount, nor reduce totalSupply when computing this new latest nav
            uint redeemFeeBeforeLevRatio = (redeemFeePC * redeemAmountInUSDC) / expScale;
            uint redeemFee = (targetLevRatio * redeemFeeBeforeLevRatio) / expScale;
            
//            console.log("redeemFee =",redeemFee);

            trueRedeemAmount = redeemAmountInUSDC - redeemFee;
            levReserve = levReserve + redeemFee;

            uint currUSDCBalance = getCashExReserves();
            if (redeemAmountInUSDC > currUSDCBalance) { // need to get some funds from Compound
                uint amtNeeded = redeemAmountInUSDC - currUSDCBalance;
                uint compoundBalance = getCmpBalanceInternal();
                if(compoundBalance > (amtNeeded + extraUSDC)){
                    withdrawUSDCfromCmp(amtNeeded + extraUSDC);
                }else{
                    withdrawUSDCfromCmp(compoundBalance);  // taking out all we have
                }
            }
            totalSupply = totalSupply - redeemTokensIn;
            updateNetAssetValue(borrowBalanceUSDC, trueRedeemAmount); // transferOut NOT done yet!
        }
        /*
        * We write the previously calculated values into storage.
        *  Note: Avoid token reentrancy attacks by writing reduced supply before external transfer.
        */
        accountTokens[redeemer] = accountTokens[redeemer] - redeemTokensIn;
        /*
        * We invoke doTransferOut for the redeemer and the redeemAmount.
        *  On success, the depErc20 has redeemAmount less of cash.
        *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
        */
        if(trueRedeemAmount > 0){
            doTransferOut(redeemer, trueRedeemAmount);
            /* We emit a Transfer event, and a Redeem event */
            emit Transfer(redeemer, address(this), redeemTokensIn);
            emit Redeem(redeemer, trueRedeemAmount, redeemTokensIn, netAssetValue);
        }else{
            emit Redeem(redeemer, 0, redeemTokensIn, netAssetValue);
        }
    }

    /**
     * @notice depErc20 user forces levToken to repay. User sells USDC to get USDT
     * @param repayAmountInUSDT The amt of USDT needed
     * @return net proceeds. it goes directly to the depToken
     */
    function forceRepayInternal(uint repayAmountInUSDT) internal nonReentrant returns (uint) {
        // need to determine how much USDC is needed. do as the oracle says
        Exp memory fx_USDTUSDC = Exp({mantissa: tensorpricer.getFx('USDTUSDC')});
        uint amtUSDC = mul_(repayAmountInUSDT, fx_USDTUSDC);
        amtUSDC = (amtUSDC * 105) / 100;    // we add 5% as buffer
        uint availCash = getCashExReserves();
        if(amtUSDC > availCash){
            uint amtUSDCmissing = amtUSDC - availCash; // we still have cash in wallet
            // need to go to compound to get the USDC
            uint compoundBalance = getCmpBalanceInternal();
            if(compoundBalance > (amtUSDCmissing + extraUSDC)){
                withdrawUSDCfromCmp(amtUSDCmissing + extraUSDC);
            }else{
                withdrawUSDCfromCmp(compoundBalance);  // taking out all we have
            }
        }
        uint netForceRepayAmount = changeUSDC2USDT(amtUSDC, 0, address(depErc20));
//        console.log("changed %d usdc into %d usdt",amtUSDC,netForceRepayAmount);
        return netForceRepayAmount;
    }

    function updateLedgerInternal() internal {
        updateBorrowBalances(tensorpricer.getFx('USDTUSDC'), depErc20.getTotalBorrows());   // no need to use transFx even tho traded, becoz no lev mint/redeem
        updateStats(true, 0, 0, 0);
        updateNetAssetValue(borrowBalanceUSDC, 0);
    }

    /**
     * @notice push a portion of profit to reserves 
     */
    function takePerfFee(uint navMantissa) internal returns (uint) {
        uint perfFee = 0;
        if(navMantissa > hisHighNav && totalSupply > 0){
//            console.log("netnav,hishighnav = %d,%d",navMantissa,hisHighNav);
            uint gain = (navMantissa-hisHighNav) * totalSupply / expScale;    // gain same unit as totalSupply, 1e6
            hisHighNav = navMantissa;
            perfFee = gain * perfPC / expScale;
            uint tmpTotalAssetValue = navMantissa * totalSupply / expScale;
            console.log("tmpTotalAssetValue,perffee,gain = %d,%d,%d",tmpTotalAssetValue,perfFee,gain);
            // by definition, tmpTotalAssetValue >= perfFee
            levReserve = levReserve + perfFee;
            uint updatedNavMantissa = (tmpTotalAssetValue - perfFee)*expScale / totalSupply;  // no need to minus redeemFee here. it's taken away in the final transfer out amt
            console.log("updatedNavMantissa = ",updatedNavMantissa);
            return updatedNavMantissa;  // only used in minting to determine how many new deptokens to issue
        }else{
            return navMantissa;
        }
    }

    /*** Admin Functions ***/

    /**
      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.
      * @param newPendingAdmin New pending admin.
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setPendingAdmin(address payable newPendingAdmin) override external returns (uint) {
        // Check caller = admin
        if (msg.sender != admin) {
            revert SetPendingAdminOwnerCheck();
        }

        // Save current value, if any, for inclusion in log
        address oldPendingAdmin = pendingAdmin;

        // Store pendingAdmin with value newPendingAdmin
        pendingAdmin = newPendingAdmin;

        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)
        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);

        return NO_ERROR;
    }

    /**
      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin
      * @dev Admin function for pending admin to accept role and update admin
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _acceptAdmin() override external returns (uint) {
        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)
        if (msg.sender != pendingAdmin || msg.sender == address(0)) {
            revert AcceptAdminPendingAdminCheck();
        }

        // Save current values for inclusion in log
        address oldAdmin = admin;
        address oldPendingAdmin = pendingAdmin;

        // Store admin with value pendingAdmin
        admin = pendingAdmin;

        // Clear the pending value
        pendingAdmin = payable(address(0));

        emit NewAdmin(oldAdmin, admin);
        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);

        return NO_ERROR;
    }

    /**
     * @notice Accrues interest and reduces reserves by transferring to admin
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReserves(uint reduceAmount) override external nonReentrant returns (uint) {
        // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.
        return _reduceReservesFresh(reduceAmount);
    }

    /**
     * @notice Reduces reserves by transferring to admin
     * @dev Requires fresh interest accrual
     * @param reduceAmount Amount of reduction to reserves
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {
        // totalReserves - reduceAmount
        uint levReserveNew;

        // Check caller is admin
        if (msg.sender != admin) {
            revert ReduceReservesAdminCheck();
        }

        // Fail gracefully if protocol has insufficient underlying cash
        if (getCashPrior() < reduceAmount) {
            revert ReduceReservesCashNotAvailable();
        }

        // Check reduceAmount ≤ reserves[n] (totalReserves)
        if (reduceAmount > levReserve) {
            revert ReduceReservesCashValidation();
        }

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        levReserveNew = levReserve - reduceAmount;

        // Store reserves[n+1] = reserves[n] - reduceAmount
        levReserve = levReserveNew;

        // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.
        doTransferOut(admin, reduceAmount);

        emit ReservesReduced(admin, reduceAmount, levReserveNew);

        return NO_ERROR;
    }

    /**
      * @notice Sets a new tensorpricer for the market
      * @dev Admin function to set a new tensorpricer
      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
      */
    function _setTensorpricer(TensorpricerInterface newTensorpricer) override public returns (uint) {
        // Check caller is admin
        if (msg.sender != admin) {
            revert SetTensorpricerOwnerCheck();
        }

        TensorpricerInterface oldTensorpricer = tensorpricer;
        // Ensure invoke tensorpricer.isTensorpricer() returns true
        require(newTensorpricer.isTensorpricer(), "marker method returned false");

        // Set market's tensorpricer to newTensorpricer
        tensorpricer = newTensorpricer;

        // Emit NewTensorpricer(oldTensorpricer, newTensorpricer)
        emit NewTensorpricer(oldTensorpricer, newTensorpricer);

        return NO_ERROR;
    }

    function getCashExReserves() internal view returns (uint) {
        uint allCash = getCashPrior();
        if(allCash > levReserve){
            return allCash - levReserve;
        }else{
            return 0;
        }
    }
    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying owned by this contract
     */
    function getCashPrior() virtual internal view returns (uint);

    /**
     * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.
     *  This may revert due to insufficient balance or insufficient allowance.
     */
    function doTransferIn(address from, uint amount) virtual internal returns (uint);

    /**
     * @dev Performs a transfer out, ideally returning an explanatory error code upon failure rather than reverting.
     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.
     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.
     */
    function doTransferOut(address payable to, uint amount) virtual internal;

    /*** Reentrancy Guard ***/

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     */
    modifier nonReentrant() {
        require(_notEntered, "re-entered");
        _notEntered = false;
        _;
        _notEntered = true; // get a gas-refund post-Istanbul
    }
}

/**
 * @title LevErc20 Contract
 * @notice LevTokens which wrap an EIP-20 underlying
 * @author Vortex
 */
contract LevErc20 is LevToken, LevErc20Interface {

    string public prologue;

    /**
     * @notice set depErc20 
     * @param depErc20_ The address of the associated depErc20
     */
    function setDepErc20(DepErc20Interface depErc20_) public override{
        super.setDepErc20(depErc20_);
    }

    /**
     * @notice Initialize the new money market
     * @param underlying_ The address of the underlying asset
     * @param borrowUnderlying_ The address of the borrow underlying asset
     * @param tensorpricer_ The address of the Tensorpricer
     * @param name_ ERC-20 name of this token
     * @param symbol_ ERC-20 symbol of this token
     * @param decimals_ ERC-20 decimal precision of this token
     */
    function initialize(address underlying_,
                        address borrowUnderlying_,
                        TensorpricerInterface tensorpricer_,
                        string memory name_,
                        string memory symbol_,
                        uint8 decimals_) public override initializer {
        // LevToken initialize does the bulk of the work
        admin = payable(msg.sender);
        super.initialize(underlying_, borrowUnderlying_, tensorpricer_, name_, symbol_, decimals_);

        // Set underlying and sanity check it
        underlying = underlying_;
        EIP20Interface(underlying).totalSupply();

        // Set borrow underlying and sanity check it
        borrowUnderlying = borrowUnderlying_;
        EIP20Interface(borrowUnderlying).totalSupply();

        netAssetValue = initialNetAssetValueMantissa;
        hisHighNav = initialNetAssetValueMantissa;
        targetLevRatio = initialTargetLevRatio;
    }

    function setPrologue() public {
        require(msg.sender == admin, "only admin may set prologue");
        prologue = 'leverc20 success';
    }

    /*** User Interface ***/

    function getAdmin() override external view returns (address payable) {
        return admin;
    }

    /*
     * @notice Sender supplies assets into the market and receives depErc20s in exchange
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param mintAmount The amount of the underlying asset to supply
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function mint(uint mintAmount) override external returns (uint) {
        require(mintAmount > 0, "cannot mint <= 0");
        mintInternal(mintAmount);
        return NO_ERROR;
    }

    /*
     * @notice Sender redeems levErc20s in exchange for the underlying asset
     * @dev Accrues interest whether or not the operation succeeds, unless reverted
     * @param redeemTokens The number of levErc20s to redeem into USDC
     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)
     */
    function redeem(uint redeemTokens) override external returns (uint) {
        redeemInternal(redeemTokens);
        return NO_ERROR;
    }

    /**
     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)
     * @param token The address of the ERC-20 token to sweep
     */
    function sweepToken(EIP20NonStandardInterface token) override external {
        require(msg.sender == admin, "DepErc20::sweepToken: only admin can sweep tokens");
        require(address(token) != underlying, "DepErc20::sweepToken: can not sweep underlying token");
        uint256 balance = token.balanceOf(address(this));
        token.transfer(admin, balance);
    }

    /**
     * @notice Get extra borrow demand of this levToken
     * @return The borrowDemand denominated in borrowUnderlying
     */
    function getExtraBorrowDemand() override external view returns (uint256){
        return extraBorrowDemand;
    }

    /**
     * @notice Get extra borrow supply of this levToken
     * @return The borrowSupply denominated in borrowUnderlying
     */
    function getExtraBorrowSupply() override external view returns (uint256){
        return extraBorrowSupply;
    }

    /**
     * @notice depErc20 user (not the contract itself) calls forceRepay
     * @param repayAmountInUSDT The amount of underlying to force repay
     * @return uint actual amount liquidated
     */
    function forceRepay(uint256 repayAmountInUSDT) override virtual external returns (uint) {
        require(msg.sender==address(depErc20), "only depToken can call forceRepay");
//        console.log("forcerepay triggered,repayAmountInUSDT=",repayAmountInUSDT);
        return forceRepayInternal(repayAmountInUSDT);
    }

    function updateLedger() override virtual external {
        require(msg.sender==address(depErc20), "only depToken can call updateLedger");
        return updateLedgerInternal();
    }

    /*** Safe Token ***/

    /**
     * @notice Gets balance of this contract in terms of the underlying
     * @dev This excludes the value of the current message, if any
     * @return The quantity of underlying tokens owned by this contract
     */
    function getCashPrior() virtual override internal view returns (uint) {
        EIP20Interface token = EIP20Interface(underlying);
//        console.log("leverc20 cash prior=", token.balanceOf(address(this)));
        return token.balanceOf(address(this));
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
     *      This will revert due to insufficient balance or insufficient allowance.
     *      This function returns the actual amount received,
     *      which may be less than `amount` if there is a fee attached to the transfer.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferIn(address from, uint amount) virtual override internal returns (uint) {
        // Read from storage once
        address underlying_ = underlying;
        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying_);
        uint balanceBefore = EIP20Interface(underlying_).balanceOf(address(this));
        token.transferFrom(from, address(this), amount);

        bool success;
        assembly {
            switch returndatasize()
                case 0 {                       // This is a non-standard ERC-20
                    success := not(0)          // set success to true
                }
                case 32 {                      // This is a compliant ERC-20
                    returndatacopy(0, 0, 32)
                    success := mload(0)        // Set `success = returndata` of override external call
                }
                default {                      // This is an excessively non-compliant ERC-20, revert.
                    revert(0, 0)
                }
        }
        require(success, "TOKEN_TRANSFER_IN_FAILED");

        // Calculate the amount that was *actually* transferred
        uint balanceAfter = EIP20Interface(underlying_).balanceOf(address(this));
        return balanceAfter - balanceBefore;   // underflow already checked above, just subtract
    }

    /**
     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
     *      it is >= amount, this should not revert in normal conditions.
     *
     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
     */
    function doTransferOut(address payable to, uint amount) virtual override internal {
        EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);
        token.transfer(to, amount);

        bool success;
        assembly {
            switch returndatasize()
                case 0 {                      // This is a non-standard ERC-20
                    success := not(0)          // set success to true
                }
                case 32 {                     // This is a compliant ERC-20
                    returndatacopy(0, 0, 32)
                    success := mload(0)        // Set `success = returndata` of override external call
                }
                default {                     // This is an excessively non-compliant ERC-20, revert.
                    revert(0, 0)
                }
        }
        require(success, "TOKEN_TRANSFER_OUT_FAILED");
    }
}
