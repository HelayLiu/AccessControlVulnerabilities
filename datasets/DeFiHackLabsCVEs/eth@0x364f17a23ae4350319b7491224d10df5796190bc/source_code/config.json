{
    "SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/LiquidXv2Zap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface ILiquidXv2Router01 {\\r\\n  function factory() external view returns (address);\\r\\n  function WETH() external view returns (address);\\r\\n\\r\\n  function addLiquidity(\\r\\n    address tokenA,\\r\\n    address tokenB,\\r\\n    uint amountADesired,\\r\\n    uint amountBDesired,\\r\\n    uint amountAMin,\\r\\n    uint amountBMin,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external returns (uint amountA, uint amountB, uint liquidity);\\r\\n  function addLiquidityETH(\\r\\n    address token,\\r\\n    uint amountTokenDesired,\\r\\n    uint amountTokenMin,\\r\\n    uint amountETHMin,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\r\\n  function removeLiquidity(\\r\\n    address tokenA,\\r\\n    address tokenB,\\r\\n    uint liquidity,\\r\\n    uint amountAMin,\\r\\n    uint amountBMin,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external returns (uint amountA, uint amountB);\\r\\n  function removeLiquidityETH(\\r\\n    address token,\\r\\n    uint liquidity,\\r\\n    uint amountTokenMin,\\r\\n    uint amountETHMin,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external returns (uint amountToken, uint amountETH);\\r\\n  function removeLiquidityWithPermit(\\r\\n    address tokenA,\\r\\n    address tokenB,\\r\\n    uint liquidity,\\r\\n    uint amountAMin,\\r\\n    uint amountBMin,\\r\\n    address to,\\r\\n    uint deadline,\\r\\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n  ) external returns (uint amountA, uint amountB);\\r\\n  function removeLiquidityETHWithPermit(\\r\\n    address token,\\r\\n    uint liquidity,\\r\\n    uint amountTokenMin,\\r\\n    uint amountETHMin,\\r\\n    address to,\\r\\n    uint deadline,\\r\\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\\r\\n  ) external returns (uint amountToken, uint amountETH);\\r\\n  function swapExactTokensForTokens(\\r\\n    uint amountIn,\\r\\n    uint amountOutMin,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external returns (uint[] memory amounts);\\r\\n  function swapTokensForExactTokens(\\r\\n    uint amountOut,\\r\\n    uint amountInMax,\\r\\n    address[] calldata path,\\r\\n    address to,\\r\\n    uint deadline\\r\\n  ) external returns (uint[] memory amounts);\\r\\n  function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n    external\\r\\n    payable\\r\\n    returns (uint[] memory amounts);\\r\\n  function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\r\\n    external\\r\\n    returns (uint[] memory amounts);\\r\\n  function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\r\\n    external\\r\\n    returns (uint[] memory amounts);\\r\\n  function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\r\\n    external\\r\\n    payable\\r\\n    returns (uint[] memory amounts);\\r\\n\\r\\n  function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\r\\n  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\r\\n  function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\r\\n  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n  function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\r\\n}\\r\\n\\r\\ninterface IRewarderv2 {\\r\\n  function getReward(address account, address token) external view returns(uint256);\\r\\n  function claim(address account, address token) external;\\r\\n}\\r\\n\\r\\ninterface ILiquidXv2Factory {\\r\\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n}\\r\\n\\r\\ninterface ILiquidXv2Pair {\\r\\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n  event Approval(address indexed owner, address indexed spender, uint value);\\r\\n  event Transfer(address indexed from, address indexed to, uint value);\\r\\n\\r\\n  function name() external view returns (string memory);\\r\\n  function symbol() external view returns (string memory);\\r\\n  function decimals() external view returns (uint8);\\r\\n  function totalSupply() external view returns (uint);\\r\\n  function balanceOf(address owner) external view returns (uint);\\r\\n  function allowance(address owner, address spender) external view returns (uint);\\r\\n\\r\\n  function approve(address spender, uint value) external returns (bool);\\r\\n  function transfer(address to, uint value) external returns (bool);\\r\\n  function transferFrom(address from, address to, uint value) external returns (bool);\\r\\n}\\r\\n\\r\\ninterface IWETH {\\r\\n  function deposit() external payable;\\r\\n  function transfer(address to, uint value) external returns (bool);\\r\\n  function withdraw(uint) external;\\r\\n}\\r\\n\\r\\ninterface IERC20Mint is IERC20 {\\r\\n  function mint(address account, uint256 amount) external;\\r\\n  function burn(address account, uint256 amount) external;\\r\\n}\\r\\n\\r\\ninterface IERC20Permit {\\r\\n  function permit(\\r\\n    address owner,\\r\\n    address spender,\\r\\n    uint256 value,\\r\\n    uint256 deadline,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s\\r\\n  ) external;\\r\\n  function nonces(address owner) external view returns (uint256);\\r\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n}\\r\\n\\r\\nlibrary Address {\\r\\n  function isContract(address account) internal view returns (bool) {\\r\\n    return account.code.length > 0;\\r\\n  }\\r\\n\\r\\n  function sendValue(address payable recipient, uint256 amount) internal {\\r\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n  }\\r\\n\\r\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n      return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionCall(\\r\\n      address target,\\r\\n      bytes memory data,\\r\\n      string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n      return functionCallWithValue(target, data, 0, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionCallWithValue(\\r\\n      address target,\\r\\n      bytes memory data,\\r\\n      uint256 value\\r\\n  ) internal returns (bytes memory) {\\r\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionCallWithValue(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    uint256 value,\\r\\n    string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\r\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionStaticCall(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    string memory errorMessage\\r\\n  ) internal view returns (bytes memory) {\\r\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n    return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n  }\\r\\n\\r\\n  function functionDelegateCall(\\r\\n    address target,\\r\\n    bytes memory data,\\r\\n    string memory errorMessage\\r\\n  ) internal returns (bytes memory) {\\r\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\r\\n  }\\r\\n\\r\\n  function verifyCallResultFromTarget(\\r\\n    address target,\\r\\n    bool success,\\r\\n    bytes memory returndata,\\r\\n    string memory errorMessage\\r\\n  ) internal view returns (bytes memory) {\\r\\n    if (success) {\\r\\n      if (returndata.length == 0) {\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n      }\\r\\n      return returndata;\\r\\n    } else {\\r\\n      _revert(returndata, errorMessage);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function verifyCallResult(\\r\\n    bool success,\\r\\n    bytes memory returndata,\\r\\n    string memory errorMessage\\r\\n  ) internal pure returns (bytes memory) {\\r\\n    if (success) {\\r\\n      return returndata;\\r\\n    } else {\\r\\n      _revert(returndata, errorMessage);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\\r\\n    if (returndata.length > 0) {\\r\\n      assembly {\\r\\n        let returndata_size := mload(returndata)\\r\\n        revert(add(32, returndata), returndata_size)\\r\\n      }\\r\\n    } else {\\r\\n      revert(errorMessage);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nlibrary SafeERC20 {\\r\\n  using Address for address;\\r\\n\\r\\n  function safeTransfer(\\r\\n    IERC20 token,\\r\\n    address to,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\r\\n  }\\r\\n\\r\\n  function safeTransferFrom(\\r\\n    IERC20 token,\\r\\n    address from,\\r\\n    address to,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\r\\n  }\\r\\n\\r\\n  function safeApprove(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    require(\\r\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\r\\n      \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\r\\n    );\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\r\\n  }\\r\\n\\r\\n  function safeIncreaseAllowance(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\\r\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n  }\\r\\n\\r\\n  function safeDecreaseAllowance(\\r\\n    IERC20 token,\\r\\n    address spender,\\r\\n    uint256 value\\r\\n  ) internal {\\r\\n    unchecked {\\r\\n      uint256 oldAllowance = token.allowance(address(this), spender);\\r\\n      require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\r\\n      uint256 newAllowance = oldAllowance - value;\\r\\n      _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function safePermit(\\r\\n    IERC20Permit token,\\r\\n    address owner,\\r\\n    address spender,\\r\\n    uint256 value,\\r\\n    uint256 deadline,\\r\\n    uint8 v,\\r\\n    bytes32 r,\\r\\n    bytes32 s\\r\\n  ) internal {\\r\\n    uint256 nonceBefore = token.nonces(owner);\\r\\n    token.permit(owner, spender, value, deadline, v, r, s);\\r\\n    uint256 nonceAfter = token.nonces(owner);\\r\\n    require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\r\\n  }\\r\\n\\r\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\r\\n    bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\r\\n    if (returndata.length > 0) {\\r\\n      require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\ninterface ISwapPlusv1 {\\r\\n  struct swapRouter {\\r\\n    string platform;\\r\\n    address tokenIn;\\r\\n    address tokenOut;\\r\\n    uint256 amountOutMin;\\r\\n    uint256 meta; // fee, flag(stable), 0=v2\\r\\n    uint256 percent;\\r\\n  }\\r\\n  struct swapLine {\\r\\n    swapRouter[] swaps;\\r\\n  }\\r\\n  struct swapBlock {\\r\\n    swapLine[] lines;\\r\\n  }\\r\\n\\r\\n  function swap(address tokenIn, uint256 amount, address tokenOut, address recipient, swapBlock[] calldata swBlocks) external payable returns(uint256, uint256);\\r\\n}\\r\\n\\r\\ncontract LiquidXv2Zap {\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n  address public router;\\r\\n  address public factory;\\r\\n  address public swapPlus;\\r\\n  address public wrappedETH;\\r\\n  address public rewarder;\\r\\n\\r\\n  mapping (address => bool) public operators;\\r\\n  address public operatorSetter;\\r\\n\\r\\n  // account => pair => basketId\\r\\n  mapping (address => mapping(address => mapping(uint256 => uint256))) public balanceOf;\\r\\n\\r\\n  struct swapPath {\\r\\n    ISwapPlusv1.swapBlock[] path;\\r\\n  }\\r\\n\\r\\n  event Deposit(address account, address token0, address token1, uint256 basketId, uint256 amount);\\r\\n  event Withdraw(address account, address token0, address token1, uint256 basketId, uint256 amount);\\r\\n\\r\\n  receive() external payable {\\r\\n  }\\r\\n\\r\\n  constructor(address _router, address _swapPlus, address _rewarder, address _wrappedETH) {\\r\\n    router = _router;\\r\\n    factory = ILiquidXv2Router01(_router).factory();\\r\\n    swapPlus = _swapPlus;\\r\\n    wrappedETH = _wrappedETH;\\r\\n    rewarder = _rewarder;\\r\\n    operatorSetter = msg.sender;\\r\\n  }\\r\\n\\r\\n  modifier onlyOpertaor() {\\r\\n    require(operators[msg.sender], \\\"LiquidXv2Zap: !operator\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function deposit(address account, address token, address tokenM, swapPath calldata path, address token0, address token1, uint256[3] calldata amount, uint256 basketId) public payable returns(uint256) {\\r\\n    address pair = ILiquidXv2Factory(factory).getPair(token0, token1);\\r\\n    require(pair != address(0), \\\"LiquidXv2Zap: no pair\\\");\\r\\n\\r\\n    // retAddLp 0, 1, 2\\r\\n    // inAmount\\r\\n    // token0Amount, token1Amount\\r\\n    uint256[6] memory lvar;\\r\\n    lvar[3] = msg.value;\\r\\n    address inToken = token;\\r\\n    if (token != address(0)) {\\r\\n      lvar[3] = IERC20(token).balanceOf(address(this));\\r\\n      IERC20(token).safeTransferFrom(account, address(this), amount[0]);\\r\\n      lvar[3] = IERC20(token).balanceOf(address(this)) - lvar[3];\\r\\n    }\\r\\n    else {\\r\\n      inToken = wrappedETH;\\r\\n      IWETH(wrappedETH).deposit{value: lvar[3]}();\\r\\n    }\\r\\n\\r\\n    if (path.path.length > 0) {\\r\\n      _approveTokenIfNeeded(inToken, swapPlus, lvar[3]);\\r\\n      (, lvar[3]) = ISwapPlusv1(swapPlus).swap(inToken, lvar[3], tokenM, address(this), path.path);\\r\\n      inToken = tokenM;\\r\\n    }\\r\\n\\r\\n    (lvar[4], lvar[5]) = _depositSwap(token0, token1, inToken, lvar[3]);\\r\\n\\r\\n    (lvar[0], lvar[1], lvar[2]) = ILiquidXv2Router01(router).addLiquidity(token0, token1, lvar[4], lvar[5], amount[1], amount[2], address(this), block.timestamp);\\r\\n    _refundReserveToken(account, token0, token1, lvar[4]-lvar[0], lvar[5]-lvar[1]);\\r\\n    if (basketId == 0) {\\r\\n      IERC20(pair).safeTransfer(account, lvar[2]);\\r\\n    }\\r\\n    else {\\r\\n      _addBalance(account, pair, basketId, lvar[2]);\\r\\n    }\\r\\n\\r\\n    if (rewarder != address(0) && IRewarderv2(rewarder).getReward(account, pair) > 0) {\\r\\n      IRewarderv2(rewarder).claim(account, pair);\\r\\n    }\\r\\n\\r\\n    emit Deposit(account, token0, token1, basketId, lvar[2]);\\r\\n    return lvar[2];\\r\\n  }\\r\\n\\r\\n  function withdraw(address account, address token0, address token1, uint256 amount, address tokenOut, uint256 basketId, address tokenM, swapPath calldata wpath, uint256[3] memory amountMin) public returns(uint256) {\\r\\n    address pair = ILiquidXv2Factory(factory).getPair(token0, token1);\\r\\n    require(pair != address(0), \\\"LiquidXv2Zap: no pair\\\");\\r\\n\\r\\n    if (basketId == 0) {\\r\\n      IERC20(pair).safeTransferFrom(account, address(this), amount);\\r\\n    }\\r\\n    else {\\r\\n      require(account == msg.sender || operators[msg.sender], \\\"LiquidXv2Zap: no access\\\");\\r\\n      if (balanceOf[account][pair][basketId] < amount) {\\r\\n        amount = balanceOf[account][pair][basketId];\\r\\n      }\\r\\n      balanceOf[account][pair][basketId] -= amount;\\r\\n    }\\r\\n\\r\\n    if (amount == 0) return 0;\\r\\n\\r\\n    _approveTokenIfNeeded(pair, router, amount);\\r\\n    // amount0, 1\\r\\n    // outAmount\\r\\n    uint256[3] memory vamount;\\r\\n    (vamount[0], vamount[1]) = ILiquidXv2Router01(router).removeLiquidity(token0, token1, amount, amountMin[0], amountMin[1], address(this), block.timestamp);\\r\\n\\r\\n    address tOut = tokenOut; \\r\\n    if (tokenOut == address(0)) {\\r\\n      tOut = wrappedETH;\\r\\n    }\\r\\n\\r\\n    vamount[2] = 0;\\r\\n    if (tOut == token1) {\\r\\n      vamount[2] = vamount[1];\\r\\n      _approveTokenIfNeeded(token0, router, vamount[0]);\\r\\n      address[] memory path = new address[](2);\\r\\n      path[0] = token0;\\r\\n      path[1] = token1;\\r\\n      uint256[] memory ret = ILiquidXv2Router01(router).swapExactTokensForTokens(vamount[0], amountMin[2], path, address(this), block.timestamp);\\r\\n      vamount[2] += ret[1];\\r\\n    }\\r\\n    else {\\r\\n      vamount[2] = vamount[0];\\r\\n      _approveTokenIfNeeded(token1, router, vamount[1]);\\r\\n      address[] memory path = new address[](2);\\r\\n      path[0] = token1;\\r\\n      path[1] = token0;\\r\\n      uint256[] memory ret = ILiquidXv2Router01(router).swapExactTokensForTokens(vamount[1], amountMin[2], path, address(this), block.timestamp);\\r\\n      vamount[2] += ret[1];\\r\\n    }\\r\\n\\r\\n    if (wpath.path.length > 0) {\\r\\n      _approveTokenIfNeeded(tokenOut, swapPlus, vamount[2]);\\r\\n      (, vamount[2]) = ISwapPlusv1(swapPlus).swap(tokenOut, vamount[2], tokenM==address(0)?wrappedETH:tokenM, address(this), wpath.path);\\r\\n      tokenOut = tokenM;\\r\\n    }\\r\\n\\r\\n    if (tokenOut != address(0)) {\\r\\n      IERC20(tokenOut).safeTransfer(account, vamount[2]);\\r\\n    }\\r\\n    else {\\r\\n      IWETH(wrappedETH).withdraw(vamount[2]);\\r\\n      (bool success, ) = payable(account).call{value: vamount[2]}(\\\"\\\");\\r\\n      require(success, \\\"LiquidXv2Zap: Failed withdraw\\\");\\r\\n    }\\r\\n\\r\\n    if (rewarder != address(0) && IRewarderv2(rewarder).getReward(account, pair) > 0) {\\r\\n      IRewarderv2(rewarder).claim(account, pair);\\r\\n    }\\r\\n\\r\\n    emit Withdraw(account, token0, token1, basketId, amount);\\r\\n    return vamount[2];\\r\\n  }\\r\\n\\r\\n  function _depositSwap(address token0, address token1, address inToken, uint256 inAmount) internal returns(uint256, uint256) {\\r\\n    address pair = ILiquidXv2Factory(factory).getPair(token0, token1);\\r\\n\\r\\n    bool isToken0 = false;\\r\\n    address outToken = token0;\\r\\n    uint256 reserve = 0;\\r\\n    if (inToken == token0) {\\r\\n      isToken0 = true;\\r\\n      outToken = token1;\\r\\n      (reserve, , ) = ILiquidXv2Pair(pair).getReserves();\\r\\n    }\\r\\n    else {\\r\\n      (, reserve, ) = ILiquidXv2Pair(pair).getReserves();\\r\\n    }\\r\\n\\r\\n    _approveTokenIfNeeded(inToken, router, inAmount);\\r\\n    uint256 swapAmount = _calculateSwapAmount(reserve, inAmount);\\r\\n\\r\\n    address[] memory path = new address[](2);\\r\\n    path[0] = inToken;\\r\\n    path[1] = outToken;\\r\\n    uint256[] memory ret = ILiquidXv2Router01(router).swapExactTokensForTokens(swapAmount, 0, path, address(this), block.timestamp);\\r\\n    inAmount = inAmount - ret[0];\\r\\n\\r\\n    _approveTokenIfNeeded(outToken, router, ret[1]);\\r\\n\\r\\n    if (isToken0) {\\r\\n      return (inAmount, ret[1]);\\r\\n    }\\r\\n    else {\\r\\n      return (ret[1], inAmount);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _refundReserveToken(address account, address token0, address token1, uint256 amount0, uint256 amount1) internal {\\r\\n    if (amount0 > 0) {\\r\\n      IERC20(token0).safeTransfer(account, amount0);\\r\\n    }\\r\\n    if (amount1 > 0) {\\r\\n      IERC20(token1).safeTransfer(account, amount1);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _calculateSwapAmount(uint256 reserve, uint256 inAmount) internal pure returns(uint256) {\\r\\n    // (sqrt(reserve^2*(1+C)^2 + 4C*reserve*inAmount) - reserve*(1+C)) / 2C\\r\\n    uint256 a1 = reserve * reserve * 1997 *1997;\\r\\n    uint256 a2 = 4 * 997 * reserve * inAmount * 1000;\\r\\n    return (_sqrt(a1+a2) - reserve * 1997) / (2 * 997);\\r\\n  }\\r\\n\\r\\n  function _sqrt(uint x) internal pure returns (uint y) {\\r\\n    uint z = (x + 1) / 2;\\r\\n    y = x;\\r\\n    while (z < y) {\\r\\n      y = z;\\r\\n      z = (x / z + z) / 2;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _addBalance(address account, address pair, uint256 basketId, uint256 amount) internal {\\r\\n    balanceOf[account][pair][basketId] += amount;\\r\\n  }\\r\\n\\r\\n  function withdrawToken(address token, address target, uint256 amount) public onlyOpertaor {\\r\\n    if (token == address(0)) {\\r\\n      (bool success, ) = payable(target).call{value: amount}(\\\"\\\");\\r\\n      require(success, \\\"LiquidXv2Zap: Failed withdraw\\\");\\r\\n    }\\r\\n    else {\\r\\n      IERC20(token).safeTransfer(target, amount);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function setRouterAndFactory(address _router) public {\\r\\n    require(msg.sender == operatorSetter, 'LiquidXv2Zap: FORBIDDEN');\\r\\n    router = _router;\\r\\n    factory = ILiquidXv2Router01(_router).factory();\\r\\n  }\\r\\n\\r\\n  function setSwapPlus(address _swapPlus) public {\\r\\n    require(msg.sender == operatorSetter, 'LiquidXv2Zap: FORBIDDEN');\\r\\n    swapPlus = _swapPlus;\\r\\n  }\\r\\n\\r\\n  function setRewarder(address _rewarder) public {\\r\\n    require(msg.sender == operatorSetter, 'LiquidXv2Zap: FORBIDDEN');\\r\\n    rewarder = _rewarder;\\r\\n  }\\r\\n\\r\\n  function setOperator(address _operator, bool mode) external {\\r\\n    require(msg.sender == operatorSetter, 'LiquidXv2Zap: FORBIDDEN');\\r\\n    operators[_operator] = mode;\\r\\n  }\\r\\n\\r\\n  function setOperatorSetter(address _operatorSetter) external {\\r\\n    require(msg.sender == operatorSetter, 'LiquidXv2Zap: FORBIDDEN');\\r\\n    operatorSetter = _operatorSetter;\\r\\n  }\\r\\n\\r\\n  function _approveTokenIfNeeded(address token, address spender, uint256 amount) private {\\r\\n    uint256 oldAllowance = IERC20(token).allowance(address(this), spender);\\r\\n    if (oldAllowance < amount) {\\r\\n      if (oldAllowance > 0) {\\r\\n        IERC20(token).safeApprove(spender, 0);\\r\\n      }\\r\\n      IERC20(token).safeApprove(spender, type(uint256).max);\\r\\n    }\\r\\n  }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}",
    "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_swapPlus\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewarder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wrappedETH\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"basketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"basketId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenM\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"platform\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"meta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwapPlusv1.swapRouter[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapLine[]\",\"name\":\"lines\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapBlock[]\",\"name\":\"path\",\"type\":\"tuple[]\"}],\"internalType\":\"struct LiquidXv2Zap.swapPath\",\"name\":\"path\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256[3]\",\"name\":\"amount\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256\",\"name\":\"basketId\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorSetter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewarder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"mode\",\"type\":\"bool\"}],\"name\":\"setOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operatorSetter\",\"type\":\"address\"}],\"name\":\"setOperatorSetter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewarder\",\"type\":\"address\"}],\"name\":\"setRewarder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"name\":\"setRouterAndFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_swapPlus\",\"type\":\"address\"}],\"name\":\"setSwapPlus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapPlus\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"basketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenM\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"platform\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"meta\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwapPlusv1.swapRouter[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapLine[]\",\"name\":\"lines\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ISwapPlusv1.swapBlock[]\",\"name\":\"path\",\"type\":\"tuple[]\"}],\"internalType\":\"struct LiquidXv2Zap.swapPath\",\"name\":\"wpath\",\"type\":\"tuple\"},{\"internalType\":\"uint256[3]\",\"name\":\"amountMin\",\"type\":\"uint256[3]\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrappedETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
    "ContractName": "LiquidXv2Zap",
    "CompilerVersion": "v0.8.19+commit.7dd6d404",
    "OptimizationUsed": "1",
    "Runs": "200",
    "ConstructorArguments": "000000000000000000000000eba22665c355457fa4e5a07b3a7559f22fd7492300000000000000000000000091f6aa43c190e317e4d02698127aa7a629cf4b23000000000000000000000000802cd52cef721d8935c27062b534fa7e65b04b4f000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
    "EVMVersion": "paris",
    "Library": "",
    "LicenseType": "",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": ""
}