{
    "SourceCode": "// File: contracts/PhoenixModules/ERC20/IERC20.sol\r\n\r\npragma solidity =0.5.16;\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see {ERC20Detailed}.\r\n */\r\ninterface IERC20 {\r\n    function decimals() external view returns (uint8);\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n      /**\r\n     * EXTERNAL FUNCTION\r\n     *\r\n     * @dev change token name\r\n     * @param _name token name\r\n     * @param _symbol token symbol\r\n     *\r\n     */\r\n    function changeTokenName(string calldata _name, string calldata _symbol)external;\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/PhoenixModules/modules/SafeMath.sol\r\n\r\npragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n    uint256 constant internal calDecimal = 1e18; \r\n    function mulPrice(uint256 value,uint256[2] memory prices,uint8 id)internal pure returns(uint256){\r\n        return id == 0 ? div(mul(mul(prices[1],value),calDecimal),prices[0]) :\r\n            div(mul(mul(prices[0],value),calDecimal),prices[1]);\r\n    }\r\n    function divPrice(uint256 value,uint256[2] memory prices,uint8 id)internal pure returns(uint256){\r\n        return id == 0 ? div(div(mul(prices[0],value),calDecimal),prices[1]) :\r\n            div(div(mul(prices[1],value),calDecimal),prices[0]);\r\n    }\r\n}\r\n\r\n// File: contracts/PhoenixModules/modules/Address.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call.value(amount)(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call.value(value )(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/PhoenixModules/ERC20/safeErc20.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity =0.5.16;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/PhoenixModules/multiSignature/multiSignatureClient.sol\r\n\r\npragma solidity =0.5.16;\r\n/**\r\n * SPDX-License-Identifier: GPL-3.0-or-later\r\n * Phoenix\r\n * Copyright (C) 2020 Phoenix Options Protocol\r\n */\r\ninterface IMultiSignature{\r\n    function getValidSignature(bytes32 msghash,uint256 lastIndex) external view returns(uint256);\r\n}\r\ncontract multiSignatureClient{\r\n    uint256 private constant multiSignaturePositon = uint256(keccak256(\"org.Phoenix.multiSignature.storage\"));\r\n    constructor(address multiSignature) public {\r\n        require(multiSignature != address(0),\"multiSignatureClient : Multiple signature contract address is zero!\");\r\n        saveValue(multiSignaturePositon,uint256(multiSignature));\r\n    }    \r\n    function getMultiSignatureAddress()public view returns (address){\r\n        return address(getValue(multiSignaturePositon));\r\n    }\r\n    modifier validCall(){\r\n        checkMultiSignature();\r\n        _;\r\n    }\r\n    function checkMultiSignature() internal {\r\n        uint256 value;\r\n        assembly {\r\n            value := callvalue()\r\n        }\r\n        bytes32 msgHash = keccak256(abi.encodePacked(msg.sender, address(this),value,msg.data));\r\n        address multiSign = getMultiSignatureAddress();\r\n        uint256 index = getValue(uint256(msgHash));\r\n        uint256 newIndex = IMultiSignature(multiSign).getValidSignature(msgHash,index);\r\n        require(newIndex > index, \"multiSignatureClient : This tx is not aprroved\");\r\n        saveValue(uint256(msgHash),newIndex);\r\n    }\r\n    function saveValue(uint256 position,uint256 value) internal \r\n    {\r\n        assembly {\r\n            sstore(position, value)\r\n        }\r\n    }\r\n    function getValue(uint256 position) internal view returns (uint256 value) {\r\n        assembly {\r\n            value := sload(position)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/PhoenixModules/proxyModules/proxyOwner.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n/**\r\n * @title  proxyOwner Contract\r\n\r\n */\r\n\r\ncontract proxyOwner is multiSignatureClient{\r\n    bytes32 private constant ownerExpiredPosition = keccak256(\"org.Phoenix.ownerExpired.storage\");\r\n    bytes32 private constant versionPositon = keccak256(\"org.Phoenix.version.storage\");\r\n    bytes32 private constant proxyOwnerPosition  = keccak256(\"org.Phoenix.Owner.storage\");\r\n    bytes32 private constant proxyOriginPosition  = keccak256(\"org.Phoenix.Origin.storage\");\r\n    uint256 private constant oncePosition  = uint256(keccak256(\"org.Phoenix.Once.storage\"));\r\n    uint256 private constant ownerExpired =  90 days;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event OriginTransferred(address indexed previousOrigin, address indexed newOrigin);\r\n    constructor(address multiSignature) multiSignatureClient(multiSignature) public{\r\n        _setProxyOwner(msg.sender);\r\n        _setProxyOrigin(tx.origin);\r\n    }\r\n    /**\r\n     * @dev Allows the current owner to transfer ownership\r\n     * @param _newOwner The address to transfer ownership to\r\n     */\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner\r\n    {\r\n        _setProxyOwner(_newOwner);\r\n    }\r\n    function _setProxyOwner(address _newOwner) internal \r\n    {\r\n        emit OwnershipTransferred(owner(),_newOwner);\r\n        bytes32 position = proxyOwnerPosition;\r\n        assembly {\r\n            sstore(position, _newOwner)\r\n        }\r\n        position = ownerExpiredPosition;\r\n        uint256 expired = now+ownerExpired;\r\n        assembly {\r\n            sstore(position, expired)\r\n        }\r\n    }\r\n    function owner() public view returns (address _owner) {\r\n        bytes32 position = proxyOwnerPosition;\r\n        assembly {\r\n            _owner := sload(position)\r\n        }\r\n    }\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require (isOwner(),\"proxyOwner: caller must be the proxy owner and a contract and not expired\");\r\n        _;\r\n    }\r\n    function transferOrigin(address _newOrigin) public onlyOrigin\r\n    {\r\n        _setProxyOrigin(_newOrigin);\r\n    }\r\n    function _setProxyOrigin(address _newOrigin) internal \r\n    {\r\n        emit OriginTransferred(txOrigin(),_newOrigin);\r\n        bytes32 position = proxyOriginPosition;\r\n        assembly {\r\n            sstore(position, _newOrigin)\r\n        }\r\n    }\r\n    function txOrigin() public view returns (address _origin) {\r\n        bytes32 position = proxyOriginPosition;\r\n        assembly {\r\n            _origin := sload(position)\r\n        }\r\n    }\r\n    function ownerExpiredTime() public view returns (uint256 _expired) {\r\n        bytes32 position = ownerExpiredPosition;\r\n        assembly {\r\n            _expired := sload(position)\r\n        }\r\n    }\r\n    modifier originOnce() {\r\n        require (msg.sender == txOrigin(),\"proxyOwner: caller is not the tx origin!\");\r\n        uint256 key = oncePosition+uint32(msg.sig);\r\n        require (getValue(key)==0, \"proxyOwner : This function must be invoked only once!\");\r\n        saveValue(key,1);\r\n        _;\r\n    }\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == owner() && isContract(msg.sender);\r\n    }\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOrigin() {\r\n        require (msg.sender == txOrigin(),\"proxyOwner: caller is not the tx origin!\");\r\n        checkMultiSignature();\r\n        _;\r\n    }\r\n    modifier OwnerOrOrigin(){\r\n        if (isOwner()){\r\n        }else if(msg.sender == txOrigin()){\r\n            checkMultiSignature();\r\n        }else{\r\n            require(false,\"proxyOwner: caller is not owner or origin\");\r\n        }\r\n        _;\r\n    }\r\n    function _setVersion(uint256 version_) internal \r\n    {\r\n        bytes32 position = versionPositon;\r\n        assembly {\r\n            sstore(position, version_)\r\n        }\r\n    }\r\n    function version() public view returns(uint256 version_){\r\n        bytes32 position = versionPositon;\r\n        assembly {\r\n            version_ := sload(position)\r\n        }\r\n    }\r\n    \r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n// File: contracts/PhoenixModules/proxyModules/initializable.sol\r\n\r\npragma solidity =0.5.16;\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract initializable {\r\n\r\n    /**\r\n    * @dev Indicates that the contract has been initialized.\r\n    */\r\n    bool private initialized;\r\n\r\n    /**\r\n    * @dev Indicates that the contract is in the process of being initialized.\r\n    */\r\n    bool private initializing;\r\n\r\n    /**\r\n    * @dev Modifier to use in the initializer function of a contract.\r\n    */\r\n    modifier initializer() {\r\n        require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n        bool wasInitializing = initializing;\r\n        initializing = true;\r\n        initialized = true;\r\n\r\n        _;\r\n        initializing = wasInitializing;\r\n    }\r\n\r\n    /// @dev Returns true if and only if the function is running in the constructor\r\n    function isConstructor() private view returns (bool) {\r\n        // extcodesize checks the size of the code stored in an address, and\r\n        // address returns the current address. Since the code is still not\r\n        // deployed when running a constructor, any checks on its code size will\r\n        // yield zero, making it an effective way to detect if a contract is\r\n        // under construction or not.\r\n        uint256 cs;\r\n        assembly { cs := extcodesize(address) }\r\n        return cs == 0;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/PhoenixModules/proxyModules/versionUpdater.sol\r\n\r\npragma solidity =0.5.16;\r\n/**\r\n * SPDX-License-Identifier: GPL-3.0-or-later\r\n * Phoenix\r\n * Copyright (C) 2020 Phoenix Options Protocol\r\n */\r\n\r\n\r\ncontract versionUpdater is proxyOwner,initializable {\r\n    function implementationVersion() public pure returns (uint256);\r\n    function initialize() public initializer versionUpdate {\r\n\r\n    }\r\n    modifier versionUpdate(){\r\n        require(implementationVersion() > version() &&  ownerExpiredTime()>now,\"New version implementation is already updated!\");\r\n        _;\r\n    }\r\n}\r\n\r\n// File: contracts/PhoenixModules/interface/IPHXOracle.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\ninterface IPHXOracle {\r\n    /**\r\n  * @notice retrieves price of an asset\r\n  * @dev function to get price for an asset\r\n  * @param asset Asset for which to get the price\r\n  * @return uint mantissa of asset price (scaled by 1e8) or zero if unset or contract paused\r\n  */\r\n    function getPrice(address asset) external view returns (uint256);\r\n    function getUnderlyingPrice(uint256 cToken) external view returns (uint256);\r\n    function getPrices(uint256[] calldata assets) external view returns (uint256[]memory);\r\n    function getAssetAndUnderlyingPrice(address asset,uint256 underlying) external view returns (uint256,uint256);\r\n//    function getSellOptionsPrice(address oToken) external view returns (uint256);\r\n//    function getBuyOptionsPrice(address oToken) external view returns (uint256);\r\n}\r\ncontract ImportOracle is proxyOwner{\r\n    IPHXOracle internal _oracle;\r\n    function oraclegetPrices(uint256[] memory assets) internal view returns (uint256[]memory){\r\n        uint256[] memory prices = _oracle.getPrices(assets);\r\n        uint256 len = assets.length;\r\n        for (uint i=0;i<len;i++){\r\n        require(prices[i] >= 100 && prices[i] <= 1e30,\"oracle price error\");\r\n        }\r\n        return prices;\r\n    }\r\n    function oraclePrice(address asset) internal view returns (uint256){\r\n        uint256 price = _oracle.getPrice(asset);\r\n        require(price >= 100 && price <= 1e30,\"oracle price error\");\r\n        return price;\r\n    }\r\n    function oracleUnderlyingPrice(uint256 cToken) internal view returns (uint256){\r\n        uint256 price = _oracle.getUnderlyingPrice(cToken);\r\n        require(price >= 100 && price <= 1e30,\"oracle price error\");\r\n        return price;\r\n    }\r\n    function oracleAssetAndUnderlyingPrice(address asset,uint256 cToken) internal view returns (uint256,uint256){\r\n        (uint256 price1,uint256 price2) = _oracle.getAssetAndUnderlyingPrice(asset,cToken);\r\n        require(price1 >= 100 && price1 <= 1e30,\"oracle price error\");\r\n        require(price2 >= 100 && price2 <= 1e30,\"oracle price error\");\r\n        return (price1,price2);\r\n    }\r\n    function getOracleAddress() public view returns(address){\r\n        return address(_oracle);\r\n    }\r\n    function setOracleAddress(address oracle)public onlyOwner{\r\n        _oracle = IPHXOracle(oracle);\r\n    }\r\n}\r\n\r\n// File: contracts/rebaseToken/IRebaseToken.sol\r\n\r\npragma solidity =0.5.16;\r\ninterface IRebaseToken {\r\n    function setTimeLimitation(uint256 _limitation) external;\r\n    function changeTokenName(string calldata _name, string calldata _symbol,address token)external;\r\n    function calRebaseRatio(uint256 newTotalSupply) external;\r\n    function newErc20(uint256 leftAmount) external;\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function totalSupply() external view returns (uint256);\r\n    function mint(address account, uint256 amount) external;\r\n    function burn(address account, uint256 amount) external;\r\n}\r\n\r\n// File: contracts/stakePool/IStakePool.sol\r\n\r\npragma solidity =0.5.16;\r\ninterface IStakePool {\r\n    function modifyPermission(address addAddress,uint256 permission)external;\r\n    function poolToken()external view returns (address);\r\n    function loan(address account) external view returns(uint256);\r\n    function PPTCoin()external view returns (address);\r\n    function interestRate()external view returns (uint64);\r\n    function setInterestRate(uint64 interestrate)external;\r\n    function interestInflation(uint64 inflation)external;\r\n    function poolBalance() external view returns (uint256);\r\n    function borrowLimit(address account)external view returns (uint256);\r\n    function borrow(uint256 amount) external returns(uint256);\r\n    function borrowAndInterest(uint256 amount) external;\r\n    function repay(uint256 amount,bool bAll) external payable;\r\n    function repayAndInterest(uint256 amount) external payable;\r\n    function setPoolInfo(address PPTToken,address stakeToken,uint64 interestrate) external;\r\n}\r\n\r\n// File: contracts/PhoenixModules/modules/ReentrancyGuard.sol\r\n\r\npragma solidity =0.5.16;\r\ncontract ReentrancyGuard {\r\n\r\n  /**\r\n   * @dev We use a single lock for the whole contract.\r\n   */\r\n  bool private reentrancyLock = false;\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * @notice If you mark a function `nonReentrant`, you should also\r\n   * mark it `external`. Calling one nonReentrant function from\r\n   * another is not supported. Instead, you can implement a\r\n   * `private` function doing the actual work, and a `external`\r\n   * wrapper marked as `nonReentrant`.\r\n   */\r\n  modifier nonReentrant() {\r\n    require(!reentrancyLock);\r\n    reentrancyLock = true;\r\n    _;\r\n    reentrancyLock = false;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/PhoenixModules/proxyModules/proxyOperator.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * each operator can be granted exclusive access to specific functions.\r\n *\r\n */\r\ncontract proxyOperator is proxyOwner {\r\n    mapping(uint256=>address) internal _operators;\r\n    uint256 internal constant managerIndex = 0;\r\n    event OperatorTransferred(address indexed previousOperator, address indexed newOperator,uint256 indexed index);\r\n    modifier onlyManager() {\r\n        require(msg.sender == _operators[managerIndex], \"Operator: caller is not the manager\");\r\n        _;\r\n    }\r\n    modifier onlyOperator(uint256 index) {\r\n        require(_operators[index] == msg.sender,\"Operator: caller is not the eligible Operator\");\r\n        _;\r\n    }\r\n    modifier onlyOperator2(uint256 index1,uint256 index2) {\r\n        require(_operators[index1] == msg.sender || _operators[index2] == msg.sender,\"Operator: caller is not the eligible Operator\");\r\n        _;\r\n    }\r\n    modifier onlyOperator3(uint256 index1,uint256 index2,uint256 index3) {\r\n        require(_operators[index1] == msg.sender || _operators[index2] == msg.sender || _operators[index3] == msg.sender,\r\n            \"Operator: caller is not the eligible Operator\");\r\n        _;\r\n    }\r\n    function setManager(address newManager) public onlyOwner{\r\n        _setOperator(managerIndex,newManager);\r\n    }\r\n    /**\r\n     * @dev modify indexed operator by owner. \r\n     *\r\n     */\r\n    function setOperator(uint256 index,address newAddress)public OwnerOrOrigin{\r\n        require(index>0, \"Index must greater than 0\");\r\n        _setOperator(index,newAddress);\r\n    }\r\n    function _setOperator(uint256 index,address newAddress) internal {\r\n        emit OperatorTransferred(_operators[index], newAddress,index);\r\n        _operators[index] = newAddress;\r\n    }\r\n    function getOperator(uint256 index)public view returns (address) {\r\n        return _operators[index];\r\n    }\r\n}\r\n\r\n// File: contracts/LeveragedPool/leveragedData.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract leveragedData is ImportOracle,versionUpdater,proxyOperator,ReentrancyGuard{\r\n    uint256 constant internal currentVersion = 7;\r\n    function implementationVersion() public pure returns (uint256) \r\n    {\r\n        return currentVersion;\r\n    }\r\n    uint256 constant internal calDecimal = 1e18; \r\n    uint256 constant internal feeDecimal = 1e8; \r\n    struct leverageInfo {\r\n        uint8 id;\r\n        bool bRebase;\r\n        address token;\r\n        IStakePool stakePool;\r\n        uint256 leverageRate;\r\n        uint256 rebalanceWorth;\r\n        IRebaseToken leverageToken;\r\n    }\r\n    leverageInfo internal leverageCoin;\r\n    leverageInfo internal hedgeCoin;\r\n    address public swapRouter;\r\n    address public phxSwapLib;\r\n    uint256[2] public rebalancePrices;\r\n    uint256[2] internal currentPrice;\r\n    uint256 public buyFee;\r\n    uint256 public sellFee;\r\n    uint256 public rebalanceFee;\r\n    uint256 public defaultLeverageRatio;\r\n    uint256 public defaultRebalanceWorth;\r\n    uint256 public rebaseThreshold;\r\n    uint256 public liquidateThreshold;\r\n\r\n    address payable public feeAddress;\r\n    uint256 public rebalanceTol;\r\n\r\n    mapping(address=>mapping(address=>address[])) internal swapRoutingPath;\r\n\r\n    bool internal halted; \r\n\r\n    \r\n    event Swap(address indexed fromCoin,address indexed toCoin,uint256 fromValue,uint256 toValue);\r\n    event Redeem(address indexed recieptor,address indexed Coin,uint256 amount);\r\n    event BuyLeverage(address indexed from,address indexed Coin,uint256 payAmount,uint256 leverageAmount,uint256 tokenPrice);\r\n    event BuyHedge(address indexed from,address indexed Coin,uint256 payAmount,uint256 hedgeAmount,uint256 tokenPrice);\r\n    event SellLeverage(address indexed from,address indexed Coin,uint256 leverageAmount,uint256 amount,uint256 tokenPrice);\r\n    event SellHedge(address indexed from,address indexed Coin,uint256 hedgeAmount,uint256 amount,uint256 tokenPrice);\r\n    event Rebalance(address indexed from,address indexed token,uint256 buyAount,uint256 sellAmount);\r\n    event Liquidate(address indexed from,address indexed token,uint256 loan,uint256 fee,uint256 leftAmount);\r\n}\r\n\r\n// File: contracts/PhoenixModules/modules/safeTransfer.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\ncontract safeTransfer{\r\n    using SafeERC20 for IERC20;\r\n    event Redeem(address indexed recieptor,address indexed token,uint256 amount);\r\n    function getPayableAmount(address token,uint256 amount) internal returns (uint256) {\r\n        if (token == address(0)){\r\n            amount = msg.value;\r\n        }else if (amount > 0){\r\n            IERC20 oToken = IERC20(token);\r\n            oToken.safeTransferFrom(msg.sender, address(this), amount);\r\n        }\r\n        return amount;\r\n    }\r\n    /**\r\n     * @dev An auxiliary foundation which transter amount stake coins to recieptor.\r\n     * @param recieptor recieptor recieptor's account.\r\n     * @param token token address\r\n     * @param amount redeem amount.\r\n     */\r\n    function _redeem(address payable recieptor,address token,uint256 amount) internal{\r\n        if (token == address(0)){\r\n            recieptor.transfer(amount);\r\n        }else{\r\n            IERC20 oToken = IERC20(token);\r\n            oToken.safeTransfer(recieptor,amount);\r\n        }\r\n        emit Redeem(recieptor,token,amount);\r\n    }\r\n}\r\n\r\n// File: contracts/LeveragedPool/leveragedPool.sol\r\n\r\npragma solidity =0.5.16;\r\n\r\n\r\n\r\n\r\n\r\ncontract leveragedPool is leveragedData,safeTransfer{\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    constructor (address multiSignature) proxyOwner(multiSignature) public{\r\n    }\r\n    function() external payable {\r\n    }\r\n    function initialize() public{\r\n        versionUpdater.initialize();\r\n        rebalanceTol = 5e7;\r\n    }\r\n    function update() external versionUpdate {\r\n    }\r\n    function setSwapRouterAddress(address _swapRouter)public OwnerOrOrigin{\r\n        require(swapRouter != _swapRouter,\"swapRouter : same address\");\r\n   \r\n        if(leverageCoin.token != address(0)){\r\n            IERC20 oToken = IERC20(leverageCoin.token);\r\n            oToken.safeApprove(swapRouter,0);\r\n            oToken.safeApprove(_swapRouter,uint256(-1));\r\n        }\r\n        if(hedgeCoin.token != address(0)){\r\n            IERC20 oToken = IERC20(hedgeCoin.token);\r\n            oToken.safeApprove(swapRouter,0);\r\n            oToken.safeApprove(_swapRouter,uint256(-1));\r\n        }\r\n        swapRouter = _swapRouter;\r\n    }\r\n    function getSwapRoutingPath(address token0,address token1) public view returns (address[] memory) {\r\n        return swapRoutingPath[token0][token1];\r\n    }\r\n    function setSwapRoutingPath(address token0,address token1,address[] calldata swapPath) external onlyOrigin {\r\n        swapRoutingPath[token0][token1] = swapPath;\r\n    }\r\n    function setSwapLibAddress(address _swapLib)public OwnerOrOrigin{\r\n        phxSwapLib = _swapLib;\r\n    }\r\n    function setFeeAddress(address payable addrFee) onlyOwner external {\r\n        feeAddress = addrFee;\r\n    }\r\n    function getLeverageRebase() external view returns (bool,bool) {\r\n        return (leverageCoin.bRebase,hedgeCoin.bRebase);\r\n    }\r\n    function getCurrentLeverageRate()external view returns (uint256,uint256) {\r\n        uint256[2] memory underlyingPrice = getUnderlyingPriceView();\r\n        return (_getCurrentLeverageRate(leverageCoin,underlyingPrice),_getCurrentLeverageRate(hedgeCoin,underlyingPrice));\r\n    }\r\n    function _getCurrentLeverageRate(leverageInfo memory coinInfo,uint256[2] memory underlyingPrice)internal view returns (uint256){\r\n        uint256 leverageCp = coinInfo.leverageRate.mulPrice(underlyingPrice, coinInfo.id);\r\n        uint256 leverageRp = (coinInfo.leverageRate-feeDecimal).mulPrice(rebalancePrices, coinInfo.id);\r\n        return leverageCp.mul(feeDecimal).div(leverageCp.sub(leverageRp));\r\n    }\r\n    function getLeverageInfo() external view returns (address,address,address,uint256,uint256) {\r\n        return (leverageCoin.token,address(leverageCoin.stakePool),address(leverageCoin.leverageToken),leverageCoin.leverageRate,leverageCoin.rebalanceWorth);\r\n    }\r\n    function getHedgeInfo() external view returns (address,address,address,uint256,uint256) {\r\n        return (hedgeCoin.token,address(hedgeCoin.stakePool),address(hedgeCoin.leverageToken),hedgeCoin.leverageRate,hedgeCoin.rebalanceWorth);\r\n    }\r\n    function setLeverageFee(uint256 _buyFee,uint256 _sellFee,uint256 _rebalanceFee) OwnerOrOrigin external{\r\n        require(_buyFee<5e6 && _sellFee<5e6 &&_rebalanceFee<5e6,\"Leverage fee is beyond the limit\");\r\n        buyFee = _buyFee;\r\n        sellFee = _sellFee;\r\n        rebalanceFee = _rebalanceFee;\r\n    }\r\n    function setLeveragePoolInfo(address payable _feeAddress,address leveragePool,address hedgePool,\r\n        address oracle,address _swapRouter,address swaplib,address rebaseTokenA,address rebaseTokenB,\r\n        uint256 fees,uint256 _threshold,uint256 rebaseWorth) onlyOwner external{\r\n            setLeveragePoolAddress(_feeAddress,leveragePool,hedgePool,oracle,_swapRouter,swaplib);\r\n            setLeveragePoolInfo_sub(rebaseTokenA,rebaseTokenB,fees,_threshold,rebaseWorth);\r\n        }\r\n    function setLeveragePoolAddress(address payable _feeAddress,address leveragePool,address hedgePool,\r\n        address oracle,address _swapRouter,address swaplib)internal{\r\n        feeAddress = _feeAddress;\r\n        _oracle = IPHXOracle(oracle);\r\n        swapRouter = _swapRouter;\r\n        phxSwapLib = swaplib;\r\n        setStakePool(leverageCoin,0,leveragePool);\r\n        setStakePool(hedgeCoin,1,hedgePool);\r\n    }\r\n    function setLeveragePoolInfo_sub(address rebaseTokenA,address rebaseTokenB,\r\n        uint256 fees,uint256 _threshold,uint256 rebaseWorth) internal {\r\n        rebalancePrices = getUnderlyingPriceView();\r\n        defaultLeverageRatio = uint64(fees>>192);\r\n        defaultRebalanceWorth = rebaseWorth;\r\n        leverageCoin.leverageRate = defaultLeverageRatio;\r\n        leverageCoin.rebalanceWorth = rebaseWorth*calDecimal/rebalancePrices[0];\r\n        leverageCoin.leverageToken = IRebaseToken(rebaseTokenA);\r\n        hedgeCoin.leverageRate = defaultLeverageRatio;\r\n        hedgeCoin.rebalanceWorth = rebaseWorth*calDecimal/rebalancePrices[1];\r\n        hedgeCoin.leverageToken = IRebaseToken(rebaseTokenB);\r\n        buyFee = uint64(fees);\r\n        sellFee = uint64(fees>>64);\r\n        rebalanceFee = uint64(fees>>128);\r\n        rebaseThreshold = uint128(_threshold);\r\n        liquidateThreshold = uint128(_threshold>>128);\r\n    }\r\n    function setStakePool(leverageInfo storage coinInfo,uint8 id,address stakePool) internal{\r\n        coinInfo.id = id;\r\n        coinInfo.stakePool = IStakePool(stakePool);\r\n        coinInfo.token = coinInfo.stakePool.poolToken();\r\n        if(coinInfo.token != address(0)){\r\n            IERC20 oToken = IERC20(coinInfo.token);\r\n            oToken.safeApprove(swapRouter,uint256(-1));\r\n            oToken.safeApprove(stakePool,uint256(-1));\r\n        }\r\n    }\r\n\r\n    function underlyingBalance(uint8 id)internal view returns (uint256){\r\n        address token = (id == 0) ? hedgeCoin.token : leverageCoin.token;\r\n        if (token == address(0)){\r\n            return address(this).balance;\r\n        }else{\r\n            return IERC20(token).balanceOf(address(this));\r\n        }\r\n    }\r\n    function getTotalworths() public view returns(uint256,uint256){\r\n        uint256[2] memory underlyingPrice = getUnderlyingPriceView();\r\n        return (_totalWorth(leverageCoin,underlyingPrice),_totalWorth(hedgeCoin,underlyingPrice));\r\n    }\r\n    function getTokenNetworths() public view returns(uint256,uint256){\r\n        uint256[2] memory underlyingPrice = getUnderlyingPriceView();\r\n        return (_tokenNetworth(leverageCoin,underlyingPrice),_tokenNetworth(hedgeCoin,underlyingPrice));\r\n    }\r\n    function _totalWorth(leverageInfo memory coinInfo,uint256[2] memory underlyingPrice) internal view returns (uint256){\r\n        uint256 totalSup = coinInfo.leverageToken.totalSupply();\r\n        uint256 allLoan = (totalSup.mul(coinInfo.rebalanceWorth)/feeDecimal).mul(coinInfo.leverageRate-feeDecimal);\r\n        return underlyingBalance(coinInfo.id).mulPrice(underlyingPrice,coinInfo.id).sub(allLoan);\r\n    }\r\n\r\n    function buyPrices() public view returns(uint256,uint256){\r\n        uint256[2] memory underlyingPrice = getUnderlyingPriceView();\r\n        return (_tokenNetworthBuy(leverageCoin,underlyingPrice),_tokenNetworthBuy(hedgeCoin,underlyingPrice));\r\n    }\r\n    function _tokenNetworthBuy(leverageInfo memory coinInfo,uint256[2] memory underlyingPrice) internal view returns (uint256){\r\n        uint256 curValue = coinInfo.rebalanceWorth.mul(coinInfo.leverageRate).mulPrice(underlyingPrice,coinInfo.id).divPrice(rebalancePrices,coinInfo.id);\r\n        return curValue.sub(coinInfo.rebalanceWorth.mul(coinInfo.leverageRate-feeDecimal))/feeDecimal;\r\n    }\r\n    function _tokenNetworth(leverageInfo memory coinInfo,uint256[2] memory underlyingPrice) internal view returns (uint256){\r\n        uint256 tokenNum = coinInfo.leverageToken.totalSupply();\r\n        if (tokenNum == 0){\r\n            return coinInfo.rebalanceWorth;\r\n        }else{\r\n            return _totalWorth(coinInfo,underlyingPrice)/tokenNum;\r\n        }\r\n    }\r\n    function buyLeverage(uint256 amount,uint256 minAmount,uint256 deadLine,bytes calldata /*data*/) external payable{\r\n        _buy(leverageCoin,amount,minAmount,deadLine,true);\r\n    }\r\n    function buyHedge(uint256 amount,uint256 minAmount,uint256 deadLine,bytes calldata /*data*/)  external payable{\r\n        _buy(hedgeCoin, amount,minAmount,deadLine,true);\r\n    }\r\n    function buyLeverage2(uint256 amount,uint256 minAmount,uint256 deadLine,bytes calldata /*data*/) external payable{\r\n        _buy(leverageCoin,amount,minAmount,deadLine,false);\r\n    }\r\n    function buyHedge2(uint256 amount,uint256 minAmount,uint256 deadLine,bytes calldata /*data*/) external payable{\r\n        _buy(hedgeCoin, amount,minAmount,deadLine,false);\r\n    }\r\n    function sellLeverage(uint256 amount,uint256 minAmount,uint256 deadLine,bytes calldata /*data*/) external payable{\r\n        _sell(leverageCoin,amount,minAmount,deadLine,true);\r\n    }\r\n    function sellHedge(uint256 amount,uint256 minAmount,uint256 deadLine,bytes calldata /*data*/)  external payable{\r\n        _sell(hedgeCoin, amount,minAmount,deadLine,true);\r\n    }\r\n    function sellLeverage2(uint256 amount,uint256 minAmount,uint256 deadLine,bytes calldata /*data*/) external payable{\r\n        _sell(leverageCoin,amount,minAmount,deadLine,false);\r\n    }\r\n    function sellHedge2(uint256 amount,uint256 minAmount,uint256 deadLine,bytes calldata /*data*/) external payable{\r\n        _sell(hedgeCoin, amount,minAmount,deadLine,false);\r\n    }\r\n    function delegateCallSwap(bytes memory data) public returns (bytes memory) {\r\n        (bool success, bytes memory returnData) = phxSwapLib.delegatecall(data);\r\n        assembly {\r\n            if eq(success, 0) {\r\n                revert(add(returnData, 0x20), returndatasize)\r\n            }\r\n        }\r\n        return returnData;\r\n    }\r\n    function _swap(address token0,address token1,uint256 amountSell) internal returns (uint256){\r\n        return abi.decode(delegateCallSwap(abi.encodeWithSignature(\"swap(address,address,address,uint256)\",swapRouter,token0,token1,amountSell)), (uint256));\r\n    }\r\n    function _buy(leverageInfo memory coinInfo,uint256 amount,uint256 minAmount,uint256 deadLine,bool bFirstToken) ensure(deadLine) notHalted nonReentrant getUnderlyingPrice internal{\r\n        address inputToken;\r\n        if(bFirstToken){\r\n            inputToken = coinInfo.token;\r\n        }else{\r\n            inputToken = (coinInfo.id == 0) ? hedgeCoin.token : leverageCoin.token;\r\n        }\r\n        amount = getPayableAmount(inputToken,amount);\r\n        require(amount > 0, 'buy amount is zero');\r\n        uint256 userPay = amount;\r\n        amount = redeemFees(buyFee,inputToken,amount);\r\n        uint256 price = _tokenNetworthBuy(coinInfo,currentPrice);\r\n        uint256 leverageAmount = bFirstToken ? amount.mul(calDecimal)/price :\r\n            amount.mulPrice(currentPrice,coinInfo.id)/price;\r\n        require(leverageAmount>=minAmount,\"token amount is less than minAmount\");\r\n        {\r\n            uint256 userLoan = (leverageAmount.mul(coinInfo.rebalanceWorth)/calDecimal).mul(coinInfo.leverageRate-feeDecimal)/feeDecimal;\r\n            userLoan = coinInfo.stakePool.borrow(userLoan);\r\n            amount = bFirstToken ? userLoan.add(amount) : userLoan;\r\n            //98%\r\n            uint256 amountOut = amount.mul(98e16).divPrice(currentPrice,coinInfo.id);\r\n            address token1 = (coinInfo.id == 0) ? hedgeCoin.token : leverageCoin.token;\r\n            amount = _swap(coinInfo.token,token1,amount);\r\n            require(amount>=amountOut, \"swap slip page is more than 2%\");\r\n        }\r\n        coinInfo.leverageToken.mint(msg.sender,leverageAmount);\r\n        price = price.mul(currentPrice[coinInfo.id])/calDecimal;\r\n        if(coinInfo.id == 0){\r\n            emit BuyLeverage(msg.sender,inputToken,userPay,leverageAmount,price);\r\n        }else{\r\n            emit BuyHedge(msg.sender,inputToken,userPay,leverageAmount,price);\r\n        }  \r\n    }\r\n    function _sellSwap(uint8 id,uint256 sellAmount,uint256 userLoan)internal returns(uint256){\r\n        (address token0,address token1) = (id == 0) ? (hedgeCoin.token,leverageCoin.token) : (leverageCoin.token,hedgeCoin.token);\r\n        sellAmount = _swap(token0,token1,sellAmount);\r\n        return sellAmount.sub(userLoan);\r\n    }\r\n    function _sellSwap2(uint8 id,uint256 sellAmount,uint256 userLoan)internal returns(uint256){\r\n        (address token0,address token1) = (id == 0) ? (hedgeCoin.token,leverageCoin.token) : (leverageCoin.token,hedgeCoin.token);\r\n        (uint256 amountIn,) = abi.decode(\r\n            delegateCallSwap(abi.encodeWithSignature(\"sellExactAmount(address,address,address,uint256)\",swapRouter,token0,token1,userLoan)), (uint256,uint256));\r\n        return sellAmount.sub(amountIn);\r\n    }\r\n    function _sell(leverageInfo memory coinInfo,uint256 amount,uint256 minAmount,uint256 deadLine,bool bFirstToken) ensure(deadLine) nonReentrant getUnderlyingPrice internal{\r\n        require(amount > 0, 'sell amount is zero');\r\n        uint256 total = coinInfo.leverageToken.totalSupply();\r\n        uint256 getLoan = coinInfo.stakePool.loan(address(this)).mul(calDecimal);\r\n        uint256 userLoan;\r\n        uint256 sellAmount;\r\n        uint256 userPayback;\r\n        if(total == amount){\r\n            userLoan = getLoan;\r\n            sellAmount = underlyingBalance(coinInfo.id);\r\n        }else{\r\n            userLoan = (amount.mul(coinInfo.rebalanceWorth)/feeDecimal).mul(coinInfo.leverageRate-feeDecimal);\r\n            if(userLoan > getLoan){\r\n                userLoan = getLoan;\r\n            }\r\n            userPayback =  amount.mul(_tokenNetworth(coinInfo,currentPrice));\r\n            sellAmount = userLoan.add(userPayback).divPrice(currentPrice,coinInfo.id);\r\n        }\r\n        userLoan = userLoan/calDecimal;\r\n        address outputToken;\r\n        uint256 sellPrice;\r\n        if (bFirstToken){\r\n            userPayback = _sellSwap(coinInfo.id,sellAmount,userLoan);\r\n            outputToken = coinInfo.token;\r\n            sellPrice = userPayback.mul(currentPrice[coinInfo.id])/amount;\r\n        }else{\r\n            userPayback = _sellSwap2(coinInfo.id,sellAmount,userLoan);\r\n            outputToken = coinInfo.id == 0 ? hedgeCoin.token : leverageCoin.token;\r\n            uint256 id = coinInfo.id == 0 ? 1 : 0;\r\n            sellPrice = userPayback.mul(currentPrice[id])/amount;\r\n        }\r\n        userPayback = redeemFees(sellFee,outputToken,userPayback);\r\n        require(userPayback >= minAmount, \"Repay amount is less than minAmount\");\r\n        _repay(coinInfo,userLoan,false);\r\n        _redeem(msg.sender,outputToken,userPayback);\r\n        //burn must run after getnetworth\r\n        coinInfo.leverageToken.burn(msg.sender,amount);\r\n        if(coinInfo.id == 0){\r\n            emit SellLeverage(msg.sender,outputToken,amount,userPayback,sellPrice);\r\n        }else{\r\n            emit SellHedge(msg.sender,outputToken,amount,userPayback,sellPrice);\r\n        } \r\n    }\r\n    function _settle(leverageInfo storage coinInfo) internal returns(uint256,uint256){\r\n        if (coinInfo.leverageToken.totalSupply() == 0){\r\n            return (0,0);\r\n        }\r\n        uint256 insterest = coinInfo.stakePool.interestRate();\r\n        uint256 totalWorth = _totalWorth(coinInfo,currentPrice).divPrice(currentPrice,coinInfo.id);\r\n        totalWorth = redeemFees(rebalanceFee,(coinInfo.id == 0) ? hedgeCoin.token : leverageCoin.token,totalWorth);\r\n        uint256 oldUnderlying = underlyingBalance(coinInfo.id).mulPrice(currentPrice,coinInfo.id)/calDecimal;\r\n        uint256 oldLoan = coinInfo.stakePool.loan(address(this));\r\n        uint256 oldLoanAdd = oldLoan.mul(feeDecimal)/(feeDecimal.sub(insterest)); \r\n        if(oldUnderlying>oldLoanAdd){ \r\n            uint256 leverageRate = oldUnderlying.mul(feeDecimal)/(oldUnderlying-oldLoanAdd);\r\n            if(leverageRate <defaultLeverageRatio+rebalanceTol &&\r\n                leverageRate >defaultLeverageRatio-rebalanceTol){\r\n                    return (0,0);\r\n            }\r\n        }\r\n        uint256 leverageRate = defaultLeverageRatio;\r\n        //allLoan = allworth*(l-1)/(1+lr-2r)\r\n        uint256 allLoan = oldUnderlying.sub(oldLoan).mul(leverageRate-feeDecimal).mul(feeDecimal);\r\n        allLoan = allLoan/(feeDecimal*feeDecimal+leverageRate*insterest-2*feeDecimal*insterest);\r\n        uint256 poolBorrow = coinInfo.stakePool.borrowLimit(address(this));\r\n        if(allLoan > poolBorrow){\r\n            allLoan = poolBorrow;\r\n            // l = loan(1-r)/(allworth-loan*r) + 1\r\n            totalWorth = oldUnderlying.sub(oldLoan).mul(feeDecimal).sub(allLoan.mul(insterest));\r\n//            leverageRate = allLoan.mul((feeDecimal-insterest)*feeDecimal)/div+feeDecimal;\r\n        }else{\r\n            totalWorth = allLoan.mul((feeDecimal-insterest)*feeDecimal)/(leverageRate-feeDecimal)/feeDecimal;\r\n        }\r\n        uint256 newUnderlying = totalWorth+allLoan;\r\n        if(oldUnderlying>newUnderlying){\r\n            return (0,oldUnderlying-newUnderlying);\r\n        }else{\r\n            return (newUnderlying-oldUnderlying,0);\r\n        }\r\n    }\r\n    function swapRebalance(address token0,address token1,uint256 amountLev,uint256 amountHe,uint256[2] memory prices,uint256 id)internal returns (uint256,uint256){\r\n        return abi.decode(delegateCallSwap(abi.encodeWithSignature(\"swapRebalance(address,address,address,uint256,uint256,uint256[2],uint256)\",\r\n            swapRouter,token0,token1,amountLev,amountHe,prices,id)), (uint256,uint256));\r\n    }\r\n    function rebalance() getUnderlyingPrice OwnerOrOrigin external {\r\n        _rebalance();\r\n    }\r\n    function setForceRebase(uint256 id) external onlyOrigin {\r\n        require(id == 0 || id == 1 ,\"leverageInfo id is error!\");\r\n        if (id == 0){\r\n            leverageCoin.bRebase = true;\r\n        }else{\r\n            hedgeCoin.bRebase = true;\r\n        }\r\n    }\r\n    function _rebalance() internal {\r\n//        uint256 levSlip = calAverageSlip(leverageCoin);\r\n//        uint256 heSlip = calAverageSlip(hedgeCoin);\r\n        (uint256 buyLev,uint256 sellLev) = _settle(leverageCoin);\r\n        emit Rebalance(msg.sender,leverageCoin.token,buyLev,sellLev);\r\n        (uint256 buyHe,uint256 sellHe) = _settle(hedgeCoin);\r\n        emit Rebalance(msg.sender,hedgeCoin.token,buyHe,sellHe);\r\n        rebalancePrices = currentPrice;\r\n        if (buyLev>0){\r\n            leverageCoin.stakePool.borrowAndInterest(buyLev);\r\n        }\r\n        if(buyHe>0){\r\n            hedgeCoin.stakePool.borrowAndInterest(buyHe);\r\n        }\r\n        if (buyLev > 0 && buyHe>0){\r\n            swapRebalance(leverageCoin.token,hedgeCoin.token,buyLev,buyHe,currentPrice,0);\r\n//            delegateCallSwap(abi.encodeWithSignature(\"swapBuyAndBuy(address,address,address,uint256,uint256,uint256[2])\",\r\n//                swapRouter,leverageCoin.token,hedgeCoin.token,buyLev,buyHe,currentPrice));\r\n        }else if(buyLev>0){\r\n            swapRebalance(leverageCoin.token,hedgeCoin.token,buyLev,sellHe,currentPrice,2<<128);\r\n//            delegateCallSwap(abi.encodeWithSignature(\"swapBuyAndSell(address,address,address,uint256,uint256,uint256[2],uint8)\",\r\n//                swapRouter,leverageCoin.token,hedgeCoin.token,buyLev,sellHe.mulPrice(currentPrice,0)/calDecimal,currentPrice,0));\r\n        }else if(buyHe>0){\r\n            swapRebalance(hedgeCoin.token,leverageCoin.token,buyHe,sellLev,currentPrice,(2<<128)+1);\r\n//            delegateCallSwap(abi.encodeWithSignature(\"swapBuyAndSell(address,address,address,uint256,uint256,uint256[2],uint8)\",\r\n//                swapRouter,hedgeCoin.token,leverageCoin.token,buyHe,sellLev.mulPrice(currentPrice,1)/calDecimal,currentPrice,1));\r\n        }else{\r\n            if(sellLev>0 || sellHe> 0){\r\n            (sellLev,sellHe)= swapRebalance(leverageCoin.token,hedgeCoin.token,sellLev,sellHe,currentPrice,1<<128);\r\n//                (sellLev,sellHe)= abi.decode(delegateCallSwap(abi.encodeWithSignature(\"swapSellAndSell(address,address,address,uint256,uint256,uint256[2])\",\r\n//                    swapRouter,leverageCoin.token,hedgeCoin.token,sellLev,sellHe,currentPrice)), (uint256,uint256));\r\n            }\r\n        }\r\n        if(buyLev == 0){\r\n            _repayAndInterest(leverageCoin,sellLev);\r\n        }\r\n        if(buyHe == 0){\r\n            _repayAndInterest(hedgeCoin,sellHe);\r\n        }\r\n        calLeverageInfo(leverageCoin);\r\n        calLeverageInfo(hedgeCoin);\r\n    }\r\n    function calAverageSlip(leverageInfo memory coinInfo) internal view returns(uint256) {\r\n        uint256 loan = coinInfo.stakePool.loan(address(this));\r\n        if(loan>0){\r\n            return underlyingBalance(coinInfo.id).mulPrice(rebalancePrices, coinInfo.id).mul(coinInfo.leverageRate - feeDecimal)/coinInfo.leverageRate/loan/(calDecimal/feeDecimal);\r\n        }else{\r\n            return feeDecimal;\r\n        }\r\n    }\r\n    function calLeverageInfo(leverageInfo storage coinInfo) internal{\r\n        uint256 tokenNum = coinInfo.leverageToken.totalSupply();\r\n        if(tokenNum > 0){\r\n            uint256 balance = underlyingBalance(coinInfo.id).mulPrice(rebalancePrices, coinInfo.id);\r\n            uint256 loan = coinInfo.stakePool.loan(address(this));\r\n            uint256 totalWorth = balance.sub(loan.mul(calDecimal));\r\n            coinInfo.leverageRate = balance.mul(feeDecimal)/totalWorth;\r\n            if (coinInfo.bRebase){\r\n                coinInfo.rebalanceWorth = defaultRebalanceWorth*calDecimal/currentPrice[coinInfo.id];\r\n                coinInfo.bRebase = false;\r\n                coinInfo.leverageToken.calRebaseRatio(totalWorth/coinInfo.rebalanceWorth);\r\n            }else{\r\n                coinInfo.rebalanceWorth = totalWorth/tokenNum;\r\n                coinInfo.bRebase = coinInfo.rebalanceWorth<defaultRebalanceWorth.mul(feeDecimal*calDecimal)/currentPrice[coinInfo.id]/rebaseThreshold;\r\n            }\r\n        }\r\n    }\r\n    function rebalanceAndLiquidate() external getUnderlyingPrice {\r\n        if(checkLiquidate(leverageCoin,currentPrice,liquidateThreshold)){\r\n            _liquidate(leverageCoin);\r\n        }else if(checkLiquidate(hedgeCoin,currentPrice,liquidateThreshold)){\r\n            _liquidate(hedgeCoin);\r\n        }else if(checkLiquidate(leverageCoin,currentPrice,liquidateThreshold*4) || \r\n            checkLiquidate(hedgeCoin,currentPrice,liquidateThreshold*4)){\r\n            _rebalance();\r\n        }else{\r\n            require(false, \"Liquidate: current price is not under the threshold!\");\r\n        }\r\n    }\r\n    function _liquidate(leverageInfo storage coinInfo) internal{\r\n        //all selled\r\n        (address token0,address token1) = (coinInfo.id == 0) ? (hedgeCoin.token,leverageCoin.token) : (leverageCoin.token,hedgeCoin.token);\r\n        uint256 amount = _swap(token0,token1,underlyingBalance(coinInfo.id));\r\n        uint256 fee = amount.mul(rebalanceFee)/feeDecimal;\r\n        uint256 leftAmount = amount.sub(fee);\r\n        uint256 allLoan = coinInfo.stakePool.loan(address(this));\r\n        if (amount<allLoan){\r\n            allLoan = amount;\r\n            leftAmount = amount;\r\n            fee = 0;\r\n        }else if(leftAmount<allLoan){\r\n            leftAmount = allLoan;\r\n            fee = amount-leftAmount;\r\n        }\r\n        if(fee>0){\r\n            _redeem(feeAddress,coinInfo.token, fee);\r\n        } \r\n        _repay(coinInfo,allLoan,true);\r\n        leftAmount = leftAmount -allLoan;\r\n        if(leftAmount>0){\r\n            _redeem(address(uint160(address(coinInfo.leverageToken))),coinInfo.token,leftAmount);\r\n        }\r\n        coinInfo.leverageToken.newErc20(leftAmount);\r\n        emit Liquidate(msg.sender,coinInfo.token,allLoan,fee,leftAmount);\r\n    }\r\n    function _repay(leverageInfo memory coinInfo,uint256 amount,bool bAll)internal{\r\n        if (coinInfo.token == address(0)){\r\n            coinInfo.stakePool.repay.value(amount)(amount,bAll);\r\n        }else{\r\n            coinInfo.stakePool.repay(amount,bAll);\r\n        }\r\n    }\r\n    function _repayAndInterest(leverageInfo memory coinInfo,uint256 amount)internal{\r\n        if (coinInfo.token == address(0)){\r\n            coinInfo.stakePool.repayAndInterest.value(amount)(amount);\r\n        }else{\r\n            coinInfo.stakePool.repayAndInterest(amount);\r\n        }\r\n    }\r\n    function redeemFees(uint256 feeRatio,address token,uint256 amount) internal returns (uint256){\r\n        uint256 fee = amount.mul(feeRatio)/feeDecimal;\r\n        if (fee>0){\r\n            _redeem(feeAddress,token, fee);\r\n        }\r\n        return amount.sub(fee);\r\n    }\r\n    function getUnderlyingPriceView() public view returns(uint256[2]memory){\r\n        uint256[] memory assets = new uint256[](2);\r\n        assets[0] = uint256(leverageCoin.token);\r\n        assets[1] = uint256(hedgeCoin.token);\r\n        uint256[]memory prices = oraclegetPrices(assets);\r\n        return [prices[0],prices[1]];\r\n    }\r\n    function getEnableRebalanceAndLiquidate()external view returns (bool,bool){\r\n        uint256[2]memory prices = getUnderlyingPriceView();\r\n        uint256 threshold = liquidateThreshold*39e7/feeDecimal;\r\n        return (checkLiquidate(leverageCoin,prices,threshold),\r\n                checkLiquidate(hedgeCoin,prices,threshold));\r\n    }\r\n    function checkLiquidate(leverageInfo memory coinInfo,uint256[2]memory prices,uint256 threshold) internal view returns(bool){\r\n        if(coinInfo.leverageToken.totalSupply() == 0){\r\n            return false;\r\n        }\r\n        //3CP < RP*(2+liquidateThreshold)\r\n        return coinInfo.leverageRate.mulPrice(prices,coinInfo.id) < \r\n            (coinInfo.leverageRate-feeDecimal+threshold).mulPrice(rebalancePrices,coinInfo.id);\r\n    }\r\n    modifier ensure(uint deadline) {\r\n        require(deadline >= block.timestamp, 'leveragedPool: EXPIRED');\r\n        _;\r\n    }\r\n    modifier getUnderlyingPrice(){\r\n        currentPrice = getUnderlyingPriceView();\r\n        _;\r\n    }\r\n    modifier notHalted() {\r\n        require(!halted,\"This contract is halted\");\r\n        _;\r\n    }\r\n\r\n    /// @notice function Emergency situation that requires \r\n    /// @notice contribution period to stop or not.\r\n    function setHalt(bool halt) \r\n        public \r\n        onlyOrigin\r\n    {\r\n        halted = halt;\r\n    }\r\n}",
    "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"multiSignature\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Coin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hedgeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"}],\"name\":\"BuyHedge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Coin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"payAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"leverageAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"}],\"name\":\"BuyLeverage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loan\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"leftAmount\",\"type\":\"uint256\"}],\"name\":\"Liquidate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOperator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"OperatorTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOrigin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOrigin\",\"type\":\"address\"}],\"name\":\"OriginTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyAount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellAmount\",\"type\":\"uint256\"}],\"name\":\"Rebalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recieptor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Coin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hedgeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"}],\"name\":\"SellHedge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Coin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"leverageAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"}],\"name\":\"SellLeverage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromCoin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toCoin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toValue\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadLine\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"buyHedge\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadLine\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"buyHedge2\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadLine\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"buyLeverage\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadLine\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"buyLeverage2\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultLeverageRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultRebalanceWorth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"delegateCallSwap\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentLeverageRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEnableRebalanceAndLiquidate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHedgeInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLeverageInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLeverageRebase\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMultiSignatureAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOracleAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"}],\"name\":\"getSwapRoutingPath\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenNetworths\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalworths\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUnderlyingPriceView\",\"outputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementationVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"liquidateThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerExpiredTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_expired\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phxSwapLib\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"rebalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"rebalanceAndLiquidate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rebalanceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rebalancePrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rebalanceTol\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rebaseThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadLine\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"sellHedge\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadLine\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"sellHedge2\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadLine\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"sellLeverage\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadLine\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"sellLeverage2\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"addrFee\",\"type\":\"address\"}],\"name\":\"setFeeAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"setForceRebase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bool\",\"name\":\"halt\",\"type\":\"bool\"}],\"name\":\"setHalt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rebalanceFee\",\"type\":\"uint256\"}],\"name\":\"setLeverageFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_feeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"leveragePool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"hedgePool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_swapRouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"swaplib\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rebaseTokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rebaseTokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rebaseWorth\",\"type\":\"uint256\"}],\"name\":\"setLeveragePoolInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"}],\"name\":\"setOracleAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_swapLib\",\"type\":\"address\"}],\"name\":\"setSwapLibAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_swapRouter\",\"type\":\"address\"}],\"name\":\"setSwapRouterAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"swapPath\",\"type\":\"address[]\"}],\"name\":\"setSwapRoutingPath\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"swapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOrigin\",\"type\":\"address\"}],\"name\":\"transferOrigin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"txOrigin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_origin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"update\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"version_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]",
    "ContractName": "leveragedPool",
    "CompilerVersion": "v0.5.16+commit.9c3226ce",
    "OptimizationUsed": "1",
    "Runs": "200",
    "ConstructorArguments": "0000000000000000000000002c2627e36ed553a6e247f1c608c64725568777ec",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "MIT",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": "bzzr://161c400ff17559753200b829d7d5a4f05a43b4ef49e4fdb1437fa0a5a93ea4c1"
}