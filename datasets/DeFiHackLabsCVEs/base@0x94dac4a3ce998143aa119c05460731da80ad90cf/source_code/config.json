{
    "SourceCode": "{\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"},\"IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"},\"ILeetSwapV2Callee.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ILeetSwapV2Callee {\\n    function hook(\\n        address sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata data\\n    ) external;\\n}\"},\"ILeetSwapV2Factory.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\ninterface ILeetSwapV2Factory {\\n    function allPairsLength() external view returns (uint256);\\n\\n    function isPair(address pair) external view returns (bool);\\n\\n    function pairCodeHash() external pure returns (bytes32);\\n\\n    function getPair(\\n        address tokenA,\\n        address token,\\n        bool stable\\n    ) external view returns (address);\\n\\n    function createPair(\\n        address tokenA,\\n        address tokenB,\\n        bool stable\\n    ) external returns (address);\\n\\n    function createPair(address tokenA, address tokenB)\\n        external\\n        returns (address);\\n\\n    function getInitializable()\\n        external\\n        view\\n        returns (\\n            address token0,\\n            address token1,\\n            bool stable\\n        );\\n\\n    function protocolFeesShare() external view returns (uint256);\\n\\n    function protocolFeesRecipient() external view returns (address);\\n\\n    function tradingFees(address pair, address to)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function isPaused() external view returns (bool);\\n}\"},\"ILeetSwapV2Pair.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\ninterface ILeetSwapV2Pair {\\n    function factory() external view returns (address);\\n\\n    function fees() external view returns (address);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function burn(address to)\\n        external\\n        returns (uint256 amount0, uint256 amount1);\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint256 _reserve0,\\n            uint256 _reserve1,\\n            uint256 _blockTimestampLast\\n        );\\n\\n    function getAmountOut(uint256, address) external view returns (uint256);\\n\\n    function current(address tokenIn, uint256 amountIn)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function stable() external view returns (bool);\\n\\n    function balanceOf(address) external view returns (uint256);\\n\\n    //LP token pricing\\n    function sample(\\n        address tokenIn,\\n        uint256 amountIn,\\n        uint256 points,\\n        uint256 window\\n    ) external view returns (uint256[] memory);\\n\\n    function quote(\\n        address tokenIn,\\n        uint256 amountIn,\\n        uint256 granularity\\n    ) external view returns (uint256);\\n\\n    function claimFeesFor(address account)\\n        external\\n        returns (uint256 claimed0, uint256 claimed1);\\n\\n    function claimFees() external returns (uint256 claimed0, uint256 claimed1);\\n\\n    function claimableFeesFor(address account)\\n        external\\n        returns (uint256 claimed0, uint256 claimed1);\\n\\n    function claimableFees()\\n        external\\n        returns (uint256 claimed0, uint256 claimed1);\\n}\"},\"LeetSwapV2Fees.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n// Base V1 Fees contract is used as a 1:1 pair relationship to split out fees, this ensures that the curve does not need to be modified for LP shares\\ncontract LeetSwapV2Fees {\\n    address internal immutable pair; // The pair it is bonded to\\n    address internal immutable token0; // token0 of pair, saved localy and statically for gas optimization\\n    address internal immutable token1; // Token1 of pair, saved localy and statically for gas optimization\\n\\n    error InvalidToken();\\n    error TransferFailed();\\n    error Unauthorized();\\n\\n    constructor(address _token0, address _token1) {\\n        pair = msg.sender;\\n        token0 = _token0;\\n        token1 = _token1;\\n    }\\n\\n    function _safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        if (token.code.length == 0) revert InvalidToken();\\n        bool success = IERC20(token).transfer(to, value);\\n        if (!success) revert TransferFailed();\\n    }\\n\\n    // Allow the pair to transfer fees to users\\n    function claimFeesFor(\\n        address recipient,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) external {\\n        if (msg.sender != pair) revert Unauthorized();\\n        if (amount0 \\u003e 0) _safeTransfer(token0, recipient, amount0);\\n        if (amount1 \\u003e 0) _safeTransfer(token1, recipient, amount1);\\n    }\\n}\"},\"LeetSwapV2Pair.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./LeetSwapV2Fees.sol\\\";\\nimport \\\"./ILeetSwapV2Factory.sol\\\";\\nimport \\\"./ILeetSwapV2Pair.sol\\\";\\nimport \\\"./ILeetSwapV2Callee.sol\\\";\\nimport \\\"./Math.sol\\\";\\nimport \\\"./IERC20Metadata.sol\\\";\\n\\n// The base pair of pools, either stable or volatile\\ncontract LeetSwapV2Pair is ILeetSwapV2Pair {\\n    uint8 public constant decimals = 18;\\n\\n    // Used to denote stable or volatile pair, not immutable since construction happens in the initialize method for CREATE2 deterministic addresses\\n    bool public immutable stable;\\n\\n    uint256 public totalSupply = 0;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public allowance;\\n    mapping(address =\\u003e uint256) public balanceOf;\\n\\n    bytes32 internal DOMAIN_SEPARATOR;\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 internal constant PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    mapping(address =\\u003e uint256) public nonces;\\n\\n    uint256 public constant MINIMUM_LIQUIDITY = 10**3;\\n\\n    address public immutable token0;\\n    address public immutable token1;\\n    address public immutable fees;\\n    address public immutable factory;\\n\\n    // Structure to capture time period observations every 30 minutes, used for local oracles\\n    struct Observation {\\n        uint256 timestamp;\\n        uint256 reserve0Cumulative;\\n        uint256 reserve1Cumulative;\\n    }\\n\\n    // Capture oracle reading every 30 minutes\\n    uint256 constant periodSize = 1800;\\n\\n    Observation[] public observations;\\n\\n    uint256 public reserve0;\\n    uint256 public reserve1;\\n    uint256 public blockTimestampLast;\\n\\n    uint256 public reserve0CumulativeLast;\\n    uint256 public reserve1CumulativeLast;\\n\\n    // index0 and index1 are used to accumulate fees, this is split out from normal trades to keep the swap \\\"clean\\\"\\n    // this further allows LP holders to easily claim fees for tokens they have/staked\\n    uint256 public index0 = 0;\\n    uint256 public index1 = 0;\\n\\n    // position assigned to each LP to track their current index0 \\u0026 index1 vs the global position\\n    mapping(address =\\u003e uint256) public supplyIndex0;\\n    mapping(address =\\u003e uint256) public supplyIndex1;\\n\\n    // tracks the amount of unclaimed, but claimable tokens off of fees for token0 and token1\\n    mapping(address =\\u003e uint256) public claimable0;\\n    mapping(address =\\u003e uint256) public claimable1;\\n\\n    event Fees(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\n    event Burn(\\n        address indexed sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        address indexed to\\n    );\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint256 reserve0, uint256 reserve1);\\n    event Claim(\\n        address indexed sender,\\n        address indexed recipient,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 amount\\n    );\\n\\n    error DEXPaused();\\n    error InvalidToken();\\n    error TransferFailed();\\n    error InsufficientOutputAmount();\\n    error InsufficientInputAmount();\\n    error InsufficientLiquidity();\\n    error ReentrancyGuard();\\n    error DeadlineExpired();\\n    error InsufficientLiquidityMinted();\\n    error InsufficientLiquidityBurned();\\n    error InvariantNotRespected();\\n    error InvalidSwapRecipient();\\n    error InvalidSignature();\\n\\n    constructor() {\\n        factory = msg.sender;\\n        (address _token0, address _token1, bool _stable) = ILeetSwapV2Factory(\\n            msg.sender\\n        ).getInitializable();\\n        (token0, token1, stable) = (_token0, _token1, _stable);\\n\\n        fees = address(new LeetSwapV2Fees(_token0, _token1));\\n\\n        observations.push(Observation(block.timestamp, 0, 0));\\n    }\\n\\n    function decimals0() internal view returns (uint256) {\\n        return 10**IERC20Metadata(token0).decimals();\\n    }\\n\\n    function decimals1() internal view returns (uint256) {\\n        return 10**IERC20Metadata(token1).decimals();\\n    }\\n\\n    function name() public view returns (string memory) {\\n        if (stable) {\\n            return\\n                string(\\n                    abi.encodePacked(\\n                        \\\"LeetSwapV2 StableV1 Pair - \\\",\\n                        IERC20Metadata(token0).symbol(),\\n                        \\\"/\\\",\\n                        IERC20Metadata(token1).symbol()\\n                    )\\n                );\\n        }\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"LeetSwapV2 VolatileV1 Pair - \\\",\\n                    IERC20Metadata(token0).symbol(),\\n                    \\\"/\\\",\\n                    IERC20Metadata(token1).symbol()\\n                )\\n            );\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        if (stable) {\\n            return\\n                string(\\n                    abi.encodePacked(\\n                        \\\"sLS2-\\\",\\n                        IERC20Metadata(token0).symbol(),\\n                        \\\"/\\\",\\n                        IERC20Metadata(token1).symbol()\\n                    )\\n                );\\n        }\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"vLS2-\\\",\\n                    IERC20Metadata(token0).symbol(),\\n                    \\\"/\\\",\\n                    IERC20Metadata(token1).symbol()\\n                )\\n            );\\n    }\\n\\n    // simple re-entrancy check\\n    uint256 internal _unlocked = 1;\\n    modifier lock() {\\n        if (_unlocked != 1) revert ReentrancyGuard();\\n        _unlocked = 2;\\n        _;\\n        _unlocked = 1;\\n    }\\n\\n    function observationLength() external view returns (uint256) {\\n        return observations.length;\\n    }\\n\\n    function lastObservation() public view returns (Observation memory) {\\n        return observations[observations.length - 1];\\n    }\\n\\n    function metadata()\\n        external\\n        view\\n        returns (\\n            uint256 dec0,\\n            uint256 dec1,\\n            uint256 r0,\\n            uint256 r1,\\n            bool st,\\n            address t0,\\n            address t1\\n        )\\n    {\\n        return (\\n            decimals0(),\\n            decimals1(),\\n            reserve0,\\n            reserve1,\\n            stable,\\n            token0,\\n            token1\\n        );\\n    }\\n\\n    function tokens() external view returns (address, address) {\\n        return (token0, token1);\\n    }\\n\\n    // claim accumulated but unclaimed fees (viewable via claimable0 and claimable1)\\n    function claimFees() external returns (uint256 claimed0, uint256 claimed1) {\\n        return claimFeesFor(msg.sender);\\n    }\\n\\n    function claimFeesFor(address recipient)\\n        public\\n        lock\\n        returns (uint256 claimed0, uint256 claimed1)\\n    {\\n        _updateFor(recipient);\\n\\n        claimed0 = claimable0[recipient];\\n        claimed1 = claimable1[recipient];\\n\\n        claimable0[recipient] = 0;\\n        claimable1[recipient] = 0;\\n\\n        LeetSwapV2Fees(fees).claimFeesFor(recipient, claimed0, claimed1);\\n\\n        emit Claim(msg.sender, recipient, claimed0, claimed1);\\n    }\\n\\n    function claimableFeesFor(address account)\\n        public\\n        view\\n        returns (uint256 _claimable0, uint256 _claimable1)\\n    {\\n        uint256 _supplied = balanceOf[account];\\n        _claimable0 = claimable0[account];\\n        _claimable1 = claimable1[account];\\n        if (_supplied \\u003e 0) {\\n            uint256 _delta0 = index0 - supplyIndex0[account];\\n            uint256 _delta1 = index1 - supplyIndex1[account];\\n            if (_delta0 \\u003e 0) {\\n                uint256 _share = (_supplied * _delta0) / 1e18;\\n                _claimable0 += _share;\\n            }\\n            if (_delta1 \\u003e 0) {\\n                uint256 _share = (_supplied * _delta1) / 1e18;\\n                _claimable1 += _share;\\n            }\\n        }\\n    }\\n\\n    function claimableFees()\\n        external\\n        view\\n        returns (uint256 _claimable0, uint256 _claimable1)\\n    {\\n        return claimableFeesFor(msg.sender);\\n    }\\n\\n    // Used to transfer fees when calling _update[01]\\n    function _transferFeesSupportingTaxTokens(address token, uint256 amount)\\n        public\\n        returns (uint256)\\n    {\\n        if (amount == 0) {\\n            return 0;\\n        }\\n\\n        uint256 balanceBefore = IERC20(token).balanceOf(fees);\\n        _safeTransfer(token, fees, amount);\\n        uint256 balanceAfter = IERC20(token).balanceOf(fees);\\n\\n        return balanceAfter - balanceBefore;\\n    }\\n\\n    // Accrue fees on token0\\n    function _update0(uint256 amount) internal {\\n        uint256 _protocolFeesShare = ILeetSwapV2Factory(factory)\\n            .protocolFeesShare();\\n        address _protocolFeesRecipient = ILeetSwapV2Factory(factory)\\n            .protocolFeesRecipient();\\n        uint256 _protocolFeesAmount = (amount * _protocolFeesShare) / 10000;\\n        amount = _transferFeesSupportingTaxTokens(\\n            token0,\\n            amount - _protocolFeesAmount\\n        );\\n        if (_protocolFeesAmount \\u003e 0)\\n            _safeTransfer(token0, _protocolFeesRecipient, _protocolFeesAmount);\\n        uint256 _ratio = (amount * 1e18) / totalSupply;\\n        if (_ratio \\u003e 0) {\\n            index0 += _ratio;\\n        }\\n        emit Fees(msg.sender, amount, 0);\\n    }\\n\\n    // Accrue fees on token1\\n    function _update1(uint256 amount) internal {\\n        uint256 _protocolFeesShare = ILeetSwapV2Factory(factory)\\n            .protocolFeesShare();\\n        address _protocolFeesRecipient = ILeetSwapV2Factory(factory)\\n            .protocolFeesRecipient();\\n        uint256 _protocolFeesAmount = (amount * _protocolFeesShare) / 10000;\\n        amount = _transferFeesSupportingTaxTokens(\\n            token1,\\n            amount - _protocolFeesAmount\\n        );\\n        if (_protocolFeesAmount \\u003e 0)\\n            _safeTransfer(token1, _protocolFeesRecipient, _protocolFeesAmount);\\n        uint256 _ratio = (amount * 1e18) / totalSupply;\\n        if (_ratio \\u003e 0) {\\n            index1 += _ratio;\\n        }\\n        emit Fees(msg.sender, 0, amount);\\n    }\\n\\n    // this function MUST be called on any balance changes, otherwise can be used to infinitely claim fees\\n    // Fees are segregated from core funds, so fees can never put liquidity at risk\\n    function _updateFor(address recipient) internal {\\n        uint256 _supplied = balanceOf[recipient]; // get LP balance of `recipient`\\n        if (_supplied \\u003e 0) {\\n            uint256 _supplyIndex0 = supplyIndex0[recipient]; // get last adjusted index0 for recipient\\n            uint256 _supplyIndex1 = supplyIndex1[recipient];\\n            uint256 _index0 = index0; // get global index0 for accumulated fees\\n            uint256 _index1 = index1;\\n            supplyIndex0[recipient] = _index0; // update user current position to global position\\n            supplyIndex1[recipient] = _index1;\\n            uint256 _delta0 = _index0 - _supplyIndex0; // see if there is any difference that need to be accrued\\n            uint256 _delta1 = _index1 - _supplyIndex1;\\n            if (_delta0 \\u003e 0) {\\n                uint256 _share = (_supplied * _delta0) / 1e18; // add accrued difference for each supplied token\\n                claimable0[recipient] += _share;\\n            }\\n            if (_delta1 \\u003e 0) {\\n                uint256 _share = (_supplied * _delta1) / 1e18;\\n                claimable1[recipient] += _share;\\n            }\\n        } else {\\n            supplyIndex0[recipient] = index0; // new users are set to the default global state\\n            supplyIndex1[recipient] = index1;\\n        }\\n    }\\n\\n    function getReserves()\\n        public\\n        view\\n        returns (\\n            uint256 _reserve0,\\n            uint256 _reserve1,\\n            uint256 _blockTimestampLast\\n        )\\n    {\\n        _reserve0 = reserve0;\\n        _reserve1 = reserve1;\\n        _blockTimestampLast = blockTimestampLast;\\n    }\\n\\n    // update reserves and, on the first call per block, price accumulators\\n    function _update(\\n        uint256 balance0,\\n        uint256 balance1,\\n        uint256 _reserve0,\\n        uint256 _reserve1\\n    ) internal {\\n        uint256 blockTimestamp = block.timestamp;\\n        uint256 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n        if (timeElapsed \\u003e 0 \\u0026\\u0026 _reserve0 != 0 \\u0026\\u0026 _reserve1 != 0) {\\n            reserve0CumulativeLast += _reserve0 * timeElapsed;\\n            reserve1CumulativeLast += _reserve1 * timeElapsed;\\n        }\\n\\n        Observation memory _point = lastObservation();\\n        timeElapsed = blockTimestamp - _point.timestamp; // compare the last observation with current timestamp, if greater than 30 minutes, record a new event\\n        if (timeElapsed \\u003e periodSize) {\\n            observations.push(\\n                Observation(\\n                    blockTimestamp,\\n                    reserve0CumulativeLast,\\n                    reserve1CumulativeLast\\n                )\\n            );\\n        }\\n        reserve0 = balance0;\\n        reserve1 = balance1;\\n        blockTimestampLast = blockTimestamp;\\n        emit Sync(reserve0, reserve1);\\n    }\\n\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n    function currentCumulativePrices()\\n        public\\n        view\\n        returns (\\n            uint256 reserve0Cumulative,\\n            uint256 reserve1Cumulative,\\n            uint256 blockTimestamp\\n        )\\n    {\\n        blockTimestamp = block.timestamp;\\n        reserve0Cumulative = reserve0CumulativeLast;\\n        reserve1Cumulative = reserve1CumulativeLast;\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (\\n            uint256 _reserve0,\\n            uint256 _reserve1,\\n            uint256 _blockTimestampLast\\n        ) = getReserves();\\n        if (_blockTimestampLast != blockTimestamp) {\\n            // subtraction overflow is desired\\n            uint256 timeElapsed = blockTimestamp - _blockTimestampLast;\\n            reserve0Cumulative += _reserve0 * timeElapsed;\\n            reserve1Cumulative += _reserve1 * timeElapsed;\\n        }\\n    }\\n\\n    // gives the current twap price measured from amountIn * tokenIn gives amountOut\\n    function current(address tokenIn, uint256 amountIn)\\n        external\\n        view\\n        returns (uint256 amountOut)\\n    {\\n        Observation memory _observation = lastObservation();\\n        (\\n            uint256 reserve0Cumulative,\\n            uint256 reserve1Cumulative,\\n\\n        ) = currentCumulativePrices();\\n        if (block.timestamp == _observation.timestamp) {\\n            _observation = observations[observations.length - 2];\\n        }\\n\\n        uint256 timeElapsed = block.timestamp - _observation.timestamp;\\n        uint256 _reserve0 = (reserve0Cumulative -\\n            _observation.reserve0Cumulative) / timeElapsed;\\n        uint256 _reserve1 = (reserve1Cumulative -\\n            _observation.reserve1Cumulative) / timeElapsed;\\n        amountOut = _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\\n    }\\n\\n    // as per `current`, however allows user configured granularity, up to the full window size\\n    function quote(\\n        address tokenIn,\\n        uint256 amountIn,\\n        uint256 granularity\\n    ) external view returns (uint256 amountOut) {\\n        uint256[] memory _prices = sample(tokenIn, amountIn, granularity, 1);\\n        uint256 priceAverageCumulative;\\n        for (uint256 i = 0; i \\u003c _prices.length; i++) {\\n            priceAverageCumulative += _prices[i];\\n        }\\n        return priceAverageCumulative / granularity;\\n    }\\n\\n    // returns a memory set of twap prices\\n    function prices(\\n        address tokenIn,\\n        uint256 amountIn,\\n        uint256 points\\n    ) external view returns (uint256[] memory) {\\n        return sample(tokenIn, amountIn, points, 1);\\n    }\\n\\n    function sample(\\n        address tokenIn,\\n        uint256 amountIn,\\n        uint256 points,\\n        uint256 window\\n    ) public view returns (uint256[] memory) {\\n        uint256[] memory _prices = new uint256[](points);\\n\\n        uint256 length = observations.length - 1;\\n        uint256 i = length - (points * window);\\n        uint256 nextIndex = 0;\\n        uint256 index = 0;\\n\\n        for (; i \\u003c length; i += window) {\\n            nextIndex = i + window;\\n            uint256 timeElapsed = observations[nextIndex].timestamp -\\n                observations[i].timestamp;\\n            uint256 _reserve0 = (observations[nextIndex].reserve0Cumulative -\\n                observations[i].reserve0Cumulative) / timeElapsed;\\n            uint256 _reserve1 = (observations[nextIndex].reserve1Cumulative -\\n                observations[i].reserve1Cumulative) / timeElapsed;\\n            _prices[index] = _getAmountOut(\\n                amountIn,\\n                tokenIn,\\n                _reserve0,\\n                _reserve1\\n            );\\n            index = index + 1;\\n        }\\n        return _prices;\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    // standard uniswap v2 implementation\\n    function mint(address to) external lock returns (uint256 liquidity) {\\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\\n        uint256 _balance0 = IERC20Metadata(token0).balanceOf(address(this));\\n        uint256 _balance1 = IERC20Metadata(token1).balanceOf(address(this));\\n        uint256 _amount0 = _balance0 - _reserve0;\\n        uint256 _amount1 = _balance1 - _reserve1;\\n\\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n        if (_totalSupply == 0) {\\n            liquidity = Math.sqrt(_amount0 * _amount1) - MINIMUM_LIQUIDITY;\\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\\n        } else {\\n            liquidity = Math.min(\\n                (_amount0 * _totalSupply) / _reserve0,\\n                (_amount1 * _totalSupply) / _reserve1\\n            );\\n        }\\n        if (liquidity \\u003c= 0) revert InsufficientLiquidityMinted();\\n        _mint(to, liquidity);\\n\\n        _update(_balance0, _balance1, _reserve0, _reserve1);\\n        emit Mint(msg.sender, _amount0, _amount1);\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    // standard uniswap v2 implementation\\n    function burn(address to)\\n        external\\n        lock\\n        returns (uint256 amount0, uint256 amount1)\\n    {\\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\\n        (address _token0, address _token1) = (token0, token1);\\n        uint256 _balance0 = IERC20Metadata(_token0).balanceOf(address(this));\\n        uint256 _balance1 = IERC20Metadata(_token1).balanceOf(address(this));\\n        uint256 _liquidity = balanceOf[address(this)];\\n\\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\\n        amount0 = (_liquidity * _balance0) / _totalSupply; // using balances ensures pro-rata distribution\\n        amount1 = (_liquidity * _balance1) / _totalSupply; // using balances ensures pro-rata distribution\\n        if (amount0 \\u003c= 0 || amount1 \\u003c= 0) revert InsufficientLiquidityBurned();\\n        _burn(address(this), _liquidity);\\n        _safeTransfer(_token0, to, amount0);\\n        _safeTransfer(_token1, to, amount1);\\n        _balance0 = IERC20Metadata(_token0).balanceOf(address(this));\\n        _balance1 = IERC20Metadata(_token1).balanceOf(address(this));\\n\\n        _update(_balance0, _balance1, _reserve0, _reserve1);\\n        emit Burn(msg.sender, amount0, amount1, to);\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external lock {\\n        if (ILeetSwapV2Factory(factory).isPaused()) revert DEXPaused();\\n        if (amount0Out \\u003c= 0 \\u0026\\u0026 amount1Out \\u003c= 0)\\n            revert InsufficientOutputAmount();\\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\\n        if (amount0Out \\u003e= _reserve0 || amount1Out \\u003e= _reserve1)\\n            revert InsufficientLiquidity();\\n\\n        uint256 _balance0;\\n        uint256 _balance1;\\n        {\\n            // scope for _token{0,1}, avoids stack too deep errors\\n            (address _token0, address _token1) = (token0, token1);\\n            if (to == _token0 || to == _token1) revert InvalidSwapRecipient();\\n            if (amount0Out \\u003e 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\\n            if (amount1Out \\u003e 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\\n            if (data.length \\u003e 0)\\n                ILeetSwapV2Callee(to).hook(\\n                    msg.sender,\\n                    amount0Out,\\n                    amount1Out,\\n                    data\\n                ); // callback, used for flash loans\\n            _balance0 = IERC20Metadata(_token0).balanceOf(address(this));\\n            _balance1 = IERC20Metadata(_token1).balanceOf(address(this));\\n        }\\n        uint256 amount0In = _balance0 \\u003e _reserve0 - amount0Out\\n            ? _balance0 - (_reserve0 - amount0Out)\\n            : 0;\\n        uint256 amount1In = _balance1 \\u003e _reserve1 - amount1Out\\n            ? _balance1 - (_reserve1 - amount1Out)\\n            : 0;\\n        if (amount0In \\u003c= 0 \\u0026\\u0026 amount1In \\u003c= 0) revert InsufficientInputAmount();\\n        {\\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\\n            (address _token0, address _token1) = (token0, token1);\\n            uint256 _tradingFees = ILeetSwapV2Factory(factory).tradingFees(\\n                address(this),\\n                to\\n            );\\n            if (amount0In \\u003e 0) _update0((amount0In * _tradingFees) / 10000); // accrue fees for token0 and move them out of pool\\n            if (amount1In \\u003e 0) _update1((amount1In * _tradingFees) / 10000); // accrue fees for token1 and move them out of pool\\n            _balance0 = IERC20Metadata(_token0).balanceOf(address(this)); // since we removed tokens, we need to reconfirm balances, can also simply use previous balance - amountIn/ 10000, but doing balanceOf again as safety check\\n            _balance1 = IERC20Metadata(_token1).balanceOf(address(this));\\n            // The curve, either x3y+y3x for stable pools, or x*y for volatile pools\\n            if (_k(_balance0, _balance1) \\u003c _k(_reserve0, _reserve1))\\n                revert InvariantNotRespected();\\n        }\\n\\n        _update(_balance0, _balance1, _reserve0, _reserve1);\\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\\n    }\\n\\n    // force balances to match reserves\\n    function skim(address to) external lock {\\n        (address _token0, address _token1) = (token0, token1);\\n        _safeTransfer(\\n            _token0,\\n            to,\\n            IERC20Metadata(_token0).balanceOf(address(this)) - (reserve0)\\n        );\\n        _safeTransfer(\\n            _token1,\\n            to,\\n            IERC20Metadata(_token1).balanceOf(address(this)) - (reserve1)\\n        );\\n    }\\n\\n    // force reserves to match balances\\n    function sync() external lock {\\n        _update(\\n            IERC20Metadata(token0).balanceOf(address(this)),\\n            IERC20Metadata(token1).balanceOf(address(this)),\\n            reserve0,\\n            reserve1\\n        );\\n    }\\n\\n    function _f(uint256 x0, uint256 y) internal pure returns (uint256) {\\n        return\\n            (x0 * ((((y * y) / 1e18) * y) / 1e18)) /\\n            1e18 +\\n            (((((x0 * x0) / 1e18) * x0) / 1e18) * y) /\\n            1e18;\\n    }\\n\\n    function _d(uint256 x0, uint256 y) internal pure returns (uint256) {\\n        return\\n            (3 * x0 * ((y * y) / 1e18)) /\\n            1e18 +\\n            ((((x0 * x0) / 1e18) * x0) / 1e18);\\n    }\\n\\n    function _get_y(\\n        uint256 x0,\\n        uint256 xy,\\n        uint256 y\\n    ) internal pure returns (uint256) {\\n        for (uint256 i = 0; i \\u003c 255; i++) {\\n            uint256 y_prev = y;\\n            uint256 k = _f(x0, y);\\n            if (k \\u003c xy) {\\n                uint256 dy = ((xy - k) * 1e18) / _d(x0, y);\\n                y = y + dy;\\n            } else {\\n                uint256 dy = ((k - xy) * 1e18) / _d(x0, y);\\n                y = y - dy;\\n            }\\n            if (y \\u003e y_prev) {\\n                if (y - y_prev \\u003c= 1) {\\n                    return y;\\n                }\\n            } else {\\n                if (y_prev - y \\u003c= 1) {\\n                    return y;\\n                }\\n            }\\n        }\\n        return y;\\n    }\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        address tokenIn,\\n        address to\\n    ) public view returns (uint256) {\\n        (uint256 _reserve0, uint256 _reserve1) = (reserve0, reserve1);\\n        uint256 _tradingFees = ILeetSwapV2Factory(factory).tradingFees(\\n            address(this),\\n            to\\n        );\\n        amountIn -= (amountIn * _tradingFees) / 10000; // remove fee from amount received\\n        return _getAmountOut(amountIn, tokenIn, _reserve0, _reserve1);\\n    }\\n\\n    function getAmountOut(uint256 amountIn, address tokenIn)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return getAmountOut(amountIn, tokenIn, msg.sender);\\n    }\\n\\n    function _getAmountOut(\\n        uint256 amountIn,\\n        address tokenIn,\\n        uint256 _reserve0,\\n        uint256 _reserve1\\n    ) internal view returns (uint256) {\\n        if (stable) {\\n            uint256 xy = _k(_reserve0, _reserve1);\\n            _reserve0 = (_reserve0 * 1e18) / decimals0();\\n            _reserve1 = (_reserve1 * 1e18) / decimals1();\\n            (uint256 reserveA, uint256 reserveB) = tokenIn == token0\\n                ? (_reserve0, _reserve1)\\n                : (_reserve1, _reserve0);\\n            amountIn = tokenIn == token0\\n                ? (amountIn * 1e18) / decimals0()\\n                : (amountIn * 1e18) / decimals1();\\n            uint256 y = reserveB - _get_y(amountIn + reserveA, xy, reserveB);\\n            return (y * (tokenIn == token0 ? decimals1() : decimals0())) / 1e18;\\n        } else {\\n            (uint256 reserveA, uint256 reserveB) = tokenIn == token0\\n                ? (_reserve0, _reserve1)\\n                : (_reserve1, _reserve0);\\n            return (amountIn * reserveB) / (reserveA + amountIn);\\n        }\\n    }\\n\\n    function _k(uint256 x, uint256 y) internal view returns (uint256) {\\n        if (stable) {\\n            uint256 _x = (x * 1e18) / decimals0();\\n            uint256 _y = (y * 1e18) / decimals1();\\n            uint256 _a = (_x * _y) / 1e18;\\n            uint256 _b = ((_x * _x) / 1e18 + (_y * _y) / 1e18);\\n            return (_a * _b) / 1e18; // x3y+y3x \\u003e= k\\n        } else {\\n            return x * y; // xy \\u003e= k\\n        }\\n    }\\n\\n    function _mint(address dst, uint256 amount) internal {\\n        _updateFor(dst); // balances must be updated on mint/burn/transfer\\n        totalSupply += amount;\\n        balanceOf[dst] += amount;\\n        emit Transfer(address(0), dst, amount);\\n    }\\n\\n    function _burn(address dst, uint256 amount) internal {\\n        _updateFor(dst);\\n        totalSupply -= amount;\\n        balanceOf[dst] -= amount;\\n        emit Transfer(dst, address(0), amount);\\n    }\\n\\n    function approve(address spender, uint256 amount) external returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        if (deadline \\u003c block.timestamp) revert DeadlineExpired();\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                ),\\n                keccak256(bytes(name())),\\n                keccak256(bytes(\\\"1\\\")),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        PERMIT_TYPEHASH,\\n                        owner,\\n                        spender,\\n                        value,\\n                        nonces[owner]++,\\n                        deadline\\n                    )\\n                )\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        if (recoveredAddress == address(0) || recoveredAddress != owner)\\n            revert InvalidSignature();\\n        allowance[owner][spender] = value;\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function transfer(address dst, uint256 amount) external returns (bool) {\\n        _transferTokens(msg.sender, dst, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 amount\\n    ) external returns (bool) {\\n        address spender = msg.sender;\\n        uint256 spenderAllowance = allowance[src][spender];\\n\\n        if (spender != src \\u0026\\u0026 spenderAllowance != type(uint256).max) {\\n            uint256 newAllowance = spenderAllowance - amount;\\n            allowance[src][spender] = newAllowance;\\n\\n            emit Approval(src, spender, newAllowance);\\n        }\\n\\n        _transferTokens(src, dst, amount);\\n        return true;\\n    }\\n\\n    function _transferTokens(\\n        address src,\\n        address dst,\\n        uint256 amount\\n    ) internal {\\n        _updateFor(src); // update fee position for src\\n        _updateFor(dst); // update fee position for dst\\n\\n        balanceOf[src] -= amount;\\n        balanceOf[dst] += amount;\\n\\n        emit Transfer(src, dst, amount);\\n    }\\n\\n    function _safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        if (token.code.length == 0) revert InvalidToken();\\n        bool success = IERC20(token).transfer(to, value);\\n        if (!success) revert TransferFailed();\\n    }\\n}\"},\"Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary Math {\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a \\u003c b ? a : b;\\n    }\\n\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y \\u003e 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x \\u003c z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\"}}",
    "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DEXPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DeadlineExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientInputAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientLiquidity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientLiquidityBurned\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientLiquidityMinted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientOutputAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSwapRecipient\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvariantNotRespected\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuard\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"Fees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0Out\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1Out\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserve0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserve1\",\"type\":\"uint256\"}],\"name\":\"Sync\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MINIMUM_LIQUIDITY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_transferFeesSupportingTaxTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockTimestampLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimed0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimed1\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"claimFeesFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimed0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimed1\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimable0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimable1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimableFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_claimable0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_claimable1\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"claimableFeesFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_claimable0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_claimable1\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"current\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentCumulativePrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reserve0Cumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve1Cumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fees\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_reserve0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserve1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_blockTimestampLast\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"index0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"index1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastObservation\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve0Cumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve1Cumulative\",\"type\":\"uint256\"}],\"internalType\":\"struct LeetSwapV2Pair.Observation\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadata\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dec0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dec1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"r0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"r1\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"st\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"t0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"t1\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"observationLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"observations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve0Cumulative\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserve1Cumulative\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"}],\"name\":\"prices\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"granularity\",\"type\":\"uint256\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserve0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserve0CumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserve1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserve1CumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"points\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"window\",\"type\":\"uint256\"}],\"name\":\"sample\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"skim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supplyIndex0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supplyIndex1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0Out\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Out\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
    "ContractName": "LeetSwapV2Pair",
    "CompilerVersion": "v0.8.17+commit.8df45f5f",
    "OptimizationUsed": "1",
    "Runs": "200",
    "ConstructorArguments": "",
    "EVMVersion": "Default",
    "Library": "",
    "LicenseType": "MIT",
    "Proxy": "0",
    "Implementation": "",
    "SwarmSource": "ipfs://dc778242d15758937c23a3da526868d4daa725d62e0fc4e62840da8e06340387"
}