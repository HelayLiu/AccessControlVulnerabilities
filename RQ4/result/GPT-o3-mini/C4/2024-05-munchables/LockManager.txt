Below is one example of a potential access control issue found during the audit. (Note that many functions are protected by role‐ or admin–based modifiers, and most setters affect only the caller’s own state. However, one function below accepts an arbitrary “recipient” address without verifying that the caller is permitted to set another user’s lock information, which may lead to unintended behavior.)

1. Vulnerable function: lockOnBehalf (approximately lines 190–203)  
 • Reason: The function accepts an _onBehalfOf parameter and, if provided, simply uses that address as the “lock recipient” without any additional check to verify that the caller is authorized to affect that specific account. In other words, any user can call lockOnBehalf and supply any main–account address (provided that accountManager.getPlayer returns that address as the “main account”). As a result, an attacker might (for example) lock their own tokens while “assigning” the locked–state (and especially the side–effects such as NFT allocation via nftOverlord.addReveal) to someone else. This behavior may interfere with account states or reward distributions if the target beneficiary did not intend to receive locked tokens and accompanying benefits.  

No other public or external function was found to lack the necessary access control checks before mutating sensitive state or calling other internal functions. (For instance, functions that change configuration or require a specific role are gated with onlyAdmin or onlyOneOfRoles modifiers, and functions that update a user’s own settings—like setLockDuration and unlock—modify only the caller’s own records.)  

It is recommended that the design intent for lockOnBehalf be re-examined. If the goal is to allow locking on behalf of another user, then additional checks (or at least careful documentation and events alerting the “on–behalf” party) may be warranted to avoid misinterpretation or abuse of the function.